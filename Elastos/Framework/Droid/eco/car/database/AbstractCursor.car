
module
{
    interface ICrossProcessCursor;

    interface ICursorWindow;
    
    interface IContentObserver;
    
    interface IDataSetObserver;
    
    interface IContentResolver;
    
    interface IUri;
    
    interface IBundle;

    interface IAbstractCursor
    {
        /* These need to be implemented by subclasses */
        GetCount(
            [out] Int32* counts);

        GetColumnNames(
            [out,callee] ArrayOf<String>* names);

        GetString(
            [in] Int32 column,
            [out] String* value);

        GetShort(
            [in] Int32 column,
            [out] Int16* value);

        GetInt(
            [in] Int32 column,
            [out] Int32* value);

        GetLong(
            [in] Int32 column,
            [out] Int64* value);

        GetFloat(
            [in] Int32 column,
            [out] Float* value);

        GetDouble(
            [in] Int32 column,
            [out] Double* value);

        IsNull(
            [in] Int32 column,
            [out] Boolean* value);

        // TODO implement getBlob in all cursor types 
        GetBlob(
            [in] Int32 column,
            [out,callee] ArrayOf<Byte>* blob);

        /* Methods that may optionally be implemented by subclasses */
        /**@implements
         * returns a pre-filled window, return NULL if no such window
         */            
//        GetWindow(
//            [out] ICursorWindow** window);

        GetColumnCount(
            [out] Int32* count);

        Deactivate();

        DeactivateInternal();

        Requery(
            [out] Boolean* value);

        IsClosed(
            [out] Boolean* value);

        Close();

//      public boolean commitUpdates(Map<? extends Long,? extends Map<String,Object>> values);

        DeleteRow(
            [out] Boolean* value);

        /**@implements
         * This function is called every time the cursor is successfully scrolled
         * to a new position, giving the subclass a chance to update any state it
         * may have. If it returns false the move function will also do so and the
         * cursor will scroll to the beforeFirst position.
         */
//        OnMove(
//            [in] Int32 oldPosition,
//            [in] Int32 newPosition,
//            [out] Boolean* value);
        
//        CopyStringToBuffer(
//            [in] Int32 columnIndex,
//            [in] ICharArrayBuffer* buffer);

    /* -------------------------------------------------------- */
    /* Implementation */

//    public final int getPosition() {
//        return mPos;
//    }

//    public final boolean moveToPosition(int position) {
//        // Make sure position isn't past the end of the cursor
//        final int count = getCount();
//        if (position >= count) {
//            mPos = count;
//            return false;
//        }

        // Make sure position isn't before the beginning of the cursor
//        if (position < 0) {
//            mPos = -1;
//            return false;
//        }

        // Check for no-op moves, and skip the rest of the work for them
//        if (position == mPos) {
//            return true;
//        }

//        boolean result = onMove(mPos, position);
//        if (result == false) {
//            mPos = -1;
//        } else {
//            mPos = position;
//            if (mRowIdColumnIndex != -1) {
//                mCurrentRowID = Long.valueOf(getLong(mRowIdColumnIndex));
//            }
//        }

//        return result;
//    }
    
    /**
     * Copy data from cursor to CursorWindow
     */
//     @implements
//    FillWindow(
//        [in] Int32 position,
//        [in] ICursorWindow* window);

//    public final boolean move(int offset) {
//        return moveToPosition(mPos + offset);
//    }

//    public final boolean moveToFirst() {
//        return moveToPosition(0);
//    }

//    public final boolean moveToLast() {
//        return moveToPosition(getCount() - 1);
//    }

//    public final boolean moveToNext() {
//        return moveToPosition(mPos + 1);
//    }

//    public final boolean moveToPrevious() {
//        return moveToPosition(mPos - 1);
//    }

//    public final boolean isFirst() {
//        return mPos == 0 && getCount() != 0;
//    }

//    public final boolean isLast() {
//        int cnt = getCount();
//        return mPos == (cnt - 1) && cnt != 0;
//    }

//    public final boolean isBeforeFirst() {
//        if (getCount() == 0) {
//            return true;
//        }
//        return mPos == -1;
//    }

//    public final boolean isAfterLast() {
//        if (getCount() == 0) {
//           return true;
//        }
//        return mPos == getCount();
//    }

    GetColumnIndex(
        [in] String columnName,
        [out] Int32* index);

    GetColumnIndexOrThrow(
        [in] String columnName,
        [out] Int32* index);

    GetColumnName(
        [in] Int32 columnIndex,
        [out] String* name);

    /**
     * @hide
     * @deprecated
     */
//    UpdateBlob(
//        [in] Int32 columnIndex,
//        [in] ArrayOf<Byte> value,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    UpdateString(
//        [in] Int32 columnIndex,
//        [in] String value,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    UpdateInt16(
//        [in] Int32 columnIndex, 
//        [in] Int16 value,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    UpdateInt32(
//        [in] Int32 columnIndex, 
//        [in] Int32 value,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    UpdateInt64(
//        [in] Int32 columnIndex,
//        [in] Int64 value,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    UpdateFloat(
//        [in] Int32 columnIndex,
//        [in] Float value,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    UpdateDouble(
//        [in] Int32 columnIndex,
//        [in] Double value,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    UpdateToNull(
//        [in] Int32 columnIndex,
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    Update(
//        [in] Int32 columnIndex,
//        [in] IInterface* obj,
//        [out] Boolean* result);

    /**
     * Returns <code>true</code> if there are pending updates that have not yet been committed.
     * 
     * @return <code>true</code> if there are pending updates that have not yet been committed.
     * @hide
     * @deprecated
     */
//    HasUpdates(
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    AbortUpdates();

    /**
     * @hide
     * @deprecated
     */
//    CommitUpdates(
//        [out] Boolean* result);

    /**
     * @hide
     * @deprecated
     */
//    SupportsUpdates(
//        [out] Boolean* result);


    RegisterContentObserver(
        [in] IContentObserver* observer);

    UnregisterContentObserver(
        [in] IContentObserver* observer);
    
    /**
     * This is hidden until the data set change model has been re-evaluated.
     * @hide
     */
//    protected void notifyDataSetChange() {
//        mDataSetObservable.notifyChanged();
//    }
    
    /**
     * This is hidden until the data set change model has been re-evaluated.
     * @hide
     */
//    protected DataSetObservable getDataSetObservable() {
//        return mDataSetObservable;
        
//    }
      RegisterDataSetObserver(
        [in] IDataSetObserver* observer);

      UnregisterDataSetObserver(
        [in] IDataSetObserver* observer);

    /**
     * Subclasses must call this method when they finish committing updates to notify all
     * observers.
     *
     * @param selfChange
     */
//    protected void onChange(boolean selfChange) {
//        synchronized (mSelfObserverLock) {
//            mContentObservable.dispatchChange(selfChange);
//            if (mNotifyUri != null && selfChange) {
//                mContentResolver.notifyChange(mNotifyUri, mSelfObserver);
//            }
//        }
//    }

    /**
     * Specifies a content URI to watch for changes.
     *
     * @param cr The content resolver from the caller's context.
     * @param notifyUri The URI to watch for changes. This can be a
     * specific row URI, or a base URI for a whole class of content.
     */
     SetNotificationUri(
         [in] IContentResolver* cr,
         [in] IUri* notifyUri);

     GetWantsAllOnMoveCalls(
        [out] Boolean* result);

     GetExtras(
        [out] IBundle** extras);

     Respond(
        [in] IBundle* extras,
        [out] IBundle** result);

    /**
     * This function returns true if the field has been updated and is
     * used in conjunction with {@link #getUpdatedField} to allow subclasses to
     * support reading uncommitted updates. NOTE: This function and
     * {@link #getUpdatedField} should be called together inside of a
     * block synchronized on mUpdatedRows.
     *
     * @param columnIndex the column index of the field to check
     * @return true if the field has been updated, false otherwise
     */
//    protected boolean isFieldUpdated(int columnIndex) {
//        if (mRowIdColumnIndex != -1 && mUpdatedRows.size() > 0) {
//            Map<String, Object> updates = mUpdatedRows.get(mCurrentRowID);
//            if (updates != null && updates.containsKey(getColumnNames()[columnIndex])) {
//                return true;
//            }
//        }
//        return false;
//    }

    /**
     * This function returns the uncommitted updated value for the field
     * at columnIndex.  NOTE: This function and {@link #isFieldUpdated} should
     * be called together inside of a block synchronized on mUpdatedRows.
     *
     * @param columnIndex the column index of the field to retrieve
     * @return the updated value
     */
//    protected Object getUpdatedField(int columnIndex) {
//        Map<String, Object> updates = mUpdatedRows.get(mCurrentRowID);
//        return updates.get(getColumnNames()[columnIndex]);
//    }

    /**
     * This function throws CursorIndexOutOfBoundsException if
     * the cursor position is out of bounds. Subclass implementations of
     * the get functions should call this before attempting
     * to retrieve data.
     *
     * @throws CursorIndexOutOfBoundsException
     */
//    protected void checkPosition() {
//        if (-1 == mPos || getCount() == mPos) {
//            throw new CursorIndexOutOfBoundsException(mPos, getCount());
//        }
//    }

//    @Override
//    protected void finalize() {
//        if (mSelfObserver != null && mSelfObserverRegistered == true) {
//            mContentResolver.unregisterContentObserver(mSelfObserver);
//        }
//    }

    }
}
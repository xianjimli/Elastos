module
{
    merge("os/apartment.car");
    merge("os/Runnable.car");
    merge("os/ClassLoader.car");
    merge("os/Binder.car");
    merge("os/BatteryStats.car");
    merge("os/ParcelFileDescriptor.car");
    merge("os/Bundle.car");
    merge("os/ServiceManager.car");
    merge("os/PatternMatcher.car");
    merge("os/FileObserver.car");
    merge("os/FileStatus.car");
    merge("os/Vibrator.car");
    merge("os/storage/IMountServiceListener.car");
    merge("os/storage/IMountShutdownObserver.car");
    merge("os/storage/IObbActionListener.car");
    merge("os/storage/IMountService.car");

    class CApartment {
        constructor(
            [in] Boolean usingNativeMessageQueue);

        interface IApartment;
    }

    class CClassLoader {
        interface IClassLoader;
    }

    class CParcelFileDescriptor {
        constructor(
            [in] IParcelFileDescriptor* pfd);

        /*package*/ constructor(
            [in] IFileDescriptor* fd);

        interface IParcelFileDescriptor;

        interface IParcelable;
    }

    /**
     * A simple pattern matcher, which is safe to use on untrusted data: it does
     * not provide full reg-exp support, only simple globbing that can not be
     * used maliciously.
     */
    class CPatternMatcher {
        constructor(
            [in] String pattern,
            [in] Int32 type);

        constructor(
            [in] IParcel* src);

        interface IParcelable;

        interface IPatternMatcher;
    }

    class CBundle {
        constructor();
        constructor(
            [in] IBundle* bundle);
        constructor(
            [in] IParcel* parcelledData);
        constructor(
            [in] IParcel* parcelledData,
            [in] Int32 length);
        constructor(
            [in] Int32 capacity);
        interface IBundle;
        interface IParcelable;
    }

    singleton class CServiceManager {
        interface IServiceManager;
    }

    class CVibrator {
        constructor();

        interface IVibrator;
    }
}

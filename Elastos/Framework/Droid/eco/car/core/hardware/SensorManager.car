
module
{
    /* NOTE: sensor IDs must be a power of 2 */

    /**
     * A constant describing an orientation sensor. See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_ORIENTATION = 1; // 1 << 0;

    /**
     * A constant describing an accelerometer. See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_ACCELEROMETER = 2; // 1 << 1;

    /**
     * A constant describing a temperature sensor See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_TEMPERATURE = 4; // 1 << 2;

    /**
     * A constant describing a magnetic sensor See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_MAGNETIC_FIELD = 8; // 1 << 3;

    /**
     * A constant describing an ambient light sensor See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_LIGHT = 16; // 1 << 4;

    /**
     * A constant describing a proximity sensor See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_PROXIMITY = 32; // 1 << 5;

    /**
     * A constant describing a Tricorder See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_TRICORDER = 64; // 1 << 6;

    /**
     * A constant describing an orientation sensor. See
     * {@link android.hardware.SensorListener SensorListener} for more details.
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_ORIENTATION_RAW = 128; // 1 << 7;

    /**
     * A constant that includes all sensors
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_ALL = 0x7F;

    /**
     * Smallest sensor ID
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_MIN = 1; // SENSOR_ORIENTATION;

    /**
     * Largest sensor ID
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_SENSOR_MAX = 64; // ((SENSOR_ALL + 1) >>1);


    /**
     * Index of the X value in the array returned by
     * {@link android.hardware.SensorListener#onSensorChanged}
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_DATA_X = 0;

    /**
     * Index of the Y value in the array returned by
     * {@link android.hardware.SensorListener#onSensorChanged}
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_DATA_Y = 1;

    /**
     * Index of the Z value in the array returned by
     * {@link android.hardware.SensorListener#onSensorChanged}
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_DATA_Z = 2;

    /**
     * Offset to the untransformed values in the array returned by
     * {@link android.hardware.SensorListener#onSensorChanged}
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_RAW_DATA_INDEX = 3;

    /**
     * Index of the untransformed X value in the array returned by
     * {@link android.hardware.SensorListener#onSensorChanged}
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_RAW_DATA_X = 3;

    /**
     * Index of the untransformed Y value in the array returned by
     * {@link android.hardware.SensorListener#onSensorChanged}
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_RAW_DATA_Y = 4;

    /**
     * Index of the untransformed Z value in the array returned by
     * {@link android.hardware.SensorListener#onSensorChanged}
     *
     * @deprecated use {@link android.hardware.Sensor Sensor} instead.
     */
    // @Deprecated
    const SensorManager_RAW_DATA_Z = 5;

    // TODO: ALEX
    /** Standard gravity (g) on Earth. This value is equivalent to 1G */
    const SensorManager_STANDARD_GRAVITY = 9; // 9.80665f;

    /** Sun's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_SUN             = 275; // 275.0f;
    /** Mercury's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_MERCURY         = 3; // 3.70f;
    /** Venus' gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_VENUS           = 8; // 8.87f;
    /** Earth's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_EARTH           = 9; // 9.80665f;
    /** The Moon's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_MOON            = 1; // 1.6f;
    /** Mars' gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_MARS            = 3; // 3.71f;
    /** Jupiter's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_JUPITER         = 23; // 23.12f;
    /** Saturn's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_SATURN          = 8; // 8.96f;
    /** Uranus' gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_URANUS          = 8; // 8.69f;
    /** Neptune's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_NEPTUNE         = 11; // 11.0f;
    /** Pluto's gravity in SI units (m/s^2) */
    const SensorManager_GRAVITY_PLUTO           = 0; // 0.6f;
    /** Gravity (estimate) on the first Death Star in Empire units (m/s^2) */
    const SensorManager_GRAVITY_DEATH_STAR_I    = 0; // 0.000000353036145f;
    /** Gravity on the island */
    const SensorManager_GRAVITY_THE_ISLAND      = 4; // 4.815162342f;


    /** Maximum magnetic field on Earth's surface */
    const SensorManager_MAGNETIC_FIELD_EARTH_MAX = 60; // 60.0f;
    /** Minimum magnetic field on Earth's surface */
    const SensorManager_MAGNETIC_FIELD_EARTH_MIN = 30; // 30.0f;


    /** Standard atmosphere, or average sea-level pressure in hPa (millibar) */
    const SensorManager_PRESSURE_STANDARD_ATMOSPHERE = 1013; // 1013.25f;


    /** Maximum luminance of sunlight in lux */
    const SensorManager_LIGHT_SUNLIGHT_MAX = 120000; // 120000.0f;
    /** luminance of sunlight in lux */
    const SensorManager_LIGHT_SUNLIGHT     = 110000; // 110000.0f;
    /** luminance in shade in lux */
    const SensorManager_LIGHT_SHADE        = 20000; // 20000.0f;
    /** luminance under an overcast sky in lux */
    const SensorManager_LIGHT_OVERCAST     = 10000; // 10000.0f;
    /** luminance at sunrise in lux */
    const SensorManager_LIGHT_SUNRISE      = 400; // 400.0f;
    /** luminance under a cloudy sky in lux */
    const SensorManager_LIGHT_CLOUDY       = 100; // 100.0f;
    /** luminance at night with full moon in lux */
    const SensorManager_LIGHT_FULLMOON     = 0; // 0.25f;
    /** luminance at night with no moon in lux*/
    const SensorManager_LIGHT_NO_MOON      = 0; // 0.001f;


    /** get sensor data as fast as possible */
    const SensorManager_SENSOR_DELAY_FASTEST = 0;
    /** rate suitable for games */
    const SensorManager_SENSOR_DELAY_GAME = 1;
    /** rate suitable for the user interface  */
    const SensorManager_SENSOR_DELAY_UI = 2;
    /** rate (default) suitable for screen orientation changes */
    const SensorManager_SENSOR_DELAY_NORMAL = 3;


    /**
     * The values returned by this sensor cannot be trusted, calibration is
     * needed or the environment doesn't allow readings
     */
    const SensorManager_SENSOR_STATUS_UNRELIABLE = 0;

    /**
     * This sensor is reporting data with low accuracy, calibration with the
     * environment is needed
     */
    const SensorManager_SENSOR_STATUS_ACCURACY_LOW = 1;

    /**
     * This sensor is reporting data with an average level of accuracy,
     * calibration with the environment may improve the readings
     */
    const SensorManager_SENSOR_STATUS_ACCURACY_MEDIUM = 2;

    /** This sensor is reporting data with maximum accuracy */
    const SensorManager_SENSOR_STATUS_ACCURACY_HIGH = 3;

    /** see {@link #remapCoordinateSystem} */
    const SensorManager_AXIS_X = 1;
    /** see {@link #remapCoordinateSystem} */
    const SensorManager_AXIS_Y = 2;
    /** see {@link #remapCoordinateSystem} */
    const SensorManager_AXIS_Z = 3;
    /** see {@link #remapCoordinateSystem} */
    const SensorManager_AXIS_MINUS_X = 0x81; // AXIS_X | 0x80;
    /** see {@link #remapCoordinateSystem} */
    const SensorManager_AXIS_MINUS_Y = 0x82; // AXIS_Y | 0x80;
    /** see {@link #remapCoordinateSystem} */
    const SensorManager_AXIS_MINUS_Z = 0x83; // AXIS_Z | 0x80;

    interface ISensorEvent;
    interface ISensor;
    interface IHandler;

    /**
     * <p>
     * SensorManager lets you access the device's {@link android.hardware.Sensor
     * sensors}. Get an instance of this class by calling
     * {@link android.content.Context#getSystemService(java.lang.String)
     * Context.getSystemService()} with the argument
     * {@link android.content.Context#SENSOR_SERVICE}.
     * </p>
     * <p>
     * Always make sure to disable sensors you don't need, especially when your
     * activity is paused. Failing to do so can drain the battery in just a few
     * hours. Note that the system will <i>not</i> disable sensors automatically when
     * the screen turns off.
     * </p>
     *
     * <pre class="prettyprint">
     * public class SensorActivity extends Activity, implements SensorEventListener {
     *     private final SensorManager mSensorManager;
     *     private final Sensor mAccelerometer;
     *
     *     public SensorActivity() {
     *         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
     *         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
     *     }
     *
     *     protected void onResume() {
     *         super.onResume();
     *         mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL);
     *     }
     *
     *     protected void onPause() {
     *         super.onPause();
     *         mSensorManager.unregisterListener(this);
     *     }
     *
     *     public void onAccuracyChanged(Sensor sensor, int accuracy) {
     *     }
     *
     *     public void onSensorChanged(SensorEvent event) {
     *     }
     * }
     * </pre>
     *
     * @see SensorEventListener
     * @see SensorEvent
     * @see Sensor
     *
     */
    interface ISensorManager {
        /**
         * @return available sensors.
         * @deprecated This method is deprecated, use
         *             {@link SensorManager#getSensorList(int)} instead
         */
        // @Deprecated
        // public int getSensors();

        /**
         * Use this method to get the list of available sensors of a certain type.
         * Make multiple calls to get sensors of different types or use
         * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all the
         * sensors.
         *
         * @param type
         *        of sensors requested
         *
         * @return a list of sensors matching the asked type.
         *
         * @see #getDefaultSensor(int)
         * @see Sensor
         */
        GetSensorList(
            [in] Int32 type,
            [out] IObjectContainer** list);

        /**
         * Use this method to get the default sensor for a given type. Note that the
         * returned sensor could be a composite sensor, and its data could be
         * averaged or filtered. If you need to access the raw sensors use
         * {@link SensorManager#getSensorList(int) getSensorList}.
         *
         * @param type
         *        of sensors requested
         *
         * @return the default sensors matching the asked type.
         *
         * @see #getSensorList(int)
         * @see Sensor
         */
        GetDefaultSensor(
            [in] Int32 type,
            [out] ISensor** sensor);

        /**
         * Registers a listener for given sensors.
         *
         * @deprecated This method is deprecated, use
         *             {@link SensorManager#registerListener(SensorEventListener, Sensor, int)}
         *             instead.
         *
         * @param listener
         *        sensor listener object
         *
         * @param sensors
         *        a bit masks of the sensors to register to
         *
         * @return <code>true</code> if the sensor is supported and successfully
         *         enabled
         */
        // @Deprecated
        // public boolean registerListener(SensorListener listener, int sensors);

        /**
         * Registers a SensorListener for given sensors.
         *
         * @deprecated This method is deprecated, use
         *             {@link SensorManager#registerListener(SensorEventListener, Sensor, int)}
         *             instead.
         *
         * @param listener
         *        sensor listener object
         *
         * @param sensors
         *        a bit masks of the sensors to register to
         *
         * @param rate
         *        rate of events. This is only a hint to the system. events may be
         *        received faster or slower than the specified rate. Usually events
         *        are received faster. The value must be one of
         *        {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
         *        {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
         *
         * @return <code>true</code> if the sensor is supported and successfully
         *         enabled
         */
        // @Deprecated
        // public boolean registerListener(SensorListener listener, int sensors, int rate);

        /**
         * Unregisters a listener for the sensors with which it is registered.
         *
         * @deprecated This method is deprecated, use
         *             {@link SensorManager#unregisterListener(SensorEventListener, Sensor)}
         *             instead.
         *
         * @param listener
         *        a SensorListener object
         *
         * @param sensors
         *        a bit masks of the sensors to unregister from
         */
        // @Deprecated
        // public void unregisterListener(SensorListener listener, int sensors);

        /**
         * Unregisters a listener for all sensors.
         *
         * @deprecated This method is deprecated, use
         *             {@link SensorManager#unregisterListener(SensorEventListener)}
         *             instead.
         *
         * @param listener
         *        a SensorListener object
         */
        // @Deprecated
        // public void unregisterListener(SensorListener listener);

        /**
         * Unregisters a listener for the sensors with which it is registered.
         *
         * @param listener
         *        a SensorEventListener object
         *
         * @param sensor
         *        the sensor to unregister from
         *
         * @see #unregisterListener(SensorEventListener)
         * @see #registerListener(SensorEventListener, Sensor, int)
         *
         */
        UnregisterListener(
            [in] ISensorEventListener* listener,
            [in] ISensor* sensor);

        /**
         * Unregisters a listener for all sensors.
         *
         * @param listener
         *        a SensorListener object
         *
         * @see #unregisterListener(SensorEventListener, Sensor)
         * @see #registerListener(SensorEventListener, Sensor, int)
         *
         */
        UnregisterListener2(
            [in] ISensorEventListener* listener);

        /**
         * Registers a {@link android.hardware.SensorEventListener
         * SensorEventListener} for the given sensor.
         *
         * @param listener
         *        A {@link android.hardware.SensorEventListener SensorEventListener}
         *        object.
         *
         * @param sensor
         *        The {@link android.hardware.Sensor Sensor} to register to.
         *
         * @param rate
         *        The rate {@link android.hardware.SensorEvent sensor events} are
         *        delivered at. This is only a hint to the system. Events may be
         *        received faster or slower than the specified rate. Usually events
         *        are received faster. The value must be one of
         *        {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
         *        {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}
         *        or, the desired delay between events in microsecond.
         *
         * @return <code>true</code> if the sensor is supported and successfully
         *         enabled.
         *
         * @see #registerListener(SensorEventListener, Sensor, int, Handler)
         * @see #unregisterListener(SensorEventListener)
         * @see #unregisterListener(SensorEventListener, Sensor)
         *
         */
        RegisterListener(
            [in] ISensorEventListener* listener,
            [in] ISensor* sensor,
            [in] Int32 rate,
            [out] Boolean* result);

        /**
         * Registers a {@link android.hardware.SensorEventListener
         * SensorEventListener} for the given sensor.
         *
         * @param listener
         *        A {@link android.hardware.SensorEventListener SensorEventListener}
         *        object.
         *
         * @param sensor
         *        The {@link android.hardware.Sensor Sensor} to register to.
         *
         * @param rate
         *        The rate {@link android.hardware.SensorEvent sensor events} are
         *        delivered at. This is only a hint to the system. Events may be
         *        received faster or slower than the specified rate. Usually events
         *        are received faster. The value must be one of
         *        {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
         *        {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
         *        or, the desired delay between events in microsecond.
         *
         * @param handler
         *        The {@link android.os.Handler Handler} the
         *        {@link android.hardware.SensorEvent sensor events} will be
         *        delivered to.
         *
         * @return true if the sensor is supported and successfully enabled.
         *
         * @see #registerListener(SensorEventListener, Sensor, int)
         * @see #unregisterListener(SensorEventListener)
         * @see #unregisterListener(SensorEventListener, Sensor)
         *
         */
        RegisterListener2(
            [in] ISensorEventListener* listener,
            [in] ISensor* sensor,
            [in] Int32 rate,
            [in] IHandler* handler,
            [out] Boolean* result);

        /**
         * {@hide}
         */
        OnRotationChanged(
            [in] Int32 rotation);
    }

    [deprecated]
    interface ISensorManagerHelper {
        /**
         * <p>
         * Computes the inclination matrix <b>I</b> as well as the rotation matrix
         * <b>R</b> transforming a vector from the device coordinate system to the
         * world's coordinate system which is defined as a direct orthonormal basis,
         * where:
         * </p>
         *
         * <ul>
         * <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to
         * the ground at the device's current location and roughly points East).</li>
         * <li>Y is tangential to the ground at the device's current location and
         * points towards the magnetic North Pole.</li>
         * <li>Z points towards the sky and is perpendicular to the ground.</li>
         * </ul>
         *
         * <p>
         * <center><img src="../../../images/axis_globe.png"
         * alt="World coordinate-system diagram." border="0" /></center>
         * </p>
         *
         * <p>
         * <hr>
         * <p>
         * By definition:
         * <p>
         * [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity)
         * <p>
         * [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of
         * geomagnetic field)
         * <p>
         * <b>R</b> is the identity matrix when the device is aligned with the
         * world's coordinate system, that is, when the device's X axis points
         * toward East, the Y axis points to the North Pole and the device is facing
         * the sky.
         *
         * <p>
         * <b>I</b> is a rotation matrix transforming the geomagnetic vector into
         * the same coordinate space as gravity (the world's coordinate space).
         * <b>I</b> is a simple rotation around the X axis. The inclination angle in
         * radians can be computed with {@link #getInclination}.
         * <hr>
         *
         * <p>
         * Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending
         * on the length of the passed array:
         * <p>
         * <u>If the array length is 16:</u>
         *
         * <pre>
         *   /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \
         *   |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  |
         *   |  M[ 8]   M[ 9]   M[10]   M[11]  |
         *   \  M[12]   M[13]   M[14]   M[15]  /
         *</pre>
         *
         * This matrix is ready to be used by OpenGL ES's
         * {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[], int)
         * glLoadMatrixf(float[], int)}.
         * <p>
         * Note that because OpenGL matrices are column-major matrices you must
         * transpose the matrix before using it. However, since the matrix is a
         * rotation matrix, its transpose is also its inverse, conveniently, it is
         * often the inverse of the rotation that is needed for rendering; it can
         * therefore be used with OpenGL ES directly.
         * <p>
         * Also note that the returned matrices always have this form:
         *
         * <pre>
         *   /  M[ 0]   M[ 1]   M[ 2]   0  \
         *   |  M[ 4]   M[ 5]   M[ 6]   0  |
         *   |  M[ 8]   M[ 9]   M[10]   0  |
         *   \      0       0       0   1  /
         *</pre>
         *
         * <p>
         * <u>If the array length is 9:</u>
         *
         * <pre>
         *   /  M[ 0]   M[ 1]   M[ 2]  \
         *   |  M[ 3]   M[ 4]   M[ 5]  |
         *   \  M[ 6]   M[ 7]   M[ 8]  /
         *</pre>
         *
         * <hr>
         * <p>
         * The inverse of each matrix can be computed easily by taking its
         * transpose.
         *
         * <p>
         * The matrices returned by this function are meaningful only when the
         * device is not free-falling and it is not close to the magnetic north. If
         * the device is accelerating, or placed into a strong magnetic field, the
         * returned matrices may be inaccurate.
         *
         * @param R
         *        is an array of 9 floats holding the rotation matrix <b>R</b> when
         *        this function returns. R can be null.
         *        <p>
         *
         * @param I
         *        is an array of 9 floats holding the rotation matrix <b>I</b> when
         *        this function returns. I can be null.
         *        <p>
         *
         * @param gravity
         *        is an array of 3 floats containing the gravity vector expressed in
         *        the device's coordinate. You can simply use the
         *        {@link android.hardware.SensorEvent#values values} returned by a
         *        {@link android.hardware.SensorEvent SensorEvent} of a
         *        {@link android.hardware.Sensor Sensor} of type
         *        {@link android.hardware.Sensor#TYPE_ACCELEROMETER
         *        TYPE_ACCELEROMETER}.
         *        <p>
         *
         * @param geomagnetic
         *        is an array of 3 floats containing the geomagnetic vector
         *        expressed in the device's coordinate. You can simply use the
         *        {@link android.hardware.SensorEvent#values values} returned by a
         *        {@link android.hardware.SensorEvent SensorEvent} of a
         *        {@link android.hardware.Sensor Sensor} of type
         *        {@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD
         *        TYPE_MAGNETIC_FIELD}.
         *
         * @return <code>true</code> on success, <code>false</code> on failure (for
         *         instance, if the device is in free fall). On failure the output
         *         matrices are not modified.
         *
         * @see #getInclination(float[])
         * @see #getOrientation(float[], float[])
         * @see #remapCoordinateSystem(float[], int, int, float[])
         */
        GetRotationMatrix(
            [in] ArrayOf<Float>* R,
            [in] ArrayOf<Float>* I,
            [in] ArrayOf<Float>* gravity,
            [in] ArrayOf<Float>* geomagnetic,
            [out] Boolean* result);

        /**
         * Computes the geomagnetic inclination angle in radians from the
         * inclination matrix <b>I</b> returned by {@link #getRotationMatrix}.
         *
         * @param I
         *        inclination matrix see {@link #getRotationMatrix}.
         *
         * @return The geomagnetic inclination angle in radians.
         *
         * @see #getRotationMatrix(float[], float[], float[], float[])
         * @see #getOrientation(float[], float[])
         * @see GeomagneticField
         *
         */
        GetInclination(
            [in] ArrayOf<Float> I,
            [out] Float* inclination);

        /**
         * <p>
         * Rotates the supplied rotation matrix so it is expressed in a different
         * coordinate system. This is typically used when an application needs to
         * compute the three orientation angles of the device (see
         * {@link #getOrientation}) in a different coordinate system.
         * </p>
         *
         * <p>
         * When the rotation matrix is used for drawing (for instance with OpenGL
         * ES), it usually <b>doesn't need</b> to be transformed by this function,
         * unless the screen is physically rotated, in which case you can use
         * {@link android.view.Display#getRotation() Display.getRotation()} to
         * retrieve the current rotation of the screen. Note that because the user
         * is generally free to rotate their screen, you often should consider the
         * rotation in deciding the parameters to use here.
         * </p>
         *
         * <p>
         * <u>Examples:</u>
         * <p>
         *
         * <ul>
         * <li>Using the camera (Y axis along the camera's axis) for an augmented
         * reality application where the rotation angles are needed:</li>
         *
         * <p>
         * <ul>
         * <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code>
         * </ul>
         * </p>
         *
         * <li>Using the device as a mechanical compass when rotation is
         * {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li>
         *
         * <p>
         * <ul>
         * <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code>
         * </ul>
         * </p>
         *
         * Beware of the above example. This call is needed only to account for a
         * rotation from its natural orientation when calculating the rotation
         * angles (see {@link #getOrientation}). If the rotation matrix is also used
         * for rendering, it may not need to be transformed, for instance if your
         * {@link android.app.Activity Activity} is running in landscape mode.
         * </ul>
         *
         * <p>
         * Since the resulting coordinate system is orthonormal, only two axes need
         * to be specified.
         *
         * @param inR
         *        the rotation matrix to be transformed. Usually it is the matrix
         *        returned by {@link #getRotationMatrix}.
         *
         * @param X
         *        defines on which world axis and direction the X axis of the device
         *        is mapped.
         *
         * @param Y
         *        defines on which world axis and direction the Y axis of the device
         *        is mapped.
         *
         * @param outR
         *        the transformed rotation matrix. inR and outR can be the same
         *        array, but it is not recommended for performance reason.
         *
         * @return <code>true</code> on success. <code>false</code> if the input
         *         parameters are incorrect, for instance if X and Y define the same
         *         axis. Or if inR and outR don't have the same length.
         *
         * @see #getRotationMatrix(float[], float[], float[], float[])
         */
        RemapCoordinateSystem(
            [in] ArrayOf<Float>* inR,
            [in] Int32 X,
            [in] Int32 Y,
            [in] ArrayOf<Float>* outR,
            [out] Boolean* result);

        /**
         * Computes the device's orientation based on the rotation matrix.
         * <p>
         * When it returns, the array values is filled with the result:
         * <ul>
         * <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li>
         * <li>values[1]: <i>pitch</i>, rotation around the X axis.</li>
         * <li>values[2]: <i>roll</i>, rotation around the Y axis.</li>
         * </ul>
         * <p>The reference coordinate-system used is different from the world
         * coordinate-system defined for the rotation matrix:</p>
         * <ul>
         * <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to
         * the ground at the device's current location and roughly points West).</li>
         * <li>Y is tangential to the ground at the device's current location and
         * points towards the magnetic North Pole.</li>
         * <li>Z points towards the center of the Earth and is perpendicular to the ground.</li>
         * </ul>
         *
         * <p>
         * <center><img src="../../../images/axis_globe_inverted.png"
         * alt="Inverted world coordinate-system diagram." border="0" /></center>
         * </p>
         * <p>
         * All three angles above are in <b>radians</b> and <b>positive</b> in the
         * <b>counter-clockwise</b> direction.
         *
         * @param R
         *        rotation matrix see {@link #getRotationMatrix}.
         *
         * @param values
         *        an array of 3 floats to hold the result.
         *
         * @return The array values passed as argument.
         *
         * @see #getRotationMatrix(float[], float[], float[], float[])
         * @see GeomagneticField
         */
        GetOrientation(
            [in] ArrayOf<Float> R,
            [in] ArrayOf<Float>* values);

        /**
         * Computes the Altitude in meters from the atmospheric pressure and the
         * pressure at sea level.
         * <p>
         * Typically the atmospheric pressure is read from a
         * {@link Sensor#TYPE_PRESSURE} sensor. The pressure at sea level must be
         * known, usually it can be retrieved from airport databases in the
         * vicinity. If unknown, you can use {@link #PRESSURE_STANDARD_ATMOSPHERE}
         * as an approximation, but absolute altitudes won't be accurate.
         * </p>
         * <p>
         * To calculate altitude differences, you must calculate the difference
         * between the altitudes at both points. If you don't know the altitude
         * as sea level, you can use {@link #PRESSURE_STANDARD_ATMOSPHERE} instead,
         * which will give good results considering the range of pressure typically
         * involved.
         * </p>
         * <p>
         * <code><ul>
         *  float altitude_difference =
         *      getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point2)
         *      - getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point1);
         * </ul></code>
         * </p>
         *
         * @param p0 pressure at sea level
         * @param p atmospheric pressure
         * @return Altitude in meters
         */
        GetAltitude(
            [in] Float p0,
            [in] Float p,
            [out] Float* altitude);

        /** Helper function to compute the angle change between two rotation matrices.
         *  Given a current rotation matrix (R) and a previous rotation matrix
         *  (prevR) computes the rotation around the x,y, and z axes which
         *  transforms prevR to R.
         *  outputs a 3 element vector containing the x,y, and z angle
         *  change at indexes 0, 1, and 2 respectively.
         * <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix
         * depending on the length of the passed array:
         * <p>If the array length is 9, then the array elements represent this matrix
         * <pre>
         *   /  R[ 0]   R[ 1]   R[ 2]   \
         *   |  R[ 3]   R[ 4]   R[ 5]   |
         *   \  R[ 6]   R[ 7]   R[ 8]   /
         *</pre>
         * <p>If the array length is 16, then the array elements represent this matrix
         * <pre>
         *   /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \
         *   |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  |
         *   |  R[ 8]   R[ 9]   R[10]   R[11]  |
         *   \  R[12]   R[13]   R[14]   R[15]  /
         *</pre>
         * @param R current rotation matrix
         * @param prevR previous rotation matrix
         * @param angleChange an array of floats in which the angle change is stored
         */
        GetAngleChange(
            [in] ArrayOf<Float>* angleChange,
            [in] ArrayOf<Float> R,
            [in] ArrayOf<Float> prevR);

        /** Helper function to convert a rotation vector to a rotation matrix.
         *  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a
         *  9  or 16 element rotation matrix in the array R.  R must have length 9 or 16.
         *  If R.length == 9, the following matrix is returned:
         * <pre>
         *   /  R[ 0]   R[ 1]   R[ 2]   \
         *   |  R[ 3]   R[ 4]   R[ 5]   |
         *   \  R[ 6]   R[ 7]   R[ 8]   /
         *</pre>
         * If R.length == 16, the following matrix is returned:
         * <pre>
         *   /  R[ 0]   R[ 1]   R[ 2]   0  \
         *   |  R[ 4]   R[ 5]   R[ 6]   0  |
         *   |  R[ 8]   R[ 9]   R[10]   0  |
         *   \  0       0       0       1  /
         *</pre>
         *  @param rotationVector the rotation vector to convert
         *  @param R an array of floats in which to store the rotation matrix
         */
        GetRotationMatrixFromVector(
            [in] ArrayOf<Float>* R,
            [in] ArrayOf<Float> rotationVector);

        /** Helper function to convert a rotation vector to a normalized quaternion.
         *  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized
         *  quaternion in the array Q.  The quaternion is stored as [w, x, y, z]
         *  @param rv the rotation vector to convert
         *  @param Q an array of floats in which to store the computed quaternion
         */
        GetQuaternionFromVector(
            [in] ArrayOf<Float>* Q,
            [in] ArrayOf<Float>  rv);
    }

    interface ISensorManagerListenerDelegate {
    }

    interface ISensorManagerLmsFilter {
        Filter(
            [in] Int64 time,
            [in] Float inValue,
            [out] Float* outValue);
    }
}

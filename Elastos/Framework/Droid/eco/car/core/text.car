
module
{
    merge("text/TextUtils.car");
    merge("text/TextPaint.car");
    merge("text/Layout.car");
    merge("text/BoringLayout.car");
    merge("text/StaticLayout.car");
    merge("text/DynamicLayout.car");
    merge("text/GetChars.car");
    merge("text/Spanned.car");
    merge("text/Spannable.car");
    merge("text/GraphicsOperations.car");
    merge("text/NoCopySpan.car");
    merge("text/SpanWatcher.car");
    merge("text/Editable.car");
    merge("text/SpannableStringBuilder.car");
    merge("text/InputType.car");
    merge("text/TextWatcher.car");
    merge("text/ClipboardManager.car");
    merge("text/IClipboard.car");
    merge("text/Selection.car");
    merge("text/style/ParagraphStyle.car");
    merge("text/style/LineBackgroundSpan.car");
    merge("text/style/AlignmentSpan.car");
    merge("text/style/LeadingMarginSpan.car");
    merge("text/style/TabStopSpan.car");
    merge("text/style/CharacterStyle.car");
    merge("text/style/MetricAffectingSpan.car");
    merge("text/style/ReplacementSpan.car");
    merge("text/style/WrapTogetherSpan.car");
    merge("text/style/LineHeightSpan.car");
    merge("text/style/UpdateAppearance.car");
    merge("text/style/UpdateLayout.car");
    merge("text/style/ParcelableSpan.car");
    merge("text/style/ClickableSpan.car");
    merge("text/style/URLSpan.car");
    merge("text/style/BackgroundColorSpan.car");
    merge("text/style/ForegroundColorSpan.car");
    merge("text/style/UnderlineSpan.car");
    merge("text/method/KeyListener.car");
    merge("text/method/TransformationMethod.car");
    merge("text/method/MovementMethod.car");
    merge("text/method/TextKeyListener.car");
    merge("text/method/QwertyKeyListener.car");


    class CTextPaint {

        constructor();

        constructor(
            [in] Int32 flags);

        constructor(
            [in] IPaint* paint);

        interface ITextPaint;
    }

    class CBoringLayoutMetrics {
        interface IBoringLayoutMetrics;
    }

    class CBoringLayout {

        constructor(
            [in] ICharSequence* source,
            [in] ITextPaint* paint,
            [in] Int32 outerwidth,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] IBoringLayoutMetrics* metrics,
            [in] Boolean includepad);

        constructor(
            [in] ICharSequence* source,
            [in] ITextPaint* paint,
            [in] Int32 outerwidth,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] IBoringLayoutMetrics* metrics,
            [in] Boolean includepad,
            [in] TextUtilsTruncateAt ellipsize,
            [in] Int32 ellipsizedWidth);

        interface IBoringLayout;
        interface IEllipsizeCallback;
    }

    class CStaticLayout {

        constructor(
            [in] ICharSequence* source,
            [in] ITextPaint* paint,
            [in] Int32 width,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] Boolean includepad);

        constructor(
            [in] ICharSequence* source,
            [in] Int32 bufstart,
            [in] Int32 bufend,
            [in] ITextPaint* paint,
            [in] Int32 outerwidth,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] Boolean includepad);

        constructor(
            [in] ICharSequence* source,
            [in] Int32 bufstart,
            [in] Int32 bufend,
            [in] ITextPaint* paint,
            [in] Int32 outerwidth,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] Boolean includepad,
            [in] TextUtilsTruncateAt ellipsize,
            [in] Int32 ellipsizedWidth);

        constructor(
            [in] Boolean ellipsize);

        interface IStaticLayout;
    }

    class CDirections {
        // The values in mDirections are the offsets from the first character
        // in the line to the next flip in direction.  Runs at even indices
        // are left-to-right, the others are right-to-left.  So, for example,
        // a line that starts with a right-to-left run has 0 at mDirections[0],
        // since the 'first' (ltr) run is zero length.
        //
        // The code currently assumes that each run is adjacent to the previous
        // one, progressing in the base line direction.  This isn't sufficient
        // to handle nested runs, for example numeric text in an rtl context
        // in an ltr paragraph.
        /* package */ constructor(
            [in] ArrayOf<Int16> dirs);

        interface IDirections;
    }

    class CSpannableString {
        constructor(
            [in] ICharSequence* source);

        constructor(
            [in] ICharSequence* source,
            [in] Int32 start,
            [in] Int32 end);

        interface ISpannable;
    }

    singleton class CSpannableFactory {
        interface ISpannableFactory;
    }

    class CDynamicLayout {
        constructor(
            [in] ICharSequence* base,
            [in] ITextPaint* paint,
            [in] Int32 width,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] Boolean includepad);

        constructor(
            [in] ICharSequence* base,
            [in] ICharSequence* display,
            [in] ITextPaint* paint,
            [in] Int32 width,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] Boolean includepad);

        constructor(
            [in] ICharSequence* base,
            [in] ICharSequence* display,
            [in] ITextPaint* paint,
            [in] Int32 width,
            [in] LayoutAlignment align,
            [in] Float spacingmult,
            [in] Float spacingadd,
            [in] Boolean includepad,
            [in] TextUtilsTruncateAt ellipsize,
            [in] Int32 ellipsizedWidth);

        interface IDynamicLayout;
    }

    class CSpannableStringBuilder {
        constructor();

        constructor(
            [in] ICharSequence* source);

        constructor(
            [in] ICharSequence* source,
            [in] Int32 start,
            [in] Int32 end);

        interface ISpannableStringBuilder;
        interface IGraphicsOperations;
        interface IGetChars;
    }

    singleton class CEditableFactory {
        interface IEditableFactory;
    }

    class CNoCopySpan {
        interface INoCopySpan;
    }

    class CURLSpan {
        constructor(
            [in] String url);

        interface IURLSpan;
        interface IParcelableSpan;
        interface IUpdateAppearance;
    }

    class CTextKeyListener {
        /**
         * Creates a new TextKeyListener with the specified capitalization
         * and correction properties.
         *
         * @param cap when, if ever, to automatically capitalize.
         * @param autotext whether to automatically do spelling corrections.
         */
        constructor(
            [in] Capitalize cap,
            [in] Boolean autotext);

        interface ITextKeyListener;
        interface ISpanWatcher;
    }

    singleton class CTextKeyListenerHelper {
        constructor();

        interface ITextKeyListenerHelper;
    }

    class CQwertyKeyListener {
        constructor(
            [in] Capitalize cap,
            [in] Boolean autotext);

        interface IQwertyKeyListener;
    }

    class CArrowKeyMovementMethod {
        interface IMovementMethod;
    }

    class CClipboardManager {
        /** {@hide} */
        constructor(
            [in] IContext* context); /* Handler handler */
        interface IClipboardManager;
    }

    class CBackgroundColorSpan {

        constructor(
            [in] Int32 color);

        constructor(
            [in] IParcel* src);

        interface IBackgroundColorSpan;
        interface IParcelable;
    }

    class CForegroundColorSpan {

        constructor(
            [in] Int32 color);

        constructor(
            [in] IParcel* src);

        interface IForegroundColorSpan;
        interface IParcelable;
    }

    class CUnderlineSpan {

        constructor();

        constructor(
            [in] IParcel* src);

        interface IUnderlineSpan;
        interface IParcelable;
    }

    singleton class CSelectionHelper {
        interface ISelectionHelper;
    }
}

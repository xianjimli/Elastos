
module
{
    interface IChronometer;

    /**
     * A callback that notifies when the chronometer has incremented on its own.
     */
    interface IOnChronometerTickListener
    {
        /**
         * Notification that the chronometer has changed.
         */
        OnChronometerTick(
            [in] IChronometer* chronometer);

    }

    interface IChronometer extends ITextView
    {
        /**
         * Set the time that the count-up timer is in reference to.
         *
         * @param base Use the {@link SystemClock#elapsedRealtime} time base.
         */
        SetBase(
            [in] Int64 base);

        /**
         * Return the base time as set through {@link #setBase}.
         */
        GetBase(
            [out] Int64* base);

        /**
         * Sets the format string used for display.  The Chronometer will display
         * this string, with the first "%s" replaced by the current timer value in
         * "MM:SS" or "H:MM:SS" form.
         *
         * If the format string is null, or if you never call setFormat(), the
         * Chronometer will simply display the timer value in "MM:SS" or "H:MM:SS"
         * form.
         *
         * @param format the format string.
         */
        SetFormat(
            [in] String format);

        /**
         * Returns the current format string as set through {@link #setFormat}.
         */
        GetFormat(
            [out] String* format);

        /**
         * Sets the listener to be called when the chronometer changes.
         * 
         * @param listener The listener.
         */
        SetOnChronometerTickListener(
            [in] IOnChronometerTickListener* listener);

        /**
         * @return The listener (may be null) that is listening for chronometer change
         *         events.
         */
        GetOnChronometerTickListener(
            [out] IOnChronometerTickListener** listener);

        /**
         * Start counting up.  This does not affect the base as set from {@link #setBase}, just
         * the view display.
         * 
         * Chronometer works by regularly scheduling messages to the handler, even when the 
         * Widget is not visible.  To make sure resource leaks do not occur, the user should 
         * make sure that each start() call has a reciprocal call to {@link #stop}. 
         */
        Start();

        /**
         * Stop counting up.  This does not affect the base as set from {@link #setBase}, just
         * the view display.
         * 
         * This stops the messages to the handler, effectively releasing resources that would
         * be held as the chronometer is running, via {@link #start}. 
         */
        Stop();

        /**
         * The same as calling {@link #start} or {@link #stop}.
         * @hide pending API council approval
         */
        SetStarted(
            [in] Boolean started);
    }
}
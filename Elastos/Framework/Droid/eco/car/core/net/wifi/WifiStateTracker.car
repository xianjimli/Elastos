
module
{
    enum SupplicantState;
    interface IWorkSource;
    interface IWifiInfo;

    interface IWifiStateTracker extends INetworkStateTracker {
        GetSupplicantState(
            [out] SupplicantState* state);

        StartEventLoop();

        /**
         * {@inheritDoc}
         * There are currently no defined Wi-Fi subtypes.
         */
        GetNetworkSubtype(
            [out] Int32* subtypes);

        /**
         * Report whether the Wi-Fi connection is fully configured for data.
         * @return {@code true} if the {@link SupplicantState} is
         * {@link android.net.wifi.SupplicantState#COMPLETED COMPLETED}.
         */
        IsConnectionCompleted(
            [out] Boolean* completed);

        /**
         * Report whether the Wi-Fi connection has successfully acquired an IP address.
         * @return {@code true} if the Wi-Fi connection has been assigned an IP address.
         */
        HasIpAddress(
            [out] Boolean* result);

        /**
         * TODO: mRunState is not synchronized in some places
         * address this as part of re-architect.
         *
         * TODO: We are exposing an additional public synchronized call
         * for a wakelock optimization in WifiService. Remove it
         * when we handle the wakelock in ConnectivityService.
         */
        IsDriverStopped(
            [out] Boolean* stopped);

        UpdateBatteryWorkSourceLocked(
            [in] IWorkSource* newSource);

        /**
         * Set the run state to either "normal" or "scan-only".
         * @param scanOnlyMode true if the new mode should be scan-only.
         */
        SetScanOnlyMode(
            [in] Boolean scanOnlyMode);

        /**
         * Set suspend mode optimizations. These include:
         * - packet filtering
         * - turn off roaming
         * - DTIM settings
         *
         * Uses reference counting to keep the suspend optimizations disabled
         * as long as one entity wants optimizations disabled.
         *
         * For example, WifiLock can keep suspend optimizations disabled
         * or the user setting (wifi never sleeps) can keep suspend optimizations
         * disabled. As long as one entity wants it disabled, it should stay
         * that way
         *
         * @param enabled true if optimizations need enabled, false otherwise
         */
        SetSuspendModeOptimizations(
            [in] Boolean enabled);

        /**
         * Set high performance mode of operation. This would mean
         * use active power mode and disable suspend optimizations
         * @param enabled true if enabled, false otherwise
         */
        SetHighPerfMode(
            [in] Boolean enabled);

        EnableRssiPolling(
             [in] Boolean enable);

        /**
         * Resets the Wi-Fi Connections by clearing any state, resetting any sockets
         * using the interface, stopping DHCP, and disabling the interface.
         */
        ResetConnections(
            [in] Boolean disableInterface);

        GetDhcpInfo(
            [out] IDhcpInfo** dhcpInfo);

        public synchronized List<ScanResult> getScanResultsList()

        public synchronized void setScanResultsList(List<ScanResult> scanList)

        /**
         * Get status information for the current connection, if any.
         * @return a {@link WifiInfo} object containing information about the current connection
         */
        RequestConnectionInfo(
            [out] IWifiInfo** wifiInfo);

        /**
         * We want to stop the driver, but if we're connected to a network,
         * we first want to disconnect, so that the supplicant is always in
         * a known state (DISCONNECTED) when the driver is stopped.
         * @return {@code true} if the operation succeeds, which means that the
         * disconnect or stop command was initiated.
         */
        DisconnectAndStop(
            [out] Boolean* succeeded);

        Restart(
            [out] Boolean* succeeded);

        GetWifiState(
            [out] Int32* state);

        SetWifiState(
            [in] Int32 wifiState);

        IsAnyNetworkDisabled(
            [out] Boolean* disabled);

        /**
         * Load the driver and firmware
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        LoadDriver(
            [out] Boolean* succeeded);

        /**
         * Unload the driver and firmware
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        UnloadDriver(
            [out] Boolean* succeeded);

        /**
         * Check the supplicant config and
         * start the supplicant daemon
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        StartSupplicant(
            [out] Boolean* succeeded);

        /**
         * Stop the supplicant daemon
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        StopSupplicant(
            [out] Boolean* succeeded);

        /**
         * Establishes two channels - control channel for commands
         * and monitor channel for notifying WifiMonitor
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        ConnectToSupplicant(
            [out] Boolean* succeeded);

        /**
         * Close the control/monitor channels to supplicant
         */
        CloseSupplicantConnection();

        /**
         * Check if the supplicant is alive
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        Ping(
            [out] Boolean* succeeded);

        /**
         * initiate an active or passive scan
         *
         * @param forceActive true if it is a active scan
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        Scan(
            [in] Boolean forceActive,
            [out] Boolean* succeeded);

        /**
         * Specifies whether the supplicant or driver
         * take care of initiating scan and doing AP selection
         *
         * @param mode
         *    SUPPL_SCAN_HANDLING_NORMAL
         *    SUPPL_SCAN_HANDLING_LIST_ONLY
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        SetScanResultHandling(
            [in] Int32 mode,
            [out] Boolean* succeeded);

        /**
         * Fetch the scan results from the supplicant
         *
         * @return example result string
         * 00:bb:cc:dd:cc:ee       2427    166     [WPA-EAP-TKIP][WPA2-EAP-CCMP]   Net1
         * 00:bb:cc:dd:cc:ff       2412    165     [WPA-EAP-TKIP][WPA2-EAP-CCMP]   Net2
         */
        ScanResults(
            [out] String* result);

        /**
         * Set the scan mode - active or passive
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        SetScanMode(
            [in] Boolean isScanModeActive,
            [out] Boolean* succeeded);

        /**
         * Disconnect from Access Point
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        Disconnect(
            [out] Boolean* succeeded);

        /**
         * Initiate a reconnection to AP
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        ReconnectCommand(
            [out] Boolean* succeeded);

        /**
         * Add a network
         *
         * @return network id of the new network
         */
        AddNetwork(
            [out] Int32* netId);

        /**
         * Delete a network
         *
         * @param networkId id of the network to be removed
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        RemoveNetwork(
            [in] Int32 networkId,
            [out] Boolean* succeeded);

        /**
         * Enable a network
         *
         * @param netId network id of the network
         * @param disableOthers true, if all other networks have to be disabled
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        EnableNetwork(
            [in] Int32 netId,
            [in] Boolean disableOthers,
            [out] Boolean* succeeded);

        /**
         * Enable all networks
         *
         * @param networks list of configured networks
         */
//        public synchronized void enableAllNetworks(List<WifiConfiguration> networks)

        /**
         * Disable a network
         *
         * @param netId network id of the network
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        DisableNetwork(
            [in] Int32 netId,
            [out] Boolean* succeeded);

        /**
         * Initiate a re-association in supplicant
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        Reassociate(
            [out] Boolean* succeeded);

        /**
         * Blacklist a BSSID. This will avoid the AP if there are
         * alternate APs to connect
         *
         * @param bssid BSSID of the network
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        AddToBlacklist(
            [in] String bssid,
            [out] Boolean* succeeded);

        /**
         * Clear the blacklist list
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        ClearBlacklist(
            [out] Boolean* succeeded);

        /**
         * List all configured networks
         *
         * @return list of networks or null on failure
         */
        ListNetworks(
            [out] String* networks);

        /**
         * Get network setting by name
         *
         * @param netId network id of the network
         * @param name network variable key
         * @return value corresponding to key
         */
        GetNetworkVariable(
            [in] Int32 netId,
            [in] String name,
            [out] String* value);

        /**
         * Set network setting by name
         *
         * @param netId network id of the network
         * @param name network variable key
         * @param value network variable value
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        SetNetworkVariable(
            [in] Int32 netId,
            [in] String name,
            [in] String value,
            [out] Boolean* succeeded);

        /**
         * Get detailed status of the connection
         *
         * @return Example status result
         *  bssid=aa:bb:cc:dd:ee:ff
         *  ssid=TestNet
         *  id=3
         *  pairwise_cipher=NONE
         *  group_cipher=NONE
         *  key_mgmt=NONE
         *  wpa_state=COMPLETED
         *  ip_address=X.X.X.X
         */
        GetStatus(
            [out] String* status);

        /**
         * Get RSSI to currently connected network
         *
         * @return RSSI value, -1 on failure
         */
        GetRssi(
            [out] Int32* value);

        /**
         * Get approx RSSI to currently connected network
         *
         * @return RSSI value, -1 on failure
         */
        GetRssiApprox(
            [out] Int32* value);

        /**
         * Get link speed to currently connected network
         *
         * @return link speed, -1 on failure
         */
        GetLinkSpeed(
            [out] Int32* speed);

        /**
         * Start driver
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        StartDriver(
            [out] Boolean* succeeded);

        /**
         * Stop driver
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        StopDriver(
            [out] Boolean* succeeded);

        /**
         * Start packet filtering
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        StartPacketFiltering(
            [out] Boolean* succeeded);

        /**
         * Stop packet filtering
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        StopPacketFiltering(
            [out] Boolean* succeeded);

        /**
         * Get power mode
         * @return power mode
         */
        GetPowerMode(
            [out] Int32* mode);

        /**
         * Set the number of allowed radio frequency channels from the system
         * setting value, if any.
         * @return {@code true} if the operation succeeds, {@code false} otherwise, e.g.,
         * the number of channels is invalid.
         */
        SetNumAllowedChannels(
            [out] Boolean* succeeded);

        /**
         * Set the number of radio frequency channels that are allowed to be used
         * in the current regulatory domain.
         * @param numChannels the number of allowed channels. Must be greater than 0
         * and less than or equal to 16.
         * @return {@code true} if the operation succeeds, {@code false} otherwise, e.g.,
         * {@code numChannels} is outside the valid range.
         */
        SetNumAllowedChannelsEx(
            [in] Int32 numChannels,
            [out] Boolean* succeeded);

        /**
         * Get number of allowed channels
         *
         * @return channel count, -1 on failure
         */
        GetNumAllowedChannels(
            [out] Int32* count);

        /**
         * Set bluetooth coex mode:
         *
         * @param mode
         *  BLUETOOTH_COEXISTENCE_MODE_ENABLED
         *  BLUETOOTH_COEXISTENCE_MODE_DISABLED
         *  BLUETOOTH_COEXISTENCE_MODE_SENSE
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        SetBluetoothCoexistenceMode(
            [in] Int32 mode,
            [out] Boolean* succeeded);

        /**
         * Enable or disable Bluetooth coexistence scan mode. When this mode is on,
         * some of the low-level scan parameters used by the driver are changed to
         * reduce interference with A2DP streaming.
         *
         * @param isBluetoothPlaying whether to enable or disable this mode
         */
        SetBluetoothScanMode(
            [in] Boolean isBluetoothPlaying);

        /**
         * Save configuration on supplicant
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        SaveConfig(
            [out] Boolean* succeeded);

        /**
         * Reload the configuration from file
         *
         * @return {@code true} if the operation succeeds, {@code false} otherwise
         */
        ReloadConfig(
            [out] Boolean* succeeded);

        /**
         * {@inheritDoc}
         * There are currently no Wi-Fi-specific features supported.
         * @param feature the name of the feature
         * @return {@code -1} indicating failure, always
         */
        StartUsingNetworkFeature(
            [in] String feature,
            [in] Int32 callingPid,
            [in] Int32 callingUid,
            [out] Int32* result);

        /**
         * {@inheritDoc}
         * There are currently no Wi-Fi-specific features supported.
         * @param feature the name of the feature
         * @return {@code -1} indicating failure, always
         */
        StopUsingNetworkFeature(
            [in] String feature,
            [in] Int32 callingPid,
            [in] Int32 callingUid,
            [out] Int32* result);

        /**
         * Display or don't display a notification that there are open Wi-Fi networks.
         * @param visible {@code true} if notification should be visible, {@code false} otherwise
         * @param numNetworks the number networks seen
         * @param force {@code true} to force notification to be shown/not-shown,
         * even if it is already shown/not-shown.
         * @param delay time in milliseconds after which the notification should be made
         * visible or invisible.
         */
        SetNotificationVisible(
            [in] Boolean visible,
            [in] Int32 numNetworks,
            [in] Boolean force,
            [in] Int32 delay);
    }
}

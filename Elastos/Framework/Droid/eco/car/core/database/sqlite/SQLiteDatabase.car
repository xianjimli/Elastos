module
{
    interface ISQLiteTransactionListener;

    interface IFile;
    interface ISQLiteCursorDriver;
    interface ISQLiteQuery;
    interface ICursor;
    interface IContentValues;
    interface ILocale;
    interface ISQLiteStatement;


    /**
     * Algorithms used in ON CONFLICT clause
     * http://www.sqlite.org/lang_conflict.html
     */
    /**
     *  When a constraint violation occurs, an immediate ROLLBACK occurs,
     * thus ending the current transaction, and the command aborts with a
     * return code of SQLITE_CONSTRAINT. If no transaction is active
     * (other than the implied transaction that is created on every command)
     *  then this algorithm works the same as ABORT.
     */
    const SQLiteDatabase_CONFLICT_ROLLBACK = 1;

    /**
     * When a constraint violation occurs,no ROLLBACK is executed
     * so changes from prior commands within the same transaction
     * are preserved. This is the default behavior.
     */
    const SQLiteDatabase_CONFLICT_ABORT = 2;

    /**
     * When a constraint violation occurs, the command aborts with a return
     * code SQLITE_CONSTRAINT. But any changes to the database that
     * the command made prior to encountering the constraint violation
     * are preserved and are not backed out.
     */
    const SQLiteDatabase_CONFLICT_FAIL = 3;

    /**
     * When a constraint violation occurs, the one row that contains
     * the constraint violation is not inserted or changed.
     * But the command continues executing normally. Other rows before and
     * after the row that contained the constraint violation continue to be
     * inserted or updated normally. No error is returned.
     */
    const SQLiteDatabase_CONFLICT_IGNORE = 4;

    /**
     * When a UNIQUE constraint violation occurs, the pre-existing rows that
     * are causing the constraint violation are removed prior to inserting
     * or updating the current row. Thus the insert or update always occurs.
     * The command continues executing normally. No error is returned.
     * If a NOT NULL constraint violation occurs, the NULL value is replaced
     * by the default value for that column. If the column has no default
     * value, then the ABORT algorithm is used. If a CHECK constraint
     * violation occurs then the IGNORE algorithm is used. When this conflict
     * resolution strategy deletes rows in order to satisfy a constraint,
     * it does not invoke delete triggers on those rows.
     *  This behavior might change in a future release.
     */
    const SQLiteDatabase_CONFLICT_REPLACE = 5;

    /**
     * use the following when no conflict action is specified.
     */
    const SQLiteDatabase_CONFLICT_NONE = 0;

    /**
     * Maximum Length Of A LIKE Or GLOB Pattern
     * The pattern matching algorithm used in the default LIKE and GLOB implementation
     * of SQLite can exhibit O(N^2) performance (where N is the number of characters in
     * the pattern) for certain pathological cases. To avoid denial-of-service attacks
     * the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes.
     * The default value of this limit is 50000. A modern workstation can evaluate
     * even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly.
     * The denial of service problem only comes into play when the pattern length gets
     * into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns
     * are at most a few dozen bytes in length, paranoid application developers may
     * want to reduce this parameter to something in the range of a few hundred
     * if they know that external users are able to generate arbitrary patterns.
     */
    const SQLiteDatabase_SQLITE_MAX_LIKE_PATTERN_LENGTH = 50000;

    /**
     * Flag for {@link #openDatabase} to open the database for reading and writing.
     * If the disk is full, this may fail even before you actually write anything.
     *
     * {@more} Note that the value of this flag is 0, so it is the default.
     */
    const SQLiteDatabase_OPEN_READWRITE = 0x00000000;          // update native code if changing

    /**
     * Flag for {@link #openDatabase} to open the database for reading only.
     * This is the only reliable way to open a database if the disk may be full.
     */
    const SQLiteDatabase_OPEN_READONLY = 0x00000001;           // update native code if changing

    /**
     * Flag for {@link #openDatabase} to open the database without support for localized collators.
     *
     * {@more} This causes the collator <code>LOCALIZED</code> not to be created.
     * You must be consistent when using this flag to use the setting the database was
     * created with.  If this is set, {@link #setLocale} will do nothing.
     */
    const SQLiteDatabase_NO_LOCALIZED_COLLATORS = 0x00000010;  // update native code if changing

    /**
     * Flag for {@link #openDatabase} to create the database file if it does not already exist.
     */
    const SQLiteDatabase_CREATE_IF_NECESSARY = 0x10000000;     // update native code if changing

    /**
     * @hide
     */
    const SQLiteDatabase_MAX_SQL_CACHE_SIZE = 250;


    interface ISQLiteDatabase;

    /**
     * Used to allow returning sub-classes of {@link Cursor} when calling query.
     */
    interface ICursorFactory {
        NewCursor(
            [in] ISQLiteDatabase* db,
            [in] ISQLiteCursorDriver* masterQuery,
            [in] String editTable,
            [in] ISQLiteQuery* query,
            [out] ICursor** newCursor);
    }

    [deprecated]
    interface ISQLiteDatabase extends ISQLiteClosable {
        /**
         * Control whether or not the SQLiteDatabase is made thread-safe by using locks
         * around critical sections. This is pretty expensive, so if you know that your
         * DB will only be used by a single thread then you should set this to false.
         * The default is true.
         * @param lockingEnabled set to true to enable locks, false otherwise
         */
        SetLockingEnabled(
            [in] Boolean lockingEnabled);

        /**
         * Begins a transaction. Transactions can be nested. When the outer transaction is ended all of
         * the work done in that transaction and all of the nested transactions will be committed or
         * rolled back. The changes will be rolled back if any transaction is ended without being
         * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
         *
         * <p>Here is the standard idiom for transactions:
         *
         * <pre>
         *   db.beginTransaction();
         *   try {
         *     ...
         *     db.setTransactionSuccessful();
         *   } finally {
         *     db.endTransaction();
         *   }
         * </pre>
         */
        BeginTransaction();

        /**
         * Begins a transaction. Transactions can be nested. When the outer transaction is ended all of
         * the work done in that transaction and all of the nested transactions will be committed or
         * rolled back. The changes will be rolled back if any transaction is ended without being
         * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
         *
         * <p>Here is the standard idiom for transactions:
         *
         * <pre>
         *   db.beginTransactionWithListener(listener);
         *   try {
         *     ...
         *     db.setTransactionSuccessful();
         *   } finally {
         *     db.endTransaction();
         *   }
         * </pre>
         * @param transactionListener listener that should be notified when the transaction begins,
         * commits, or is rolled back, either explicitly or by a call to
         * {@link #yieldIfContendedSafely}.
         */
        BeginTransactionWithListener(
            [in] ISQLiteTransactionListener* transactionListener);

        /**
         * End a transaction. See beginTransaction for notes about how to use this and when transactions
         * are committed and rolled back.
         */
        EndTransaction();

        /**
         * Marks the current transaction as successful. Do not do any more database work between
         * calling this and calling endTransaction. Do as little non-database work as possible in that
         * situation too. If any errors are encountered between this and endTransaction the transaction
         * will still be committed.
         *
         * @throws IllegalStateException if the current thread is not in a transaction or the
         * transaction is already marked as successful.
         */
        SetTransactionSuccessful();

        /**
         * return true if there is a transaction pending
         */
        InTransaction(
            [out] Boolean* result);

        /**
         * Checks if the database lock is held by this thread.
         *
         * @return true, if this thread is holding the database lock.
         */
        IsDbLockedByCurrentThread(
            [out] Boolean* isLocked);

        /**
         * Checks if the database is locked by another thread. This is
         * just an estimate, since this status can change at any time,
         * including after the call is made but before the result has
         * been acted upon.
         *
         * @return true, if the database is locked by another thread
         */
        IsDbLockedByOtherThreads(
            [out] Boolean* isLocked);

        //@Deprecated
        YieldIfContended(
            [out] Boolean* isYielded);

        YieldIfContendedSafely(
            [out] Boolean* isYielded);

        YieldIfContendedSafelyEx(
            [in] Int64 sleepAfterYieldDelay,
            [out] Boolean* isYielded);

//        GetSyncedTables(
//            [out] Map<String,String>* tables);

        /**
         * Close the database.
         */
        Close();

        /**
         * Gets the database version.
         *
         * @return the database version
         */
        GetVersion(
            [out] Int32* versions);

        /**
         * Sets the database version.
         *
         * @param version the new database version
         */
        SetVersion(
            [in] Int32 versions);

        /**
         * Returns the maximum size the database may grow to.
         *
         * @return the new maximum database size
         */
        GetMaximumSize(
            [out] Int64* numBytes);

        /**
         * Sets the maximum size the database will grow to. The maximum size cannot
         * be set below the current size.
         *
         * @param numBytes the maximum database size, in bytes
         * @return the new maximum database size
         */
        SetMaximumSize(
            [in] Int64 numBytes,
            [out] Int64* maxSize);

        /**
         * Returns the current database page size, in bytes.
         *
         * @return the database page size, in bytes
         */
        GetPageSize(
            [out] Int64* numBytes);

        /**
         * Sets the database page size. The page size must be a power of two. This
         * method does not work if any data has been written to the database file,
         * and must be called right after the database has been created.
         *
         * @param numBytes the database page size, in bytes
         */
        SetPageSize(
            [in] Int64 numBytes);

        /**
         * Mark this table as syncable. When an update occurs in this table the
         * _sync_dirty field will be set to ensure proper syncing operation.
         *
         * @param table the table to mark as syncable
         * @param deletedTable The deleted table that corresponds to the
         *          syncable table
         */
        MarkTableSyncable(
            [in] String table,
            [in] String deletedTable);

        /**
         * Mark this table as syncable, with the _sync_dirty residing in another
         * table. When an update occurs in this table the _sync_dirty field of the
         * row in updateTable with the _id in foreignKey will be set to
         * ensure proper syncing operation.
         *
         * @param table an update on this table will trigger a sync time removal
         * @param foreignKey this is the column in table whose value is an _id in
         *          updateTable
         * @param updateTable this is the table that will have its _sync_dirty
         */
        MarkTableSyncableEx(
            [in] String table,
            [in] String foreignKey,
            [in] String updateTable);

        /**
         * Compiles an SQL statement into a reusable pre-compiled statement object.
         * The parameters are identical to {@link #execSQL(String)}. You may put ?s in the
         * statement and fill in those values with {@link SQLiteProgram#bindString}
         * and {@link SQLiteProgram#bindLong} each time you want to run the
         * statement. Statements may not return result sets larger than 1x1.
         *
         * @param sql The raw SQL statement, may contain ? for unknown values to be
         *            bound later.
         * @return A pre-compiled {@link SQLiteStatement} object. Note that
         * {@link SQLiteStatement}s are not synchronized, see the documentation for more details.
         */
        CompileStatement(
            [in] String sql,
            [out] ISQLiteStatement** statement);

        /**
         * Query the given URL, returning a {@link Cursor} over the result set.
         *
         * @param distinct true if you want each row to be unique, false otherwise.
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        Query(
            [in] Boolean distinct,
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [out] ICursor** cursor);

        /**
         * Query the given URL, returning a {@link Cursor} over the result set.
         *
         * @param cursorFactory the cursor factory to use, or null for the default factory
         * @param distinct true if you want each row to be unique, false otherwise.
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        QueryWithFactory(
            [in] ICursorFactory* cursorFactory,
            [in] Boolean distinct,
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [out] ICursor** cursor);

        /**
         * Query the given table, returning a {@link Cursor} over the result set.
         *
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        QueryEx(
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [out] ICursor** cursor);

        /**
         * Query the given table, returning a {@link Cursor} over the result set.
         *
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        QueryEx2(
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [out] ICursor** cursor);

        /**
         * Runs the provided SQL and returns a {@link Cursor} over the result set.
         *
         * @param sql the SQL query. The SQL string must not be ; terminated
         * @param selectionArgs You may include ?s in where clause in the query,
         *     which will be replaced by the values from selectionArgs. The
         *     values will be bound as Strings.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         */
        RawQuery(
            [in] String sql,
            [in] ArrayOf<String>* selectionArgs,
            [out] ICursor** cursor);

        /**
         * Runs the provided SQL and returns a cursor over the result set.
         *
         * @param cursorFactory the cursor factory to use, or null for the default factory
         * @param sql the SQL query. The SQL string must not be ; terminated
         * @param selectionArgs You may include ?s in where clause in the query,
         *     which will be replaced by the values from selectionArgs. The
         *     values will be bound as Strings.
         * @param editTable the name of the first table, which is editable
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         */
        RawQueryWithFactory(
            [in] ICursorFactory* cursorFactory,
            [in] String sql,
            [in] ArrayOf<String>* selectionArgs,
            [in] String editTable,
            [out] ICursor** cursor);

        /**
         * Runs the provided SQL and returns a cursor over the result set.
         * The cursor will read an initial set of rows and the return to the caller.
         * It will continue to read in batches and send data changed notifications
         * when the later batches are ready.
         * @param sql the SQL query. The SQL string must not be ; terminated
         * @param selectionArgs You may include ?s in where clause in the query,
         *     which will be replaced by the values from selectionArgs. The
         *     values will be bound as Strings.
         * @param initialRead set the initial count of items to read from the cursor
         * @param maxRead set the count of items to read on each iteration after the first
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         *
         * This work is incomplete and not fully tested or reviewed, so currently
         * hidden.
         * @hide
         */
        RawQueryEx(
            [in] String sql,
            [in] ArrayOf<String>* selectionArgs,
            [in] Int32 initialRead,
            [in] Int32 maxRead,
            [out] ICursor** cursor);

        /**
         * Convenience method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>values</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>values</code> is empty.
         * @param values this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        Insert(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* values,
            [out] Int64* value);

        /**
         * Convenience method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>values</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>values</code> is empty.
         * @param values this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @throws SQLException
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        InsertOrThrow(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* values,
            [out] Int64* value);

        /**
         * Convenience method for replacing a row in the database.
         *
         * @param table the table in which to replace the row
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>initialValues</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>initialValues</code> is empty.
         * @param initialValues this map contains the initial column values for
         *   the row.
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        Replace(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* initialValues,
            [out] Int64* value);

        /**
         * Convenience method for replacing a row in the database.
         *
         * @param table the table in which to replace the row
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>initialValues</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>initialValues</code> is empty.
         * @param initialValues this map contains the initial column values for
         *   the row. The key
         * @throws SQLException
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        ReplaceOrThrow(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* initialValues,
            [out] Int64* value);

        /**
         * General method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>initialValues</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>initialValues</code> is empty.
         * @param initialValues this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @param conflictAlgorithm for insert conflict resolver
         * @return the row ID of the newly inserted row
         * OR the primary key of the existing row if the input param 'conflictAlgorithm' =
         * {@link #CONFLICT_IGNORE}
         * OR -1 if any error
         */
        InsertWithOnConflict(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* initialValues,
            [in] Int32 conflictAlgorithm,
            [out] Int64* value);

        /**
         * Convenience method for deleting rows in the database.
         *
         * @param table the table to delete from
         * @param whereClause the optional WHERE clause to apply when deleting.
         *            Passing null will delete all rows.
         * @return the number of rows affected if a whereClause is passed in, 0
         *         otherwise. To remove all rows and get a count pass "1" as the
         *         whereClause.
         */
        Delete(
            [in] String table,
            [in] String whereClause,
            [in] ArrayOf<String>* whereArgs,
            [out] Int32* value);

        /**
         * Convenience method for updating rows in the database.
         *
         * @param table the table to update in
         * @param values a map from column names to new column values. null is a
         *            valid value that will be translated to NULL.
         * @param whereClause the optional WHERE clause to apply when updating.
         *            Passing null will update all rows.
         * @return the number of rows affected
         */
        Update(
            [in] String table,
            [in] IContentValues* values,
            [in] String whereClause,
            [in] ArrayOf<String>* whereArgs,
            [out] Int32* value);

        /**
         * Convenience method for updating rows in the database.
         *
         * @param table the table to update in
         * @param values a map from column names to new column values. null is a
         *            valid value that will be translated to NULL.
         * @param whereClause the optional WHERE clause to apply when updating.
         *            Passing null will update all rows.
         * @param conflictAlgorithm for update conflict resolver
         * @return the number of rows affected
         */
        UpdateWithOnConflict(
            [in] String table,
            [in] IContentValues* values,
            [in] String whereClause,
            [in] ArrayOf<String>* whereArgs,
            [in] Int32 conflictAlgorithm,
            [out] Int32* value);

        /**
         * Execute a single SQL statement that is not a query. For example, CREATE
         * TABLE, DELETE, INSERT, etc. Multiple statements separated by semicolons are not
         * supported.  Takes a write lock.
         *
         * @throws SQLException if the SQL string is invalid
         */
        ExecSQL(
            [in] CString sql);

        /**
         * Execute a single SQL statement that is not a query. For example, CREATE
         * TABLE, DELETE, INSERT, etc. Multiple statements separated by semicolons are not
         * supported.  Takes a write lock.
         *
         * @param sql
         * @param bindArgs only byte[], String, Long and Double are supported in bindArgs.
         * @throws SQLException if the SQL string is invalid
         */
        ExecSQLEx(
            [in] CString sql,
            [in] ArrayOf<IInterface*>* bindArgs);

        /**
         * return whether the DB is opened as read only.
         * @return true if DB is opened as read only
         */
        IsReadOnly(
            [out] Boolean* isReadOnlyed);

        /**
         * @return true if the DB is currently open (has not been closed)
         */
        IsOpen(
            [out] Boolean* isOpened);

        NeedUpgrade(
            [in] Int32 newVersion,
            [out] Boolean* result);

        /**
         * Getter for the path to the database file.
         *
         * @return the path to our database file.
         */
        GetPath(
            [out] String* path);

        /**
         * Sets the locale for this database.  Does nothing if this database has
         * the NO_LOCALIZED_COLLATORS flag set or was opened read only.
         * @throws SQLException if the locale could not be set.  The most common reason
         * for this is that there is no collator available for the locale you requested.
         * In this case the database remains unchanged.
         */
        SetLocale(
            [in] ILocale* locale);

        /**
         * returns true if the given sql is cached in compiled-sql cache.
         * @hide
         */
        IsInCompiledSqlCache(
            [in] String sql,
            [out] Boolean* isInCompiledSqlCached);

        /**
         * purges the given sql from the compiled-sql cache.
         * @hide
         */
        PurgeFromCompiledSqlCache(
            [in] String sql);

        /**
         * remove everything from the compiled sql cache
         * @hide
         */
        ResetCompiledSqlCache();

        /**
         * return the current maxCacheSqlCacheSize
         * @hide
         */
        GetMaxSqlCacheSize(
            [out] Int32* maxSqlCacheSize);

        /**
         * set the max size of the compiled sql cache for this database after purging the cache.
         * (size of the cache = number of compiled-sql-statements stored in the cache).
         *
         * max cache size can ONLY be increased from its current size (default = 0).
         * if this method is called with smaller size than the current value of mMaxSqlCacheSize,
         * then IllegalStateException is thrown
         *
         * synchronized because we don't want t threads to change cache size at the same time.
         * @param cacheSize the size of the cache. can be (0 to MAX_SQL_CACHE_SIZE)
         * @throws IllegalStateException if input cacheSize > MAX_SQL_CACHE_SIZE or < 0 or
         * < the value set with previous setMaxSqlCacheSize() call.
         *
         * @hide
         */
        SetMaxSqlCacheSize(
            [in] Int32 cacheSize);
    }

    interface ISQLiteDatabaseHelper {
        /**
         * Open the database according to the flags {@link #OPEN_READWRITE}
         * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
         *
         * <p>Sets the locale of the database to the  the system's current locale.
         * Call {@link #setLocale} if you would like something else.</p>
         *
         * @param path to database file to open and/or create
         * @param factory an optional factory class that is called to instantiate a
         *            cursor when query is called, or null for default
         * @param flags to control database access mode
         * @return the newly opened database
         * @throws SQLiteException if the database cannot be opened
         */
        OpenDatabase(
            [in] String path,
            [in] ICursorFactory* factory,
            [in] Int32 flags,
            [out] ISQLiteDatabase** db);

        /**
         * Equivalent to openDatabase(file.getPath(), factory, CREATE_IF_NECESSARY).
         */
        OpenOrCreateDatabase(
            [in] IFile* file,
            [in] ICursorFactory* factory,
            [out] ISQLiteDatabase** db);

        /**
         * Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).
         */
        OpenOrCreateDatabaseEx(
            [in] String path,
            [in] ICursorFactory* factory,
            [out] ISQLiteDatabase** db);

        /**
         * Create a memory backed SQLite database.  Its contents will be destroyed
         * when the database is closed.
         *
         * <p>Sets the locale of the database to the  the system's current locale.
         * Call {@link #setLocale} if you would like something else.</p>
         *
         * @param factory an optional factory class that is called to instantiate a
         *            cursor when query is called
         * @return a SQLiteDatabase object, or null if the database can't be created
         */
        Create(
            [in] ICursorFactory* factory,
            [out] ISQLiteDatabase** db);

        /**
         * Finds the name of the first table, which is editable.
         *
         * @param tables a list of tables
         * @return the first table listed
         */
        FindEditTable(
            [in] String tables,
            [out] String* resultTables);
    }

}

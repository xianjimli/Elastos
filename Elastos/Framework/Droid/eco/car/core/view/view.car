
module
{
    /**
     * Used to mark a View that has no ID.
     */
    const View_NO_ID = -1;

    /**
     * This view is visible.  Use with {@link #setVisibility}.
     */
    const View_VISIBLE = 0x00000000;

    /**
     * This view is invisible, but it still takes up space for layout purposes.
     * Use with {@link #setVisibility}.
     */
    const View_INVISIBLE = 0x00000004;

     /**
     * This view is invisible, and it doesn't take any space for layout
     * purposes. Use with {@link #setVisibility}.
     */
    const View_GONE = 0x00000008;

    /**
     * Mask for use with setFlags indicating bits used for visibility.
     * {@hide}
     */
    const View_VISIBILITY_MASK = 0x0000000C;

     /**
     * This view is enabled. Intrepretation varies by subclass.
     * Use with ENABLED_MASK when calling setFlags.
     * {@hide}
     */
    const View_ENABLED = 0x00000000;

    /**
     * This view is disabled. Intrepretation varies by subclass.
     * Use with ENABLED_MASK when calling setFlags.
     * {@hide}
     */
    const View_DISABLED = 0x00000020;

   /**
    * Mask for use with setFlags indicating bits used for indicating whether
    * this view is enabled
    * {@hide}
    */
    const View_ENABLED_MASK = 0x00000020;

    /**
     * This view won't draw. {@link #onDraw} won't be called and further
     * optimizations
     * will be performed. It is okay to have this flag set and a background.
     * Use with DRAW_MASK when calling setFlags.
     * {@hide}
     */
    const View_WILL_NOT_DRAW = 0x00000080;

    /**
     * Mask for use with setFlags indicating bits used for indicating whether
     * this view is will draw
     * {@hide}
     */
    const View_DRAW_MASK = 0x00000080;

    /**
     * <p>This view doesn't show scrollbars.</p>
     * {@hide}
     */
    const View_SCROLLBARS_NONE = 0x00000000;

    /**
     * <p>This view shows horizontal scrollbars.</p>
     * {@hide}
     */
    const View_SCROLLBARS_HORIZONTAL = 0x00000100;

    /**
     * <p>This view shows vertical scrollbars.</p>
     * {@hide}
     */
    const View_SCROLLBARS_VERTICAL = 0x00000200;

    /**
     * <p>Mask for use with setFlags indicating bits used for indicating which
     * scrollbars are enabled.</p>
     * {@hide}
     */
    const View_SCROLLBARS_MASK = 0x00000300;

    /**
     * Indicates that the view should filter touches when its window is obscured.
     * Refer to the class comments for more information about this security feature.
     * {@hide}
     */
    const View_FILTER_TOUCHES_WHEN_OBSCURED = 0x00000400;

    /**
     * <p>This view doesn't show fading edges.</p>
     * {@hide}
     */
    const View_FADING_EDGE_NONE = 0x00000000;

    /**
     * <p>Indicates this view can be clicked. When clickable, a View reacts
     * to clicks by notifying the OnClickListener.<p>
     * {@hide}
     */
    const View_CLICKABLE = 0x00004000;

    /**
     * <p>Indicates this view is caching its drawing into a bitmap.</p>
     * {@hide}
     */
    const View_DRAWING_CACHE_ENABLED = 0x00008000;

    /**
     * <p>Indicates that no icicle should be saved for this view.<p>
     * {@hide}
     */
    const View_SAVE_DISABLED = 0x000010000;

    /**
     * <p>Mask for use with setFlags indicating bits used for the saveEnabled
     * property.</p>
     * {@hide}
     */
    const View_SAVE_DISABLED_MASK = 0x000010000;

    /**
     * <p>Indicates that no drawing cache should ever be created for this view.<p>
     * {@hide}
     */
    const View_WILL_NOT_CACHE_DRAWING = 0x000020000;

    /**
     * <p>Indicates this view can take / keep focus when int touch mode.</p>
     * {@hide}
     */
    const View_FOCUSABLE_IN_TOUCH_MODE = 0x00040000;

    /**
     * <p>Enables low quality mode for the drawing cache.</p>
     */
    const View_DRAWING_CACHE_QUALITY_LOW = 0x00080000;

    /**
     * <p>Enables high quality mode for the drawing cache.</p>
     */
    const View_DRAWING_CACHE_QUALITY_HIGH = 0x00100000;

    /**
     * <p>Enables automatic quality mode for the drawing cache.</p>
     */
    const View_DRAWING_CACHE_QUALITY_AUTO = 0x00000000;

    /*private static final int[] DRAWING_CACHE_QUALITY_FLAGS = {
            DRAWING_CACHE_QUALITY_AUTO, DRAWING_CACHE_QUALITY_LOW, DRAWING_CACHE_QUALITY_HIGH
    };*/

    /**
     * <p>Mask for use with setFlags indicating bits used for the cache
     * quality property.</p>
     * {@hide}
     */
    const View_DRAWING_CACHE_QUALITY_MASK = 0x00180000;

    /**
     * <p>
     * Indicates this view can be long clicked. When long clickable, a View
     * reacts to long clicks by notifying the OnLongClickListener or showing a
     * context menu.
     * </p>
     * {@hide}
     */
    const View_LONG_CLICKABLE = 0x00200000;

    /**
     * <p>Indicates that this view gets its drawable states from its direct parent
     * and ignores its original internal states.</p>
     *
     * @hide
     */
    const View_DUPLICATE_PARENT_STATE = 0x00400000;

    /**
     * <p>This view shows horizontal fading edges.</p>
     * {@hide}
     */
    const View_FADING_EDGE_HORIZONTAL = 0x00001000;

    /**
     * <p>This view shows vertical fading edges.</p>
     * {@hide}
     */
    const View_FADING_EDGE_VERTICAL = 0x00002000;

    /**
     * <p>Mask for use with setFlags indicating bits used for indicating which
     * fading edges are enabled.</p>
     * {@hide}
     */
    const View_FADING_EDGE_MASK = 0x00003000;

    /**
     * The scrollbar style to display the scrollbars inside the content area,
     * without increasing the padding. The scrollbars will be overlaid with
     * translucency on the view's content.
     */
    const View_SCROLLBARS_INSIDE_OVERLAY = 0;

    /**
     * The scrollbar style to display the scrollbars inside the padded area,
     * increasing the padding of the view. The scrollbars will not overlap the
     * content area of the view.
     */
    const View_SCROLLBARS_INSIDE_INSET = 0x01000000;

    /**
     * The scrollbar style to display the scrollbars at the edge of the view,
     * without increasing the padding. The scrollbars will be overlaid with
     * translucency.
     */
    const View_SCROLLBARS_OUTSIDE_OVERLAY = 0x02000000;

    /**
     * The scrollbar style to display the scrollbars at the edge of the view,
     * increasing the padding of the view. The scrollbars will only overlap the
     * background, if any.
     */
    const View_SCROLLBARS_OUTSIDE_INSET = 0x03000000;

    /**
     * Mask to check if the scrollbar style is overlay or inset.
     * {@hide}
     */
    const View_SCROLLBARS_INSET_MASK = 0x01000000;

    /**
     * Mask to check if the scrollbar style is inside or outside.
     * {@hide}
     */
    const View_SCROLLBARS_OUTSIDE_MASK = 0x02000000;

    /**
     * Mask for scrollbar style.
     * {@hide}
     */
    const View_SCROLLBARS_STYLE_MASK = 0x03000000;

    /**
     * View flag indicating that the screen should remain on while the
     * window containing this view is visible to the user.  This effectively
     * takes care of automatically setting the WindowManager's
     * {@link WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON}.
     */
    const View_KEEP_SCREEN_ON = 0x04000000;

    /**
     * View flag indicating whether this view should have sound effects enabled
     * for events such as clicking and touching.
     */
    const View_SOUND_EFFECTS_ENABLED = 0x08000000;

    /**
     * View flag indicating whether this view should have haptic feedback
     * enabled for events such as long presses.
     */
    const View_HAPTIC_FEEDBACK_ENABLED = 0x10000000;

    /**
     * View flag indicating whether {@link #addFocusables(ArrayList, int, int)}
     * should add all focusable Views regardless if they are focusable in touch mode.
     */
    const View_FOCUSABLES_ALL = 0x00000000;

    /**
     * View flag indicating whether {@link #addFocusables(ArrayList, int, int)}
     * should add only Views focusable in touch mode.
     */
    const View_FOCUSABLES_TOUCH_MODE = 0x00000001;

    /**
     * Use with {@link #focusSearch}. Move focus to the previous selectable
     * item.
     */
    const View_FOCUS_BACKWARD = 0x00000001;

    /**
     * Use with {@link #focusSearch}. Move focus to the next selectable
     * item.
     */
    const View_FOCUS_FORWARD = 0x00000002;

    /**
     * Use with {@link #focusSearch}. Move focus to the left.
     */
    const View_FOCUS_LEFT = 0x00000011;

    /**
     * Use with {@link #focusSearch}. Move focus up.
     */
    const View_FOCUS_UP = 0x00000021;

    /**
     * Use with {@link #focusSearch}. Move focus to the right.
     */
    const View_FOCUS_RIGHT = 0x00000042;

    /**
     * Use with {@link #focusSearch}. Move focus down.
     */
    const View_FOCUS_DOWN = 0x00000082;

    interface IContext;
    interface IViewParent;
    interface IViewGroupLayoutParams;
    interface IRect;
    interface IBinder;
    interface IResources;
    interface IDrawable;
    interface IKeyEvent;
    interface ITouchDelegate;
    interface IDispatcherState;
    interface IAbsSavedState;
    interface IView;
    interface IAccessibilityEvent;
    interface IAnimation;
    interface IViewTreeObserver;
    interface IEditorInfo;
    interface IInputConnection;

    /**
     * Interface definition for a callback to be invoked when a key event is
     * dispatched to this view. The callback will be invoked before the key
     * event is given to the view.
     */
    interface IViewOnKeyListener {
        /**
         * Called when a key is dispatched to a view. This allows listeners to
         * get a chance to respond before the target view.
         *
         * @param v The view the key has been dispatched to.
         * @param keyCode The code for the physical key that was pressed
         * @param event The KeyEvent object containing full information about
         *        the event.
         * @return True if the listener has consumed the event, false otherwise.
         */
        OnKey(
            [in] IView* v,
            [in] Int32 keyCode,
            [in] IKeyEvent* event,
            [out] Boolean* result);
    }

    /**
     * Interface definition for a callback to be invoked when a touch event is
     * dispatched to this view. The callback will be invoked before the touch
     * event is given to the view.
     */
    interface IViewOnTouchListener {
        /**
         * Called when a touch event is dispatched to a view. This allows listeners to
         * get a chance to respond before the target view.
         *
         * @param v The view the touch event has been dispatched to.
         * @param event The MotionEvent object containing full information about
         *        the event.
         * @return True if the listener has consumed the event, false otherwise.
         */
        OnTouch(
            [in] IView* v,
            [in] IMotionEvent* event,
            [out] Boolean* result);
    }

    /**
     * Interface definition for a callback to be invoked when a view has been clicked and held.
     */
    interface IViewOnLongClickListener {
        /**
         * Called when a view has been clicked and held.
         *
         * @param v The view that was clicked and held.
         *
         * @return true if the callback consumed the long click, false otherwise.
         */
        OnLongClick(
            [in] IView* v,
            [out] Boolean* result);
    }

    /**
     * Interface definition for a callback to be invoked when the focus state of
     * a view changed.
     */
    interface IViewOnFocusChangeListener {
        /**
         * Called when the focus state of a view has changed.
         *
         * @param v The view whose state has changed.
         * @param hasFocus The new focus state of v.
         */
        OnFocusChange(
            [in] IView* v,
            [in] Boolean hasFocus);
    }

    /**
     * Interface definition for a callback to be invoked when a view is clicked.
     */
    interface IViewOnClickListener {
        /**
         * Called when a view has been clicked.
         *
         * @param v The view that was clicked.
         */
        OnClick(
            [in] IView* v);
    }

    /**
     * Interface definition for a callback to be invoked when the context menu
     * for this view is being built.
     */
    interface IViewOnCreateContextMenuListener {
        /**
         * Called when the context menu for this view is being built. It is not
         * safe to hold onto the menu after this method returns.
         *
         * @param menu The context menu that is being built
         * @param v The view for which the context menu is being built
         * @param menuInfo Extra information about the item for which the
         *            context menu should be shown. This information will vary
         *            depending on the class of v.
         */
        OnCreateContextMenu(
            [in] IContextMenu* menu,
            [in] IView* v,
            [in] IContextMenuInfo* menuInfo);
    }

    interface IViewBaseSavedState extends IAbsSavedState {
    }

    interface IView {
        /**
         * Returns the size of the vertical faded edges used to indicate that more
         * content in this view is visible.
         *
         * @return The size in pixels of the vertical faded edge or 0 if vertical
         *         faded edges are not enabled for this view.
         * @attr ref android.R.styleable#View_fadingEdgeLength
         */
        GetVerticalFadingEdgeLength(
            [out] Int32* length);

        /**
         * Set the size of the faded edge used to indicate that more content in this
         * view is available.  Will not change whether the fading edge is enabled; use
         * {@link #setVerticalFadingEdgeEnabled} or {@link #setHorizontalFadingEdgeEnabled}
         * to enable the fading edge for the vertical or horizontal fading edges.
         *
         * @param length The size in pixels of the faded edge used to indicate that more
         *        content in this view is visible.
         */
        SetFadingEdgeLength(
            [in] Int32 length);

        /**
         * Returns the size of the horizontal faded edges used to indicate that more
         * content in this view is visible.
         *
         * @return The size in pixels of the horizontal faded edge or 0 if horizontal
         *         faded edges are not enabled for this view.
         * @attr ref android.R.styleable#View_fadingEdgeLength
         */
        GetHorizontalFadingEdgeLength(
            [out] Int32* length);

        /**
         * Returns the width of the vertical scrollbar.
         *
         * @return The width in pixels of the vertical scrollbar or 0 if there
         *         is no vertical scrollbar.
         */
        GetVerticalScrollbarWidth(
            [out] Int32* width);

        /**
         * Returns the height of the horizontal scrollbar.
         *
         * @return The height in pixels of the horizontal scrollbar or 0 if
         *         there is no horizontal scrollbar.
         */
        GetHorizontalScrollbarHeight(
            [out] Int32* height);

        /**
         * Register a callback to be invoked when focus of this view changed.
         *
         * @param l The callback that will run.
         */
        SetOnFocusChangeListener(
            [in] IViewOnFocusChangeListener* l);

        /**
         * Returns the focus-change callback registered for this view.
         *
         * @return The callback, or NULL if one is not registered.
         */
        GetOnFocusChangeListener(
            [out] IViewOnFocusChangeListener** l);

        /**
         * Register a callback to be invoked when this view is clicked. If this view is not
         * clickable, it becomes clickable.
         *
         * @param l The callback that will run
         *
         * @see #setClickable(Boolean)
         */
        SetOnClickListener(
            [in] IViewOnClickListener* l);

        /**
         * Register a callback to be invoked when this view is clicked and held. If this view is not
         * long clickable, it becomes long clickable.
         *
         * @param l The callback that will run
         *
         * @see #setLongClickable(Boolean)
         */
        SetOnLongClickListener(
            [in] IViewOnLongClickListener* l);

        /**
         * Register a callback to be invoked when the context menu for this view is
         * being built. If this view is not long clickable, it becomes long clickable.
         *
         * @param l The callback that will run
         *
         */
        SetOnCreateContextMenuListener(
            [in] IViewOnCreateContextMenuListener* l);

        /**
         * Call this view's OnClickListener, if it is defined.
         *
         * @return True there was an assigned OnClickListener that was called, FALSE
         *         otherwise is returned.
         */
        PerformClick(
            [out] Boolean* result);

        /**
         * Call this view's OnLongClickListener, if it is defined. Invokes the context menu if the
         * OnLongClickListener did not consume the event.
         *
         * @return True if one of the above receivers consumed the event, FALSE otherwise.
         */
        PerformLongClick(
            [out] Boolean* result);

        /**
         * Bring up the context menu for this view.
         *
         * @return Whether a context menu was displayed.
         */
        ShowContextMenu(
            [out] Boolean* result);

        /***
         * Register a callback to be invoked when a key is pressed in this view.
         * @param l the key listener to attach to this view
         */
        SetOnKeyListener(
            [in] IViewOnKeyListener* l);

        /**
         * Register a callback to be invoked when a touch event is sent to this view.
         * @param l the touch listener to attach to this view
         */
        SetOnTouchListener(
            [in] IViewOnTouchListener* l);

        /**
         * Request that a rectangle of this view be visible on the screen,
         * scrolling if necessary just enough.
         *
         * <p>A View should call this if it maintains some notion of which part
         * of its content is interesting.  For example, a text editing view
         * should call this when its cursor moves.
         *
         * @param rectangle The rectangle.
         * @return Whether any parent scrolled.
         */
        RequestRectangleOnScreen(
            [in] IRect* rectangle,
            [out] Boolean* result);

        /**
         * Request that a rectangle of this view be visible on the screen,
         * scrolling if necessary just enough.
         *
         * <p>A View should call this if it maintains some notion of which part
         * of its content is interesting.  For example, a text editing view
         * should call this when its cursor moves.
         *
         * <p>When <code>immediate</code> is set to true, scrolling will not be
         * animated.
         *
         * @param rectangle The rectangle.
         * @param immediate True to forbid animated scrolling, false otherwise
         * @return Whether any parent scrolled.
         */
        RequestRectangleOnScreenEx(
            [in] IRect* rectangle,
            [in] Boolean immediate,
            [out] Boolean* result);

        /**
         * Called when this view wants to give up focus. This will cause
         * {@link #onFocusChanged} to be called.
         */
        ClearFocus();

        /**
         * Returns true if this view has focus iteself, or is the ancestor of the
         * view that has focus.
         *
         * @return True if this view has or contains focus, false otherwise.
         */
        HasFocus(
            [out] Boolean* hasFocus);

        /**
         * Returns true if this view is focusable or if it contains a reachable View
         * for which {@link #hasFocusable()} returns true. A "reachable hasFocusable()"
         * is a View whose parents do not block descendants focus.
         *
         * Only {@link #VISIBLE} views are considered focusable.
         *
         * @return True if the view is focusable or if the view contains a focusable
         *         View, false otherwise.
         *
         * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
         */
        HasFocusable(
            [out] Boolean* hasFocusable);

        /**
         * Dispatches an {@link AccessibilityEvent} to the {@link View} children
         * to be populated.
         *
         * @param event The event.
         *
         * @return True if the event population was completed.
         */
        DispatchPopulateAccessibilityEvent(
            [in] IAccessibilityEvent* event,
            [out] Boolean* result);

        /**
         * Gets the {@link View} description. It briefly describes the view and is
         * primarily used for accessibility support. Set this property to enable
         * better accessibility support for your application. This is especially
         * true for views that do not have textual representation (For example,
         * ImageButton).
         *
         * @return The content descriptiopn.
         *
         * @attr ref android.R.styleable#View_contentDescription
         */
        GetContentDescription(
            [out, callee] ArrayOf<Char8>* description);

        /**
         * Sets the {@link View} description. It briefly describes the view and is
         * primarily used for accessibility support. Set this property to enable
         * better accessibility support for your application. This is especially
         * true for views that do not have textual representation (For example,
         * ImageButton).
         *
         * @param contentDescription The content description.
         *
         * @attr ref android.R.styleable#View_contentDescription
         */
        SetContentDescription(
            [in] ArrayOf<Char8> contentDescription);

        /**
         * Returns true if this view has focus
         *
         * @return True if this view has focus, false otherwise.
         */
        IsFocused(
            [out] Boolean* focused);

        /**
         * Find the view in the hierarchy rooted at this view that currently has
         * focus.
         *
         * @return The view that currently has focus, or NULL if no focused view can
         *         be found.
         */
        FindFocus(
            [out] IView** view);

        /**
         * Change whether this view is one of the set of scrollable containers in
         * its window.  This will be used to determine whether the window can
         * resize or must pan when a soft input area is open -- scrollable
         * containers allow the window to use resize mode since the container
         * will appropriately shrink.
         */
        SetScrollContainer(
            [in] Boolean isScrollContainer);

        /**
         * Returns the quality of the drawing cache.
         *
         * @return One of {@link #DRAWING_CACHE_QUALITY_AUTO},
         *         {@link #DRAWING_CACHE_QUALITY_LOW}, or {@link #DRAWING_CACHE_QUALITY_HIGH}
         *
         * @see #setDrawingCacheQuality(int)
         * @see #setDrawingCacheEnabled(boolean)
         * @see #isDrawingCacheEnabled()
         *
         * @attr ref android.R.styleable#View_drawingCacheQuality
         */
        GetDrawingCacheQuality(
            [out] Int32* quality);

        /**
         * Set the drawing cache quality of this view. This value is used only when the
         * drawing cache is enabled
         *
         * @param quality One of {@link #DRAWING_CACHE_QUALITY_AUTO},
         *        {@link #DRAWING_CACHE_QUALITY_LOW}, or {@link #DRAWING_CACHE_QUALITY_HIGH}
         *
         * @see #getDrawingCacheQuality()
         * @see #setDrawingCacheEnabled(boolean)
         * @see #isDrawingCacheEnabled()
         *
         * @attr ref android.R.styleable#View_drawingCacheQuality
         */
        SetDrawingCacheQuality(
            [in] Int32 quality);

        /**
         * Returns whether the screen should remain on, corresponding to the current
         * value of {@link #KEEP_SCREEN_ON}.
         *
         * @return Returns true if {@link #KEEP_SCREEN_ON} is set.
         *
         * @see #setKeepScreenOn(boolean)
         *
         * @attr ref android.R.styleable#View_keepScreenOn
         */
        GetKeepScreenOn(
            [out] Boolean* result);

        /**
         * Controls whether the screen should remain on, modifying the
         * value of {@link #KEEP_SCREEN_ON}.
         *
         * @param keepScreenOn Supply true to set {@link #KEEP_SCREEN_ON}.
         *
         * @see #getKeepScreenOn()
         *
         * @attr ref android.R.styleable#View_keepScreenOn
         */
        SetKeepScreenOn(
            [in] Boolean keepScreenOn);

        /**
         * @return The user specified next focus ID.
         *
         * @attr ref android.R.styleable#View_nextFocusLeft
         */
        GetNextFocusLeftId(
            [out] Int32* nextFocusLeftId);

        /**
         * Set the id of the view to use for the next focus
         *
         * @param nextFocusLeftId
         *
         * @attr ref android.R.styleable#View_nextFocusLeft
         */
        SetNextFocusLeftId(
            [in] Int32 nextFocusLeftId);

        /**
         * @return The user specified next focus ID.
         *
         * @attr ref android.R.styleable#View_nextFocusRight
         */
        GetNextFocusRightId(
            [out] Int32* nextFocusRightId);

        /**
         * Set the id of the view to use for the next focus
         *
         * @param nextFocusRightId
         *
         * @attr ref android.R.styleable#View_nextFocusRight
         */
        SetNextFocusRightId(
            [in] Int32 nextFocusRightId);

        /**
         * @return The user specified next focus ID.
         *
         * @attr ref android.R.styleable#View_nextFocusUp
         */
        GetNextFocusUpId(
            [out] Int32* nextFocusUpId);

        /**
         * Set the id of the view to use for the next focus
         *
         * @param nextFocusUpId
         *
         * @attr ref android.R.styleable#View_nextFocusUp
         */
        SetNextFocusUpId(
            [in] Int32 nextFocusUpId);

        /**
         * @return The user specified next focus ID.
         *
         * @attr ref android.R.styleable#View_nextFocusDown
         */
        GetNextFocusDownId(
            [out] Int32* nextFocusDownId);

        /**
         * Set the id of the view to use for the next focus
         *
         * @param nextFocusDownId
         *
         * @attr ref android.R.styleable#View_nextFocusDown
         */
        SetNextFocusDownId(
            [in] Int32 nextFocusDownId);

        /**
         * Returns the visibility of this view and all of its ancestors
         *
         * @return True if this view and all of its ancestors are {@link #VISIBLE}
         */
        IsShown(
            [out] Boolean* shown);

        /**
         * Determine if this view has the FITS_SYSTEM_WINDOWS flag set.
         * @return True if window has FITS_SYSTEM_WINDOWS set
         *
         * @hide
         */
        IsFitsSystemWindowsFlagSet(
            [out] Boolean* flag);

        /**
         * Returns the visibility status for this view.
         *
         * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
         * @attr ref android.R.styleable#View_visibility
         */
        GetVisibility(
            [out] Int32* visibility);

        /**
         * Set the enabled state of this view.
         *
         * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
         * @attr ref android.R.styleable#View_visibility
         */
        SetVisibility(
            [in] Int32 visibility);

        /**
         * Returns the enabled status for this view. The interpretation of the
         * enabled state varies by subclass.
         *
         * @return True if this view is enabled, false otherwise.
         */
        IsEnabled(
            [out] Boolean* enabled);

        /**
         * Set the enabled state of this view. The interpretation of the enabled
         * state varies by subclass.
         *
         * @param enabled True if this view is enabled, false otherwise.
         */
        SetEnabled(
            [in] Boolean enabled);

        /**
         * Set whether this view can receive the focus.
         *
         * Setting this to false will also ensure that this view is not focusable
         * in touch mode.
         *
         * @param focusable If true, this view can receive the focus.
         *
         * @see #setFocusableInTouchMode(boolean)
         * @attr ref android.R.styleable#View_focusable
         */
        SetFocusable(
            [in] Boolean focusable);

        /**
         * Set whether this view can receive focus while in touch mode.
         *
         * Setting this to true will also ensure that this view is focusable.
         *
         * @param focusableInTouchMode If true, this view can receive the focus while
         *   in touch mode.
         *
         * @see #setFocusable(boolean)
         * @attr ref android.R.styleable#View_focusableInTouchMode
         */
        SetFocusableInTouchMode(
            [in] Boolean focusableInTouchMode);

        /**
         * Set whether this view should have sound effects enabled for events such as
         * clicking and touching.
         *
         * <p>You may wish to disable sound effects for a view if you already play sounds,
         * for instance, a dial key that plays dtmf tones.
         *
         * @param soundEffectsEnabled whether sound effects are enabled for this view.
         * @see #isSoundEffectsEnabled()
         * @see #playSoundEffect(int)
         * @attr ref android.R.styleable#View_soundEffectsEnabled
         */
        SetSoundEffectsEnabled(
            [in] Boolean soundEffectsEnabled);

        /**
         * @return whether this view should have sound effects enabled for events such as
         *     clicking and touching.
         *
         * @see #setSoundEffectsEnabled(boolean)
         * @see #playSoundEffect(int)
         * @attr ref android.R.styleable#View_soundEffectsEnabled
         */
        IsSoundEffectsEnabled(
            [out] Boolean* soundEffectsEnabled);

        /**
         * Set whether this view should have haptic feedback for events such as
         * long presses.
         *
         * <p>You may wish to disable haptic feedback if your view already controls
         * its own haptic feedback.
         *
         * @param hapticFeedbackEnabled whether haptic feedback enabled for this view.
         * @see #isHapticFeedbackEnabled()
         * @see #performHapticFeedback(int)
         * @attr ref android.R.styleable#View_hapticFeedbackEnabled
         */
        SetHapticFeedbackEnabled(
            [in] Boolean hapticFeedbackEnabled);

        /**
         * @return whether this view should have haptic feedback enabled for events
         * long presses.
         *
         * @see #setHapticFeedbackEnabled(boolean)
         * @see #performHapticFeedback(int)
         * @attr ref android.R.styleable#View_hapticFeedbackEnabled
         */
        IsHapticFeedbackEnabled(
            [out] Boolean* hapticFeedbackEnabled);

        /**
         * If this view doesn't do any drawing on its own, set this flag to
         * allow further optimizations. By default, this flag is not set on
         * View, but could be set on some View subclasses such as ViewGroup.
         *
         * Typically, if you override {@link #onDraw} you should clear this flag.
         *
         * @param willNotDraw whether or not this View draw on its own
         */
        SetWillNotDraw(
            [in] Boolean willNotDraw);

        /**
         * Returns whether or not this View draws on its own.
         *
         * @return true if this view has nothing to draw, false otherwise
         */
        WillNotDraw(
            [out] Boolean* willNotDraw);

        /**
         * When a View's drawing cache is enabled, drawing is redirected to an
         * offscreen bitmap. Some views, like an ImageView, must be able to
         * bypass this mechanism if they already draw a single bitmap, to avoid
         * unnecessary usage of the memory.
         *
         * @param willNotCacheDrawing true if this view does not cache its
         *        drawing, false otherwise
         */
        SetWillNotCacheDrawing(
            [in] Boolean willNotCacheDrawing);

        /**
         * Returns whether or not this View can cache its drawing or not.
         *
         * @return true if this view does not cache its drawing, false otherwise
         */
        WillNotCacheDrawing(
            [out] Boolean* cache);

        /**
         * Indicates whether this view reacts to click events or not.
         *
         * @return true if the view is clickable, false otherwise
         *
         * @see #setClickable(boolean)
         * @attr ref android.R.styleable#View_clickable
         */
        IsClickable(
            [out] Boolean* clickable);

        /**
         * Enables or disables click events for this view. When a view
         * is clickable it will change its state to "pressed" on every click.
         * Subclasses should set the view clickable to visually react to
         * user's clicks.
         *
         * @param clickable true to make the view clickable, false otherwise
         *
         * @see #isClickable()
         * @attr ref android.R.styleable#View_clickable
         */
        SetClickable(
            [in] Boolean clickable);

        /**
         * Indicates whether this view reacts to long click events or not.
         *
         * @return true if the view is long clickable, false otherwise
         *
         * @see #setLongClickable(boolean)
         * @attr ref android.R.styleable#View_longClickable
         */
        IsLongClickable(
            [out] Boolean* longClickable);

        /**
         * Enables or disables long click events for this view. When a view is long
         * clickable it reacts to the user holding down the button for a longer
         * duration than a tap. This event can either launch the listener or a
         * context menu.
         *
         * @param longClickable true to make the view long clickable, false otherwise
         * @see #isLongClickable()
         * @attr ref android.R.styleable#View_longClickable
         */
        SetLongClickable(
            [in] Boolean longClickable);

        /**
         * Sets the pressed that for this view.
         *
         * @see #isClickable()
         * @see #setClickable(boolean)
         *
         * @param pressed Pass true to set the View's internal state to "pressed", or false to reverts
         *        the View's internal state from a previously set "pressed" state.
         */
        SetPressed(
            [in] Boolean pressed);

        /**
         * Indicates whether the view is currently in pressed state. Unless
         * {@link #setPressed(boolean)} is explicitly called, only clickable views can enter
         * the pressed state.
         *
         * @see #setPressed
         * @see #isClickable()
         * @see #setClickable(boolean)
         *
         * @return true if the view is currently pressed, false otherwise
         */
        IsPressed(
            [out] Boolean* pressed);

        /**
         * Indicates whether this view will save its state (that is,
         * whether its {@link #onSaveInstanceState} method will be called).
         *
         * @return Returns true if the view state saving is enabled, else false.
         *
         * @see #setSaveEnabled(boolean)
         * @attr ref android.R.styleable#View_saveEnabled
         */
        IsSaveEnabled(
            [out] Boolean* enabled);

        /**
         * Controls whether the saving of this view's state is
         * enabled (that is, whether its {@link #onSaveInstanceState} method
         * will be called).  Note that even if freezing is enabled, the
         * view still must have an id assigned to it (via {@link #setId setId()})
         * for its state to be saved.  This flag can only disable the
         * saving of this view; any child views may still have their state saved.
         *
         * @param enabled Set to false to <em>disable</em> state saving, or true
         * (the default) to allow it.
         *
         * @see #isSaveEnabled()
         * @see #setId(int)
         * @see #onSaveInstanceState()
         * @attr ref android.R.styleable#View_saveEnabled
         */
        SetSaveEnabled(
            [in] Boolean enabled);

        /**
         * Gets whether the framework should discard touches when the view's
         * window is obscured by another visible window.
         * Refer to the {@link View} security documentation for more details.
         *
         * @return True if touch filtering is enabled.
         *
         * @see #setFilterTouchesWhenObscured(boolean)
         * @attr ref android.R.styleable#View_filterTouchesWhenObscured
         */
        GetFilterTouchesWhenObscured(
            [out] Boolean* enabled);

        /**
         * Sets whether the framework should discard touches when the view's
         * window is obscured by another visible window.
         * Refer to the {@link View} security documentation for more details.
         *
         * @param enabled True if touch filtering should be enabled.
         *
         * @see #getFilterTouchesWhenObscured
         * @attr ref android.R.styleable#View_filterTouchesWhenObscured
         */
        SetFilterTouchesWhenObscured(
            [in] Boolean enabled);

        /**
         * Returns whether this View is able to take focus.
         *
         * @return True if this view can take focus, or false otherwise.
         * @attr ref android.R.styleable#View_focusable
         */
        IsFocusable(
            [out] Boolean* focusable);

        /**
         * When a view is focusable, it may not want to take focus when in touch mode.
         * For example, a button would like focus when the user is navigating via a D-pad
         * so that the user can click on it, but once the user starts touching the screen,
         * the button shouldn't take focus
         * @return Whether the view is focusable in touch mode.
         * @attr ref android.R.styleable#View_focusableInTouchMode
         */
        IsFocusableInTouchMode(
            [out] Boolean* focusable);

        /**
         * Find the nearest view in the specified direction that can take focus.
         * This does not actually give focus to that view.
         *
         * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
         *
         * @return The nearest focusable in the specified direction, or NULL if none
         *         can be found.
         */
        FocusSearch(
            [in] Int32 direction,
            [out] IView** view);

        /**
         * This method is the last chance for the focused view and its ancestors to
         * respond to an arrow key. This is called when the focused view did not
         * consume the key internally, nor could the view system find a new view in
         * the requested direction to give focus to.
         *
         * @param focused The currently focused view.
         * @param direction The direction focus wants to move. One of FOCUS_UP,
         *        FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT.
         * @return True if the this view consumed this unhandled move.
         */
        DispatchUnhandledMove(
            [in] IView* focused,
            [in] Int32 direction,
            [out] Boolean* result);

        /**
         * Find and return all focusable views that are descendants of this view,
         * possibly including this view if it is focusable itself.
         *
         * @param direction The direction of the focus
         * @return A list of focusable views
         */
        GetFocusables(
            [in] Int32 direction,
            [out] IObjectContainer** views);

        /**
         * Add any focusable views that are descendants of this view (possibly
         * including this view if it is focusable itself) to views.  If we are in touch mode,
         * only add views that are also focusable in touch mode.
         *
         * @param views Focusable views found so far
         * @param direction The direction of the focus
         */
        AddFocusables(
            [in] IObjectContainer* views,
            [in] Int32 direction);

        /**
         * Adds any focusable views that are descendants of this view (possibly
         * including this view if it is focusable itself) to views. This method
         * adds all focusable views regardless if we are in touch mode or
         * only views focusable in touch mode if we are in touch mode depending on
         * the focusable mode paramater.
         *
         * @param views Focusable views found so far or NULL if all we are interested is
         *        the number of focusables.
         * @param direction The direction of the focus.
         * @param focusableMode The type of focusables to be added.
         *
         * @see #FOCUSABLES_ALL
         * @see #FOCUSABLES_TOUCH_MODE
         */
        AddFocusablesEx(
            [in] IObjectContainer* views,
            [in] Int32 direction,
            [in] Int32 focusableMode);

        /**
         * Find and return all touchable views that are descendants of this view,
         * possibly including this view if it is touchable itself.
         *
         * @return A list of touchable views
         */
        GetTouchables(
            [out] IObjectContainer** views);

        /**
         * Add any touchable views that are descendants of this view (possibly
         * including this view if it is touchable itself) to views.
         *
         * @param views Touchable views found so far
         */
        AddTouchables(
            [in] IObjectContainer* views);

        /**
         * Call this to try to give focus to a specific view or to one of its
         * descendants.
         *
         * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns false),
         * or if it is focusable and it is not focusable in touch mode ({@link #isFocusableInTouchMode})
         * while the device is in touch mode.
         *
         * See also {@link #focusSearch}, which is what you call to say that you
         * have focus, and you want your parent to look for the next one.
         *
         * This is equivalent to calling {@link #requestFocus(int, Rect)} with arguments
         * {@link #FOCUS_DOWN} and <code>NULL</code>.
         *
         * @return Whether this view or one of its descendants actually took focus.
         */
        RequestFocus(
            [out] Boolean* result);

        /**
         * Call this to try to give focus to a specific view or to one of its
         * descendants and give it a hint about what direction focus is heading.
         *
         * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns false),
         * or if it is focusable and it is not focusable in touch mode ({@link #isFocusableInTouchMode})
         * while the device is in touch mode.
         *
         * See also {@link #focusSearch}, which is what you call to say that you
         * have focus, and you want your parent to look for the next one.
         *
         * This is equivalent to calling {@link #requestFocus(int, Rect)} with
         * <code>NULL</code> set for the previously focused rectangle.
         *
         * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
         * @return Whether this view or one of its descendants actually took focus.
         */
        RequestFocusEx(
            [in] Int32 direction,
            [out] Boolean* result);

        /**
         * Call this to try to give focus to a specific view or to one of its descendants
         * and give it hints about the direction and a specific rectangle that the focus
         * is coming from.  The rectangle can help give larger views a finer grained hint
         * about where focus is coming from, and therefore, where to show selection, or
         * forward focus change internally.
         *
         * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns false),
         * or if it is focusable and it is not focusable in touch mode ({@link #isFocusableInTouchMode})
         * while the device is in touch mode.
         *
         * A View will not take focus if it is not visible.
         *
         * A View will not take focus if one of its parents has {@link android.view.ViewGroup#getDescendantFocusability()}
         * equal to {@link ViewGroup#FOCUS_BLOCK_DESCENDANTS}.
         *
         * See also {@link #focusSearch}, which is what you call to say that you
         * have focus, and you want your parent to look for the next one.
         *
         * You may wish to override this method if your custom {@link View} has an internal
         * {@link View} that it wishes to forward the request to.
         *
         * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
         * @param previouslyFocusedRect The rectangle (in this View's coordinate system)
         *        to give a finer grained hint about where focus is coming from.  May be NULL
         *        if there is no hint.
         * @return Whether this view or one of its descendants actually took focus.
         */
        RequestFocusEx2(
            [in] Int32 direction,
            [in] IRect* previouslyFocusedRect,
            [out] Boolean* result);

        /**
         * Call this to try to give focus to a specific view or to one of its descendants. This is a
         * special variant of {@link #requestFocus() } that will allow views that are not focuable in
         * touch mode to request focus when they are touched.
         *
         * @return Whether this view or one of its descendants actually took focus.
         *
         * @see #isInTouchMode()
         *
         */
        RequestFocusFromTouch(
            [out] Boolean* result);

        DispatchStartTemporaryDetach();

        /**
         * This is called when a container is going to temporarily detach a child, with
         * {@link ViewGroup#detachViewFromParent(View) ViewGroup.detachViewFromParent}.
         * It will either be followed by {@link #onFinishTemporaryDetach()} or
         * {@link #onDetachedFromWindow()} when the container is done.
         */
        OnStartTemporaryDetach();

        DispatchFinishTemporaryDetach();

        /**
         * Called after {@link #onStartTemporaryDetach} when the container is done
         * changing the view.
         */
        OnFinishTemporaryDetach();

        /**
         * Return the global {@link KeyEvent.DispatcherState KeyEvent.DispatcherState}
         * for this view's window.  Returns null if the view is not currently attached
         * to the window.  Normally you will not need to use this directly, but
         * just use the standard high-level event callbacks like {@link #onKeyDown}.
         */
        GetKeyDispatcherState(
            [out] IDispatcherState** state);

        /**
         * Dispatch a key event before it is processed by any input method
         * associated with the view hierarchy.  This can be used to intercept
         * key events in special situations before the IME consumes them; a
         * typical example would be handling the BACK key to update the application's
         * UI instead of allowing the IME to see it and close itself.
         *
         * @param event The key event to be dispatched.
         * @return True if the event was handled, false otherwise.
         */
        DispatchKeyEventPreIme(
            [in] IKeyEvent* event,
            [out] Boolean* result);

        /**
         * Dispatch a key event to the next view on the focus path. This path runs
         * from the top of the view tree down to the currently focused view. If this
         * view has focus, it will dispatch to itself. Otherwise it will dispatch
         * the next node down the focus path. This method also fires any key
         * listeners.
         *
         * @param event The key event to be dispatched.
         * @return True if the event was handled, false otherwise.
         */
        DispatchKeyEvent(
            [in] IKeyEvent* event,
            [out] Boolean* result);

        /**
         * Dispatches a key shortcut event.
         *
         * @param event The key event to be dispatched.
         * @return True if the event was handled by the view, false otherwise.
         */
        DispatchKeyShortcutEvent(
            [in] IKeyEvent* event,
            [out] Boolean* result);

        /**
         * Pass the touch screen motion event down to the target view, or this
         * view if it is the target.
         *
         * @param event The motion event to be dispatched.
         * @return True if the event was handled by the view, false otherwise.
         */
        DispatchTouchEvent(
            [in] IMotionEvent* event,
            [out] Boolean* result);

        /**
         * Filter the touch event to apply security policies.
         *
         * @param event The motion event to be filtered.
         * @return True if the event should be dispatched, false if the event should be dropped.
         *
         * @see #getFilterTouchesWhenObscured
         */
        OnFilterTouchEventForSecurity(
            [in] IMotionEvent* event,
            [out] Boolean* result);

        /**
         * Pass a trackball motion event down to the focused view.
         *
         * @param event The motion event to be dispatched.
         * @return True if the event was handled by the view, false otherwise.
         */
        DispatchTrackballEvent(
            [in] IMotionEvent* event,
            [out] Boolean* result);

        /**
         * Called when the window containing this view gains or loses window focus.
         * ViewGroups should override to route to their children.
         *
         * @param hasFocus True if the window containing this view now has focus,
         *        false otherwise.
         */
        DispatchWindowFocusChanged(
            [in] Boolean hasFocus);

        /**
         * Called when the window containing this view gains or loses focus.  Note
         * that this is separate from view focus: to receive key events, both
         * your view and its window must have focus.  If a window is displayed
         * on top of yours that takes input focus, then your own window will lose
         * focus but the view focus will remain unchanged.
         *
         * @param hasWindowFocus True if the window containing this view now has
         *        focus, false otherwise.
         */
        OnWindowFocusChanged(
            [in] Boolean hasWindowFocus);

        /**
         * Returns true if this view is in a window that currently has window focus.
         * Note that this is not the same as the view itself having focus.
         *
         * @return True if this view is in a window that currently has window focus.
         */
        HasWindowFocus(
            [out] Boolean* focus);

        /**
         * Dispatch a hint about whether this view is displayed. For instance, when
         * a View moves out of the screen, it might receives a display hint indicating
         * the view is not displayed. Applications should not <em>rely</em> on this hint
         * as there is no guarantee that they will receive one.
         *
         * @param hint A hint about whether or not this view is displayed:
         * {@link #VISIBLE} or {@link #INVISIBLE}.
         */
        DispatchDisplayHint(
            [in] Int32 hint);

        /**
         * Dispatch a window visibility change down the view hierarchy.
         * ViewGroups should override to route to their children.
         *
         * @param visibility The new visibility of the window.
         *
         * @see #onWindowVisibilityChanged
         */
        DispatchWindowVisibilityChanged(
            [in] Int32 visibility);

        /**
         * Returns the current visibility of the window this view is attached to
         * (either {@link #GONE}, {@link #INVISIBLE}, or {@link #VISIBLE}).
         *
         * @return Returns the current visibility of the view's window.
         */
        GetWindowVisibility(
            [out] Int32* visibility);

        /**
         * Retrieve the overall visible display size in which the window this view is
         * attached to has been positioned in.  This takes into account screen
         * decorations above the window, for both cases where the window itself
         * is being position inside of them or the window is being placed under
         * then and covered insets are used for the window to position its content
         * inside.  In effect, this tells you the available area where content can
         * be placed and remain visible to users.
         *
         * <p>This function requires an IPC back to the window manager to retrieve
         * the requested information, so should not be used in performance critical
         * code like drawing.
         *
         * @param outRect Filled in with the visible display frame.  If the view
         * is not attached to a window, this is simply the raw display size.
         */
        GetWindowVisibleDisplayFrame(
            [in/*, out*/] IRect* outRect);

        /**
         * Dispatch a notification about a resource configuration change down
         * the view hierarchy.
         * ViewGroups should override to route to their children.
         *
         * @param newConfig The new resource configuration.
         *
         * @see #onConfigurationChanged
         */
        DispatchConfigurationChanged(
            [in] IConfiguration* newConfig);

        /**
         * Returns whether the device is currently in touch mode.  Touch mode is entered
         * once the user begins interacting with the device by touch, and affects various
         * things like whether focus is always visible to the user.
         *
         * @return Whether the device is in touch mode.
         */
        IsInTouchMode(
            [out] Boolean* result);

        /**
         * Returns the context the view is running in, through which it can
         * access the current theme, resources, etc.
         *
         * @return The view's Context.
         */
        GetContext(
            [out] IContext** ctx);

        /**
         * Handle a key event before it is processed by any input method
         * associated with the view hierarchy.  This can be used to intercept
         * key events in special situations before the IME consumes them; a
         * typical example would be handling the BACK key to update the application's
         * UI instead of allowing the IME to see it and close itself.
         *
         * @param keyCode The value in event.getKeyCode().
         * @param event Description of the key event.
         * @return If you handled the event, return true. If you want to allow the
         *         event to be handled by the next receiver, return false.
         */
        OnKeyPreIme(
            [in] Int32 keyCode,
            [in] IKeyEvent* event,
            [out] Boolean* result);

        /**
         * Called when an unhandled key shortcut event occurs.
         *
         * @param keyCode The value in event.getKeyCode().
         * @param event Description of the key event.
         * @return If you handled the event, return true. If you want to allow the
         *         event to be handled by the next receiver, return false.
         */
        OnKeyShortcut(
            [in] Int32 keyCode,
            [in] IKeyEvent* event,
            [out] Boolean* result);

        /**
         * Check whether the called view is a text editor, in which case it
         * would make sense to automatically display a soft input window for
         * it.  Subclasses should override this if they implement
         * {@link #onCreateInputConnection(EditorInfo)} to return true if
         * a call on that method would return a non-NULL InputConnection, and
         * they are really a first-class editor that the user would normally
         * start typing on when the go into a window containing your view.
         *
         * <p>The default implementation always returns false.  This does
         * <em>not</em> mean that its {@link #onCreateInputConnection(EditorInfo)}
         * will not be called or the user can not otherwise perform edits on your
         * view; it is just a hint to the system that this is not the primary
         * purpose of this view.
         *
         * @return Returns true if this view is a text editor, else false.
         */
        OnCheckIsTextEditor(
            [out] Boolean* result);

        /**
         * Create a new InputConnection for an InputMethod to interact
         * with the view.  The default implementation returns null, since it doesn't
         * support input methods.  You can override this to implement such support.
         * This is only needed for views that take focus and text input.
         *
         * <p>When implementing this, you probably also want to implement
         * {@link #onCheckIsTextEditor()} to indicate you will return a
         * non-null InputConnection.
         *
         * @param outAttrs Fill in with attribute information about the connection.
         */
        OnCreateInputConnection(
            [in] IEditorInfo* outAttrs,
            [out] IInputConnection** inputConnection);

        /**
         * Called by the {@link android.view.inputmethod.InputMethodManager}
         * when a view who is not the current
         * input connection target is trying to make a call on the manager.  The
         * default implementation returns false; you can override this to return
         * true for certain views if you are performing InputConnection proxying
         * to them.
         * @param view The View that is making the InputMethodManager call.
         * @return Return true to allow the call, false to reject.
         */
        CheckInputConnectionProxy(
            [in] IView* view,
            [out] Boolean* result);

        /**
         * Show the context menu for this view. It is not safe to hold on to the
         * menu after returning from this method.
         *
         * You should normally not overload this method. Overload
         * {@link #onCreateContextMenu(ContextMenu)} or define an
         * {@link OnCreateContextMenuListener} to add items to the context menu.
         *
         * @param menu The context menu to populate
         */
        CreateContextMenu(
            [in] IContextMenu* menu);

        /**
         * Implement this method to handle trackball motion events.  The
         * <em>relative</em> movement of the trackball since the last event
         * can be retrieve with {@link MotionEvent#getX MotionEvent.getX()} and
         * {@link MotionEvent#getY MotionEvent.getY()}.  These are normalized so
         * that a movement of 1 corresponds to the user pressing one DPAD key (so
         * they will often be fractional values, representing the more fine-grained
         * movement information available from a trackball).
         *
         * @param event The motion event.
         * @return True if the event was handled, false otherwise.
         */
        OnTrackballEvent(
            [in] IMotionEvent* event,
            [out] Boolean* result);

        /**
         * Implement this method to handle touch screen motion events.
         *
         * @param event The motion event.
         * @return True if the event was handled, false otherwise.
         */
        OnTouchEvent(
            [in] IMotionEvent* event,
            [out] Boolean* result);

        /**
         * Sets the TouchDelegate for this View.
         */
        SetTouchDelegate(
            [in] ITouchDelegate* touchDelegate);

        /**
         * Gets the TouchDelegate for this View.
         */
        GetTouchDelegate(
            [out] ITouchDelegate** touchDelegate);

        /**
         * Cancels a pending long press.  Your subclass can use this if you
         * want the context menu to come up if the user presses and holds
         * at the same place, but you don't want it to come up if they press
         * and then move around enough to cause scrolling.
         */
        CancelLongPress();

        /**
         * Change the view's z order in the tree, so it's on top of other sibling
         * views
         */
        BringToFront();

        /**
         * Gets the parent of this view. Note that the parent is a
         * ViewParent and not necessarily a View.
         *
         * @return Parent of this view.
         */
        GetParent(
            [out] IViewParent** parent);

        /**
         * Return the scrolled left position of this view. This is the left edge of
         * the displayed part of your view. You do not need to draw any pixels
         * farther left, since those are outside of the frame of your view on
         * screen.
         *
         * @return The left edge of the displayed part of your view, in pixels.
         */
        GetScrollX(
            [out] Int32* x);

        /**
         * Return the scrolled top position of this view. This is the top edge of
         * the displayed part of your view. You do not need to draw any pixels above
         * it, since those are outside of the frame of your view on screen.
         *
         * @return The top edge of the displayed part of your view, in pixels.
         */
        GetScrollY(
            [out] Int32* y);

        /**
         * Return the width of the your view.
         *
         * @return The width of your view, in pixels.
         */
        GetWidth(
            [out] Int32* width);

        /**
         * Return the height of your view.
         *
         * @return The height of your view, in pixels.
         */
        GetHeight(
            [out] Int32* height);

        /**
         * Return the visible drawing bounds of your view. Fills in the output
         * rectangle with the values from getScrollX(), getScrollY(),
         * getWidth(), and getHeight().
         *
         * @param outRect The (scrolled) drawing bounds of the view.
         */
        GetDrawingRect(
            [in] IRect* outRect);

        /**
         * The width of this view as measured in the most recent call to measure().
         * This should be used during measurement and layout calculations only. Use
         * {@link #getWidth()} to see how wide a view is after layout.
         *
         * @return The measured width of this view.
         */
        GetMeasuredWidth(
            [out] Int32* width);

        /**
         * The height of this view as measured in the most recent call to measure().
         * This should be used during measurement and layout calculations only. Use
         * {@link #getHeight()} to see how tall a view is after layout.
         *
         * @return The measured height of this view.
         */
        GetMeasuredHeight(
            [out] Int32* height);

        /**
         * Top position of this view relative to its parent.
         *
         * @return The top of this view, in pixels.
         */
        GetTop(
            [out] Int32* top);

        /**
         * Bottom position of this view relative to its parent.
         *
         * @return The bottom of this view, in pixels.
         */
        GetBottom(
            [out] Int32* bottom);

        /**
         * Left position of this view relative to its parent.
         *
         * @return The left edge of this view, in pixels.
         */
        GetLeft(
            [out] Int32* left);

        /**
         * Right position of this view relative to its parent.
         *
         * @return The right edge of this view, in pixels.
         */
        GetRight(
            [out] Int32* right);

        /**
         * Hit rectangle in parent's coordinates
         *
         * @param outRect The hit rectangle of the view.
         */
        GetHitRect(
            [in/*, out*/] IRect* outRect);

        /**
         * When a view has focus and the user navigates away from it, the next view is searched for
         * starting from the rectangle filled in by this method.
         *
         * By default, the rectange is the {@link #getDrawingRect})of the view.  However, if your
         * view maintains some idea of internal selection, such as a cursor, or a selected row
         * or column, you should override this method and fill in a more specific rectangle.
         *
         * @param r The rectangle to fill in, in this view's coordinates.
         */
        GetFocusedRect(
            [in/*, out*/] IRect* outRect);

        /**
         * If some part of this view is not clipped by any of its parents, then
         * return that area in r in global (root) coordinates. To convert r to local
         * coordinates, offset it by -globalOffset (e.g. r.offset(-globalOffset.x,
         * -globalOffset.y)) If the view is completely clipped or translated out,
         * return false.
         *
         * @param r If true is returned, r holds the global coordinates of the
         *        visible portion of this view.
         * @param globalOffset If true is returned, globalOffset holds the dx,dy
         *        between this view and its root. globalOffet may be NULL.
         * @return true if r is non-empty (i.e. part of the view is visible at the
         *         root level.
         */
        GetGlobalVisibleRect(
            [in/*, out*/] IRect* outRect,
            [in/*, out*/] IPoint* outGlobalOffset,
            [out] Boolean* result);

        GetGlobalVisibleRectEx(
            [in/*, out*/] IRect* outRect,
            [out] Boolean* result);

        GetLocalVisibleRect(
            [in/*, out*/] IRect* outRect,
            [out] Boolean* result);

        /**
         * Offset this view's vertical location by the specified number of pixels.
         *
         * @param offset the number of pixels to offset the view by
         */
        OffsetTopAndBottom(
            [in] Int32 offset);

        /**
         * Offset this view's horizontal location by the specified amount of pixels.
         *
         * @param offset the numer of pixels to offset the view by
         */
        OffsetLeftAndRight(
            [in] Int32 offset);

        /**
         * Get the LayoutParams associated with this view. All views should have
         * layout parameters. These supply parameters to the <i>parent</i> of this
         * view specifying how it should be arranged. There are many subclasses of
         * ViewGroup.LayoutParams, and these correspond to the different subclasses
         * of ViewGroup that are responsible for arranging their children.
         * @return The LayoutParams associated with this view
         */
        GetLayoutParams(
            [out] IViewGroupLayoutParams** params);

        /**
         * Set the layout parameters associated with this view. These supply
         * parameters to the <i>parent</i> of this view specifying how it should be
         * arranged. There are many subclasses of ViewGroup.LayoutParams, and these
         * correspond to the different subclasses of ViewGroup that are responsible
         * for arranging their children.
         *
         * @param params the layout parameters for this view
         */
        SetLayoutParams(
            [in] IViewGroupLayoutParams* params);

        /**
         * Set the scrolled position of your view. This will cause a call to
         * {@link #onScrollChanged(int, int, int, int)} and the view will be
         * invalidated.
         * @param x the x position to scroll to
         * @param y the y position to scroll to
         */
        ScrollTo(
            [in] Int32 x,
            [in] Int32 y);

        /**
         * Move the scrolled position of your view. This will cause a call to
         * {@link #onScrollChanged(int, int, int, int)} and the view will be
         * invalidated.
         * @param x the amount of pixels to scroll by horizontally
         * @param y the amount of pixels to scroll by vertically
         */
        ScrollBy(
            [in] Int32 x,
            [in] Int32 y);

        /**
         * Mark the the area defined by dirty as needing to be drawn. If the view is
         * visible, {@link #onDraw} will be called at some point in the future.
         * This must be called from a UI thread. To call from a non-UI thread, call
         * {@link #postInvalidate()}.
         *
         * WARNING: This method is destructive to dirty.
         * @param dirty the rectangle representing the bounds of the dirty region
         */
        Invalidate(
            [in] IRect* dirty);

        /**
         * Mark the the area defined by the rect (l,t,r,b) as needing to be drawn.
         * The coordinates of the dirty rect are relative to the view.
         * If the view is visible, {@link #onDraw} will be called at some point
         * in the future. This must be called from a UI thread. To call
         * from a non-UI thread, call {@link #postInvalidate()}.
         * @param l the left position of the dirty region
         * @param t the top position of the dirty region
         * @param r the right position of the dirty region
         * @param b the bottom position of the dirty region
         */
        InvalidateEx(
            [in] Int32 left,
            [in] Int32 top,
            [in] Int32 right,
            [in] Int32 bottom);

        /**
         * Invalidate the whole view. If the view is visible, {@link #onDraw} will
         * be called at some point in the future. This must be called from a
         * UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
         */
        InvalidateEx2();

        /**
         * Indicates whether this View is opaque. An opaque View guarantees that it will
         * draw all the pixels overlapping its bounds using a fully opaque color.
         *
         * Subclasses of View should override this method whenever possible to indicate
         * whether an instance is opaque. Opaque Views are treated in a special way by
         * the View hierarchy, possibly allowing it to perform optimizations during
         * invalidate/draw passes.
         *
         * @return True if this View is guaranteed to be fully opaque, false otherwise.
         */
        IsOpaque(
            [out] Boolean* opaque);

        /**
         * @return A handler associated with the thread running the View. This
         * handler can be used to pump events in the UI events queue.
         */
        GetHandler(
            [out] IApartment** apartment);

        /**
         * Cause an invalidate to happen on a subsequent cycle through the event loop.
         * Use this to invalidate the View from a non-UI thread.
         *
         * @see #invalidate()
         */
        PostInvalidate();

        /**
         * Cause an invalidate of the specified area to happen on a subsequent cycle
         * through the event loop. Use this to invalidate the View from a non-UI thread.
         *
         * @param left The left coordinate of the rectangle to invalidate.
         * @param top The top coordinate of the rectangle to invalidate.
         * @param right The right coordinate of the rectangle to invalidate.
         * @param bottom The bottom coordinate of the rectangle to invalidate.
         *
         * @see #invalidate(int, int, int, int)
         * @see #invalidate(Rect)
         */
        PostInvalidateEx(
            [in] Int32 left,
            [in] Int32 top,
            [in] Int32 right,
            [in] Int32 bottom);

        /**
         * Cause an invalidate to happen on a subsequent cycle through the event
         * loop. Waits for the specified amount of time.
         *
         * @param delayMilliseconds the duration in milliseconds to delay the
         *         invalidation by
         */
        PostInvalidateDelayed(
            [in] Int64 delayMilliseconds);

        /**
         * Cause an invalidate of the specified area to happen on a subsequent cycle
         * through the event loop. Waits for the specified amount of time.
         *
         * @param delayMilliseconds the duration in milliseconds to delay the
         *         invalidation by
         * @param left The left coordinate of the rectangle to invalidate.
         * @param top The top coordinate of the rectangle to invalidate.
         * @param right The right coordinate of the rectangle to invalidate.
         * @param bottom The bottom coordinate of the rectangle to invalidate.
         */
        PostInvalidateDelayedEx(
            [in] Int64 delayMilliseconds,
            [in] Int32 left,
            [in] Int32 top,
            [in] Int32 right,
            [in] Int32 bottom);

        /**
         * Called by a parent to request that a child update its values for mScrollX
         * and mScrollY if necessary. This will typically be done if the child is
         * animating a scroll using a {@link android.widget.Scroller Scroller}
         * object.
         */
        ComputeScroll();

        /**
         * <p>Indicate whether the horizontal edges are faded when the view is
         * scrolled horizontally.</p>
         *
         * @return true if the horizontal edges should are faded on scroll, false
         *         otherwise
         *
         * @see #setHorizontalFadingEdgeEnabled(boolean)
         * @attr ref android.R.styleable#View_fadingEdge
         */
        IsHorizontalFadingEdgeEnabled(
            [out] Boolean* horizontalFadingEdgeEnabled);

        /**
         * <p>Define whether the horizontal edges should be faded when this view
         * is scrolled horizontally.</p>
         *
         * @param horizontalFadingEdgeEnabled true if the horizontal edges should
         *                                    be faded when the view is scrolled
         *                                    horizontally
         *
         * @see #isHorizontalFadingEdgeEnabled()
         * @attr ref android.R.styleable#View_fadingEdge
         */
        SetHorizontalFadingEdgeEnabled(
            [in] Boolean horizontalFadingEdgeEnabled);

        /**
         * <p>Indicate whether the vertical edges are faded when the view is
         * scrolled horizontally.</p>
         *
         * @return true if the vertical edges should are faded on scroll, false
         *         otherwise
         *
         * @see #setVerticalFadingEdgeEnabled(boolean)
         * @attr ref android.R.styleable#View_fadingEdge
         */
        IsVerticalFadingEdgeEnabled(
            [out] Boolean* verticalFadingEdgeEnabled);

        /**
         * <p>Define whether the vertical edges should be faded when this view
         * is scrolled vertically.</p>
         *
         * @param verticalFadingEdgeEnabled true if the vertical edges should
         *                                  be faded when the view is scrolled
         *                                  vertically
         *
         * @see #isVerticalFadingEdgeEnabled()
         * @attr ref android.R.styleable#View_fadingEdge
         */
        SetVerticalFadingEdgeEnabled(
            [in] Boolean verticalFadingEdgeEnabled);

        /**
         * <p>Indicate whether the horizontal scrollbar should be drawn or not. The
         * scrollbar is not drawn by default.</p>
         *
         * @return true if the horizontal scrollbar should be painted, false
         *         otherwise
         *
         * @see #setHorizontalScrollBarEnabled(boolean)
         */
        IsHorizontalScrollBarEnabled(
            [out] Boolean* horizontalScrollBarEnabled);

        /**
         * <p>Define whether the horizontal scrollbar should be drawn or not. The
         * scrollbar is not drawn by default.</p>
         *
         * @param horizontalScrollBarEnabled true if the horizontal scrollbar should
         *                                   be painted
         *
         * @see #isHorizontalScrollBarEnabled()
         */
        SetHorizontalScrollBarEnabled(
            [in] Boolean horizontalScrollBarEnabled);

        /**
         * <p>Indicate whether the vertical scrollbar should be drawn or not. The
         * scrollbar is not drawn by default.</p>
         *
         * @return true if the vertical scrollbar should be painted, false
         *         otherwise
         *
         * @see #setVerticalScrollBarEnabled(boolean)
         */
        IsVerticalScrollBarEnabled(
            [out] Boolean* verticalScrollBarEnabled);

        /**
         * <p>Define whether the vertical scrollbar should be drawn or not. The
         * scrollbar is not drawn by default.</p>
         *
         * @param verticalScrollBarEnabled true if the vertical scrollbar should
         *                                 be painted
         *
         * @see #isVerticalScrollBarEnabled()
         */
        SetVerticalScrollBarEnabled(
            [in] Boolean verticalScrollBarEnabled);

        /**
         * Define whether scrollbars will fade when the view is not scrolling.
         *
         * @param fadeScrollbars wheter to enable fading
         *
         */
        SetScrollbarFadingEnabled(
            [in] Boolean fadeScrollbars);

        /**
         *
         * Returns true if scrollbars will fade when this view is not scrolling
         *
         * @return true if scrollbar fading is enabled
         */
        IsScrollbarFadingEnabled(
            [out] Boolean* fadeScrollbars);

        /**
         * <p>Specify the style of the scrollbars. The scrollbars can be overlaid or
         * inset. When inset, they add to the padding of the view. And the scrollbars
         * can be drawn inside the padding area or on the edge of the view. For example,
         * if a view has a background drawable and you want to draw the scrollbars
         * inside the padding specified by the drawable, you can use
         * SCROLLBARS_INSIDE_OVERLAY or SCROLLBARS_INSIDE_INSET. If you want them to
         * appear at the edge of the view, ignoring the padding, then you can use
         * SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.</p>
         * @param style the style of the scrollbars. Should be one of
         * SCROLLBARS_INSIDE_OVERLAY, SCROLLBARS_INSIDE_INSET,
         * SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.
         * @see #SCROLLBARS_INSIDE_OVERLAY
         * @see #SCROLLBARS_INSIDE_INSET
         * @see #SCROLLBARS_OUTSIDE_OVERLAY
         * @see #SCROLLBARS_OUTSIDE_INSET
         */
        SetScrollBarStyle(
            [in] Int32 style);

        /**
         * <p>Returns the current scrollbar style.</p>
         * @return the current scrollbar style
         * @see #SCROLLBARS_INSIDE_OVERLAY
         * @see #SCROLLBARS_INSIDE_INSET
         * @see #SCROLLBARS_OUTSIDE_OVERLAY
         * @see #SCROLLBARS_OUTSIDE_INSET
         */
        GetScrollBarStyle(
            [out] Int32* style);

        /*
         * Caller is responsible for calling requestLayout if necessary.
         * (This allows addViewInLayout to not request a new layout.)
         */
        AssignParent(
            [in] IViewParent* parent);

        /**
         * Retrieve a unique token identifying the window this view is attached to.
         * @return Return the window's token for use in
         * {@link WindowManager.LayoutParams#token WindowManager.LayoutParams.token}.
         */
        GetWindowToken(
            [out] IBinder** token);
        /**
         * Retrieve a unique token identifying the top-level "real" window of
         * the window that this view is attached to.  That is, this is like
         * {@link #getWindowToken}, except if the window this view in is a panel
         * window (attached to another containing window), then the token of
         * the containing window is returned instead.
         *
         * @return Returns the associated window token, either
         * {@link #getWindowToken()} or the containing window's token.
         */
        GetApplicationWindowToken(
            [out] IBinder** token);

        /**
         * Store this view hierarchy's frozen state into the given container.
         *
         * @param container The SparseArray in which to save the view's state.
         *
         * @see #restoreHierarchyState
         * @see #dispatchSaveInstanceState
         * @see #onSaveInstanceState
         */
        SaveHierarchyState(
            [in/*, out*/] IObjectIntegerMap* container);

        /**
         * Restore this view hierarchy's frozen state from the given container.
         *
         * @param container The SparseArray which holds previously frozen states.
         *
         * @see #saveHierarchyState
         * @see #dispatchRestoreInstanceState
         * @see #onRestoreInstanceState
         */
        RestoreHierarchyState(
            [in] IObjectIntegerMap* container);

        /**
         * <p>Return the time at which the drawing of the view hierarchy started.</p>
         *
         * @return the drawing start time in milliseconds
         */
        GetDrawingTime(
            [out] Int64* time);

        /**
         * <p>Enables or disables the duplication of the parent's state into this view. When
         * duplication is enabled, this view gets its drawable state from its parent rather
         * than from its own internal properties.</p>
         *
         * <p>Note: in the current implementation, setting this property to true after the
         * view was added to a ViewGroup might have no effect at all. This property should
         * always be used from XML or set to true before adding this view to a ViewGroup.</p>
         *
         * <p>Note: if this view's parent addStateFromChildren property is enabled and this
         * property is enabled, an exception will be thrown.</p>
         *
         * @param enabled True to enable duplication of the parent's drawable state, false
         *                to disable it.
         *
         * @see #getDrawableState()
         * @see #isDuplicateParentStateEnabled()
         */
        SetDuplicateParentStateEnabled(
            [in] Boolean enabled);

        /**
         * <p>Indicates whether this duplicates its drawable state from its parent.</p>
         *
         * @return True if this view's drawable state is duplicated from the parent,
         *         false otherwise
         *
         * @see #getDrawableState()
         * @see #setDuplicateParentStateEnabled(boolean)
         */
        IsDuplicateParentStateEnabled(
            [out] Boolean* result);

        /**
         * <p>Enables or disables the drawing cache. When the drawing cache is enabled, the next call
         * to {@link #getDrawingCache()} or {@link #buildDrawingCache()} will draw the view in a
         * bitmap. Calling {@link #draw(android.graphics.Canvas)} will not draw from the cache when
         * the cache is enabled. To benefit from the cache, you must request the drawing cache by
         * calling {@link #getDrawingCache()} and draw it on screen if the returned bitmap is not
         * NULL.</p>
         *
         * @param enabled true to enable the drawing cache, false otherwise
         *
         * @see #isDrawingCacheEnabled()
         * @see #getDrawingCache()
         * @see #buildDrawingCache()
         */
        SetDrawingCacheEnabled(
            [in] Boolean enabled);

        /**
         * <p>Indicates whether the drawing cache is enabled for this view.</p>
         *
         * @return true if the drawing cache is enabled
         *
         * @see #setDrawingCacheEnabled(boolean)
         * @see #getDrawingCache()
         */
        IsDrawingCacheEnabled(
            [out] Boolean* enabled);

        /**
         * <p>Calling this method is equivalent to calling <code>getDrawingCache(false)</code>.</p>
         *
         * @return A non-scaled bitmap representing this view or NULL if cache is disabled.
         *
         * @see #getDrawingCache(boolean)
         */
        GetDrawingCache(
            [out] IBitmap** bitmap);

        /**
         * <p>Returns the bitmap in which this view drawing is cached. The returned bitmap
         * is NULL when caching is disabled. If caching is enabled and the cache is not ready,
         * this method will create it. Calling {@link #draw(android.graphics.Canvas)} will not
         * draw from the cache when the cache is enabled. To benefit from the cache, you must
         * request the drawing cache by calling this method and draw it on screen if the
         * returned bitmap is not NULL.</p>
         *
         * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
         * this method will create a bitmap of the same size as this view. Because this bitmap
         * will be drawn scaled by the parent ViewGroup, the result on screen might show
         * scaling artifacts. To avoid such artifacts, you should call this method by setting
         * the auto scaling to true. Doing so, however, will generate a bitmap of a different
         * size than the view. This implies that your application must be able to handle this
         * size.</p>
         *
         * @param autoScale Indicates whether the generated bitmap should be scaled based on
         *        the current density of the screen when the application is in compatibility
         *        mode.
         *
         * @return A bitmap representing this view or NULL if cache is disabled.
         *
         * @see #setDrawingCacheEnabled(boolean)
         * @see #isDrawingCacheEnabled()
         * @see #buildDrawingCache(boolean)
         * @see #destroyDrawingCache()
         */
        GetDrawingCacheEx(
            [in] Boolean autoScale,
            [out] IBitmap** bitmap);

        /**
         * <p>Frees the resources used by the drawing cache. If you call
         * {@link #buildDrawingCache()} manually without calling
         * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
         * should cleanup the cache with this method afterwards.</p>
         *
         * @see #setDrawingCacheEnabled(boolean)
         * @see #buildDrawingCache()
         * @see #getDrawingCache()
         */
        DestroyDrawingCache();

        /**
         * Setting a solid background color for the drawing cache's bitmaps will improve
         * perfromance and memory usage. Note, though that this should only be used if this
         * view will always be drawn on top of a solid color.
         *
         * @param color The background color to use for the drawing cache's bitmap
         *
         * @see #setDrawingCacheEnabled(boolean)
         * @see #buildDrawingCache()
         * @see #getDrawingCache()
         */
        SetDrawingCacheBackgroundColor(
            [in] Int32 color);

        /**
         * @see #setDrawingCacheBackgroundColor(int)
         *
         * @return The background color to used for the drawing cache's bitmap
         */
        GetDrawingCacheBackgroundColor(
            [out] Int32* color);

        /**
         * <p>Calling this method is equivalent to calling <code>buildDrawingCache(false)</code>.</p>
         *
         * @see #buildDrawingCache(boolean)
         */
        BuildDrawingCache();

        /**
         * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
         *
         * <p>If you call {@link #buildDrawingCache()} manually without calling
         * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
         * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
         *
         * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
         * this method will create a bitmap of the same size as this view. Because this bitmap
         * will be drawn scaled by the parent ViewGroup, the result on screen might show
         * scaling artifacts. To avoid such artifacts, you should call this method by setting
         * the auto scaling to true. Doing so, however, will generate a bitmap of a different
         * size than the view. This implies that your application must be able to handle this
         * size.</p>
         *
         * @see #getDrawingCache()
         * @see #destroyDrawingCache()
         */
        BuildDrawingCacheEx(
            [in] Boolean autoScale);

        /**
         * Create a snapshot of the view into a bitmap.  We should probably make
         * some form of this public, but should think about the API.
         */
        CreateSnapshot(
            [in] BitmapConfig quality,
            [in] Int32 backgroundColor,
            [in] Boolean skipChildren,
            [out] IBitmap** bitmap);

        /**
         * Indicates whether this View is currently in edit mode. A View is usually
         * in edit mode when displayed within a developer tool. For instance, if
         * this View is being drawn by a visual user interface builder, this method
         * should return true.
         *
         * Subclasses should check the return value of this method to provide
         * different behaviors if their normal behavior might interfere with the
         * host environment. For instance: the class spawns a thread in its
         * constructor, the drawing code relies on device-specific features, etc.
         *
         * This method is usually checked in the drawing code of custom widgets.
         *
         * @return True if this View is in edit mode, false otherwise.
         */
        IsInEditMode(
            [out] Boolean* result);

        /**
         * Manually render this view (and all of its children) to the given Canvas.
         * The view must have already done a full layout before this function is
         * called.  When implementing a view, do not override this method; instead,
         * you should implement {@link #onDraw}.
         *
         * @param canvas The Canvas to which the View is rendered.
         */
        Draw(
            [in] ICanvas* canvas);

        /**
         * Override this if your view is known to always be drawn on top of a solid color background,
         * and needs to draw fading edges. Returning a non-zero color enables the view system to
         * optimize the drawing of the fading edges. If you do return a non-zero color, the alpha
         * should be set to 0xFF.
         *
         * @see #setVerticalFadingEdgeEnabled
         * @see #setHorizontalFadingEdgeEnabled
         *
         * @return The known solid color background for this view, or 0 if the color may vary
         */
        GetSolidColor(
            [out] Int32* color);

        /**
         * Finalize inflating a view from XML.  This is called as the last phase
         * of inflation, after all child views have been added.
         *
         * <p>Even if the subclass overrides onFinishInflate, they should always be
         * sure to call the super method, so that we get called.
         */
        OnFinishInflate();

        /**
         * <p>Indicates whether or not this view's layout will be requested during
         * the next hierarchy layout pass.</p>
         *
         * @return true if the layout will be forced during next layout pass
         */
        IsLayoutRequested(
            [out] Boolean* result);

        /**
         * Assign a size and position to a view and all of its
         * descendants
         *
         * <p>This is the second phase of the layout mechanism.
         * (The first is measuring). In this phase, each parent calls
         * layout on all of its children to position them.
         * This is typically done using the child measurements
         * that were stored in the measure pass().
         *
         * Derived classes with children should override
         * onLayout. In that method, they should
         * call layout on each of their their children.
         *
         * @param l Left position, relative to parent
         * @param t Top position, relative to parent
         * @param r Right position, relative to parent
         * @param b Bottom position, relative to parent
         */
        Layout(
            [in] Int32 l,
            [in] Int32 t,
            [in] Int32 r,
            [in] Int32 b);

        /**
         * Returns the resources associated with this view.
         *
         * @return Resources object.
         */
        GetResources(
            [out] IResources** resources);

        /**
         * Unschedule any events associated with the given Drawable.  This can be
         * used when selecting a new Drawable into a view, so that the previous
         * one is completely unscheduled.
         *
         * @param who The Drawable to unschedule.
         *
         * @see #drawableStateChanged
         */
        UnscheduleDrawableEx(
            [in] IDrawable* who);

        /**
         * Call this to force a view to update its drawable state. This will cause
         * drawableStateChanged to be called on this view. Views that are interested
         * in the new state should call getDrawableState.
         *
         * @see #drawableStateChanged
         * @see #getDrawableState
         */
        RefreshDrawableState();

        /**
         * Return an array of resource IDs of the drawable states representing the
         * current state of the view.
         *
         * @return The current drawable state
         *
         * @see Drawable#setState
         * @see #drawableStateChanged
         * @see #onCreateDrawableState
         */
        GetDrawableState(
            [out, callee] ArrayOf<Int32>* state);

        /**
         * Sets the background color for this view.
         * @param color the color of the background
         */
        SetBackgroundColor(
            [in] Int32 color);

        /**
         * Set the background to a given resource. The resource should refer to
         * a Drawable object or 0 to remove the background.
         * @param resid The identifier of the resource.
         * @attr ref android.R.styleable#View_background
         */
        SetBackgroundResource(
            [in] Int32 resid);

        /**
         * Set the background to a given Drawable, or remove the background. If the
         * background has padding, this View's padding is set to the background's
         * padding. However, when a background is removed, this View's padding isn't
         * touched. If setting the padding is desired, please use
         * {@link #setPadding(int, int, int, int)}.
         *
         * @param d The Drawable to use as the background, or NULL to remove the
         *        background
         */
        SetBackgroundDrawable(
            [in] IDrawable* d);

        /**
         * Gets the background drawable
         * @return The drawable used as the background for this view, if any.
         */
        GetBackground(
            [out] IDrawable** drawable);

        /**
         * Sets the padding. The view may add on the space required to display
         * the scrollbars, depending on the style and visibility of the scrollbars.
         * So the values returned from {@link #getPaddingLeft}, {@link #getPaddingTop},
         * {@link #getPaddingRight} and {@link #getPaddingBottom} may be different
         * from the values set in this call.
         *
         * @attr ref android.R.styleable#View_padding
         * @attr ref android.R.styleable#View_paddingBottom
         * @attr ref android.R.styleable#View_paddingLeft
         * @attr ref android.R.styleable#View_paddingRight
         * @attr ref android.R.styleable#View_paddingTop
         * @param left the left padding in pixels
         * @param top the top padding in pixels
         * @param right the right padding in pixels
         * @param bottom the bottom padding in pixels
         */
        SetPadding(
            [in] Int32 left,
            [in] Int32 top,
            [in] Int32 right,
            [in] Int32 bottom);

        /**
         * Returns the top padding of this view.
         *
         * @return the top padding in pixels
         */
        GetPaddingTop(
            [out] Int32* top);

        /**
         * Returns the bottom padding of this view. If there are inset and enabled
         * scrollbars, this value may include the space required to display the
         * scrollbars as well.
         *
         * @return the bottom padding in pixels
         */
        GetPaddingBottom(
            [out] Int32* bottom);

        /**
         * Returns the left padding of this view. If there are inset and enabled
         * scrollbars, this value may include the space required to display the
         * scrollbars as well.
         *
         * @return the left padding in pixels
         */
        GetPaddingLeft(
            [out] Int32* left);

        /**
         * Returns the right padding of this view. If there are inset and enabled
         * scrollbars, this value may include the space required to display the
         * scrollbars as well.
         *
         * @return the right padding in pixels
         */
        GetPaddingRight(
            [out] Int32* right);

        /**
         * Changes the selection state of this view. A view can be selected or not.
         * Note that selection is not the same as focus. Views are typically
         * selected in the context of an AdapterView like ListView or GridView;
         * the selected view is the view that is highlighted.
         *
         * @param selected true if the view must be selected, false otherwise
         */
        SetSelected(
            [in] Boolean selected);

        /**
         * Indicates the selection state of this view.
         *
         * @return true if the view is selected, false otherwise
         */
        IsSelected(
            [out] Boolean* selected);

        /**
         * Returns the ViewTreeObserver for this view's hierarchy. The view tree
         * observer can be used to get notifications when global events, like
         * layout, happen.
         *
         * The returned ViewTreeObserver observer is not guaranteed to remain
         * valid for the lifetime of this View. If the caller of this method keeps
         * a long-lived reference to ViewTreeObserver, it should always check for
         * the return value of {@link ViewTreeObserver#isAlive()}.
         *
         * @return The ViewTreeObserver for this view's hierarchy.
         */
        GetViewTreeObserver(
            [out] IViewTreeObserver** observer);

        /**
         * <p>Finds the topmost view in the current view hierarchy.</p>
         *
         * @return the topmost view containing this view
         */
        GetRootView(
            [out] IView** view);

        /**
         * <p>Computes the coordinates of this view on the screen. The argument
         * must be an array of two integers. After the method returns, the array
         * contains the x and y location in that order.</p>
         *
         * @param location an array of two integers in which to hold the coordinates
         */
        GetLocationOnScreen(
            [out] Int32* x,
            [out] Int32* y);

        /**
         * <p>Computes the coordinates of this view in its window. The argument
         * must be an array of two integers. After the method returns, the array
         * contains the x and y location in that order.</p>
         *
         * @param location an array of two integers in which to hold the coordinates
         */
        GetLocationInWindow(
            [out] Int32* x,
            [out] Int32* y);

        /**
         * Look for a child view with the given id.  If this view has the given
         * id, return this view.
         *
         * @param id The id to search for.
         * @return The view that has the given id in the hierarchy or null
         */
        FindViewById(
            [in] Int32 id,
            [out] IView** view);

        /**
         * Sets the identifier for this view. The identifier does not have to be
         * unique in this view's hierarchy. The identifier should be a positive
         * number.
         *
         * @see #NO_ID
         * @see #getId
         * @see #findViewById
         *
         * @param id a number used to identify the view
         *
         * @attr ref android.R.styleable#View_id
         */
        SetId(
            [in] Int32 id);

        /**
         * Returns this view's identifier.
         *
         * @return a positive integer used to identify the view or {@link #NO_ID}
         *         if the view has no ID
         *
         * @see #setId
         * @see #findViewById
         * @attr ref android.R.styleable#View_id
         */
        GetId(
            [out] Int32* id);

        /**
         * {@hide}
         *
         * @return true if the view belongs to the root namespace, false otherwise
         */
        IsRootNamespace(
            [out] Boolean* result);

        /**
         * <p>Return the offset of the widget's text baseline from the widget's top
         * boundary. If this widget does not support baseline alignment, this
         * method returns -1. </p>
         *
         * @return the offset of the baseline within the widget's bounds or -1
         *         if baseline alignment is not supported
         */
        GetBaseline(
            [out] Int32* result);

        /**
         * Call this when something has changed which has invalidated the
         * layout of this view. This will schedule a layout pass of the view
         * tree.
         */
        RequestLayout();

        /**
         * Forces this view to be laid out during the next layout pass.
         * This method does not call requestLayout() or forceLayout()
         * on the parent.
         */
        ForceLayout();

        /**
         * <p>
         * This is called to find out how big a view should be. The parent
         * supplies constraint information in the width and height parameters.
         * </p>
         *
         * <p>
         * The actual mesurement work of a view is performed in
         * {@link #onMeasure(int, int)}, called by this method. Therefore, only
         * {@link #onMeasure(int, int)} can and must be overriden by subclasses.
         * </p>
         *
         *
         * @param widthMeasureSpec Horizontal space requirements as imposed by the
         *        parent
         * @param heightMeasureSpec Vertical space requirements as imposed by the
         *        parent
         *
         * @see #onMeasure(int, int)
         */
        Measure(
            [in] Int32 widthMeasureSpec,
            [in] Int32 heightMeasureSpec);

        /**
         * Sets the minimum height of the view. It is not guaranteed the view will
         * be able to achieve this minimum height (for example, if its parent layout
         * constrains it with less available height).
         *
         * @param minHeight The minimum height the view will try to be.
         */
        SetMinimumHeight(
            [in] Int32 minHeight);

        /**
         * Sets the minimum width of the view. It is not guaranteed the view will
         * be able to achieve this minimum width (for example, if its parent layout
         * constrains it with less available width).
         *
         * @param minWidth The minimum width the view will try to be.
         */
        SetMinimumWidth(
            [in] Int32 minWidth);

        /**
         * Get the animation currently associated with this view.
         *
         * @return The animation that is currently playing or
         *         scheduled to play for this view.
         */
        GetAnimation(
            [out] IAnimation** animation);

        /**
         * Start the specified animation now.
         *
         * @param animation the animation to start now
         */
        StartAnimation(
            [in] IAnimation* animation);

        /**
         * Cancels any animations for this view.
         */
        ClearAnimation();

        /**
         * Sets the next animation to play for this view.
         * If you want the animation to play immediately, use
         * startAnimation. This method provides allows fine-grained
         * control over the start time and invalidation, but you
         * must make sure that 1) the animation has a start time set, and
         * 2) the view will be invalidated when the animation is supposed to
         * start.
         *
         * @param animation The next animation, or null.
         */
        SetAnimation(
            [in] IAnimation* animation);

        /**
         * This is used by the RootView to perform an optimization when
         * the view hierarchy contains one or several SurfaceView.
         * SurfaceView is always considered transparent, but its children are not,
         * therefore all View objects remove themselves from the global transparent
         * region (passed as a parameter to this function).
         *
         * @param region The transparent region for this ViewRoot (window).
         *
         * @return Returns true if the effective visibility of the view at this
         * point is opaque, regardless of the transparent region; returns false
         * if it is possible for underlying windows to be seen behind the view.
         *
         * {@hide}
         */
        GatherTransparentRegion(
            [in] IRegion* region,
            [out] Boolean* result);

        /**
         * Play a sound effect for this view.
         *
         * <p>The framework will play sound effects for some built in actions, such as
         * clicking, but you may wish to play these effects in your widget,
         * for instance, for internal navigation.
         *
         * <p>The sound effect will only be played if sound effects are enabled by the user, and
         * {@link #isSoundEffectsEnabled()} is true.
         *
         * @param soundConstant One of the constants defined in {@link SoundEffectConstants}
         */
        PlaySoundEffect(
            [in] Int32 soundConstant);

        /**
         * BZZZTT!!1!
         *
         * <p>Provide haptic feedback to the user for this view.
         *
         * <p>The framework will provide haptic feedback for some built in actions,
         * such as long presses, but you may wish to provide feedback for your
         * own widget.
         *
         * <p>The feedback will only be performed if
         * {@link #isHapticFeedbackEnabled()} is true.
         *
         * @param feedbackConstant One of the constants defined in
         * {@link HapticFeedbackConstants}
         */
        PerformHapticFeedback(
            [in] Int32 feedbackConstant,
            [out] Boolean* result);

        /**
         * BZZZTT!!1!
         *
         * <p>Like {@link #performHapticFeedback(int)}, with additional options.
         *
         * @param feedbackConstant One of the constants defined in
         * {@link HapticFeedbackConstants}
         * @param flags Additional flags as per {@link HapticFeedbackConstants}.
         */
        PerformHapticFeedbackEx(
            [in] Int32 feedbackConstant,
            [in] Int32 flags,
            [out] Boolean* result);

        /**
         * This needs to be a better API (NOT ON VIEW) before it is exposed.  If
         * it is ever exposed at all.
         * @hide
         */
        OnCloseSystemDialogs(
            [in] String reason);

        /**
         * Given a Drawable whose bounds have been set to draw into this view,
         * update a Region being computed for {@link #gatherTransparentRegion} so
         * that any non-transparent parts of the Drawable are removed from the
         * given transparent region.
         *
         * @param dr The Drawable whose transparency is to be applied to the region.
         * @param region A Region holding the current transparency information,
         * where any parts of the region that are set are considered to be
         * transparent.  On return, this region will be modified to have the
         * transparency information reduced by the corresponding parts of the
         * Drawable that are not transparent.
         * {@hide}
         */
        ApplyDrawableToTransparentRegion(
            [in] IDrawable* dr,
            [in] IRegion* region);

        /**
         * Returns the over-scroll mode for this view. The result will be
         * one of {@link #OVER_SCROLL_ALWAYS} (default), {@link #OVER_SCROLL_IF_CONTENT_SCROLLS}
         * (allow over-scrolling only if the view content is larger than the container),
         * or {@link #OVER_SCROLL_NEVER}.
         *
         * @return This view's over-scroll mode.
         */
        GetOverScrollMode(
            [out] Int32* mode);

        /**
         * Set the over-scroll mode for this view. Valid over-scroll modes are
         * {@link #OVER_SCROLL_ALWAYS} (default), {@link #OVER_SCROLL_IF_CONTENT_SCROLLS}
         * (allow over-scrolling only if the view content is larger than the container),
         * or {@link #OVER_SCROLL_NEVER}.
         *
         * Setting the over-scroll mode of a view will have an effect only if the
         * view is capable of scrolling.
         *
         * @param overScrollMode The new over-scroll mode for this view.
         */
        SetOverScrollMode(
            [in] Int32 overScrollMode);

        SetTag(
            [in] IInterface* tag);

        GetTag(
            [out] IInterface** tag);
    }
}

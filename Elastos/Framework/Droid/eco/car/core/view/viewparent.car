
module
{
    interface IView;
    interface IRect;
    interface IPoint;

    [deprecated]
    interface IViewParent {
        /**
         * Called when something has changed which has invalidated the layout of a
         * child of this view parent. This will schedule a layout pass of the view
         * tree.
         */
        //IView has RequestLayout method
        RequestLayoutEx();

        /**
         * Indicates whether layout was requested on this view parent.
         *
         * @param result true if layout was requested, false otherwise
         */
        //IView has IsLayoutRequested method
        IsLayoutRequestedEx(
            [out] Boolean* result);

        /**
         * Called when a child wants the view hierarchy to gather and report
         * transparent regions to the window compositor. Views that "punch" holes in
         * the view hierarchy, such as SurfaceView can use this API to improve
         * performance of the system. When no such a view is present in the
         * hierarchy, this optimization in unnecessary and might slightly reduce the
         * view hierarchy performance.
         *
         * @param child the view requesting the transparent region computation
         *
         */
        RequestTransparentRegion(
            [in] IView* child);

        /**
         * All or part of a child is dirty and needs to be redrawn.
         *
         * @param child The child which is dirty
         * @param r The area within the child that is invalid
         */
        InvalidateChild(
            [in] IView* child,
            [in] IRect* r);

        /**
         * All or part of a child is dirty and needs to be redrawn.
         *
         * The location array is an array of two int values which respectively
         * define the left and the top position of the dirty child.
         *
         * This method must return the parent of this ViewParent if the specified
         * rectangle must be invalidated in the parent. If the specified rectangle
         * does not require invalidation in the parent or if the parent does not
         * exist, this method must return null.
         *
         * When this method returns a non-null value, the location array must
         * have been updated with the left and top coordinates of this ViewParent.
         *
         * @param location An array of 2 ints containing the left and top
         *        coordinates of the child to invalidate
         *
         * @param r The area within the child that is invalid
         *
         * @param parent the parent of this ViewParent or null
         */
        InvalidateChildInParent(
            [in] ArrayOf<Int32>* location,
            [in] IRect* r,
            [out] IViewParent** parent);

        /**
         * Returns the parent if it exists, or null.
         *
         * @param parent a ViewParent or null if this ViewParent does not have a parent
         */
        //IView has GetParent method
        GetParentEx(
            [out] IViewParent** parent);

        /**
         * Called when a child of this parent wants focus
         *
         * @param child The child of this ViewParent that wants focus. This view
         *        will contain the focused view. It is not necessarily the view that
         *        actually has focus.
         * @param focused The view that is a descendant of child that actually has
         *        focus
         */
        RequestChildFocus(
            [in] IView* child,
            [in] IView* focused);

        /**
         * Tell view hierarchy that the global view attributes need to be
         * re-evaluated.
         *
         * @param child View whose attributes have changed.
         */
        RecomputeViewAttributes(
            [in] IView* child);

        /**
         * Called when a child of this parent is giving up focus
         *
         * @param child The view that is giving up focus
         */
        ClearChildFocus(
            [in] IView* child);

        GetChildVisibleRect(
            [in] IView* child,
            [in] IRect* r,
            [in] IPoint* offset,
            [out] Boolean* result);

        /**
         * Find the nearest view in the specified direction that wants to take focus
         *
         * @param v The view that currently has focus
         * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
         */
        //IView has FocusSearch method;
        FocusSearchEx(
            [in] IView* focused,
            [in] Int32 direction,
            [out] IView** focus);

        /**
         * Change the z order of the child so it's on top of all other children
         *
         * @param child
         */
        BringChildToFront(
            [in] IView* child);

        /**
         * Tells the parent that a new focusable view has become available. This is
         * to handle transitions from the case where there are no focusable views to
         * the case where the first focusable view appears.
         *
         * @param v The view that has become newly focusable
         */
        FocusableViewAvailable(
            [in] IView* v);

        /**
         * Bring up a context menu for the specified view or its ancestors.
         * <p>
         * In most cases, a subclass does not need to override this.  However, if
         * the subclass is added directly to the window manager (for example,
         * {@link ViewManager#addView(View, android.view.ViewGroup.LayoutParams)})
         * then it should override this and show the context menu.
         *
         * @param originalView The source view where the context menu was first invoked
         * @param result true if a context menu was displayed
         */
        ShowContextMenuForChild(
            [in] IView* originalView,
            [out] Boolean* result);

        /**
         * Have the parent populate the specified context menu if it has anything to
         * add (and then recurse on its parent).
         *
         * @param menu The menu to populate
         */
        CreateContextMenuEx(
            [in] IContextMenu* menu);

        /**
         * This method is called on the parent when a child's drawable state
         * has changed.
         *
         * @param child The child whose drawable state has changed.
         */
        ChildDrawableStateChanged(
            [in] IView* child);

        /**
         * Called when a child does not want this parent and its ancestors to
         * intercept touch events with
         * {@link ViewGroup#onInterceptTouchEvent(MotionEvent)}.
         * <p>
         * This parent should pass this call onto its parents. This parent must obey
         * this request for the duration of the touch (that is, only clear the flag
         * after this parent has received an up or a cancel.
         *
         * @param disallowIntercept True if the child does not want the parent to
         *            intercept touch events.
         */
        RequestDisallowInterceptTouchEvent(
            [in] Boolean disallowIntercept);

        /**
         * Called when a child of this group wants a particular rectangle to be
         * positioned onto the screen.  {@link ViewGroup}s overriding this can trust
         * that:
         * <ul>
         *   <li>child will be a direct child of this group</li>
         *   <li>rectangle will be in the child's coordinates</li>
         * </ul>
         *
         * <p>{@link ViewGroup}s overriding this should uphold the contract:</p>
         * <ul>
         *   <li>nothing will change if the rectangle is already visible</li>
         *   <li>the view port will be scrolled only just enough to make the
         *       rectangle visible</li>
         * <ul>
         *
         * @param child The direct child making the request.
         * @param rectangle The rectangle in the child's coordinates the child
         *        wishes to be on the screen.
         * @param immediate True to forbid animated or delayed scrolling,
         *        false otherwise
         * @param result Whether the group scrolled to handle the operation
         */
        RequestChildRectangleOnScreen(
            [in] IView* child,
            [in] IRect* rectangle,
            [in] Boolean immediate,
            [out] Boolean* result);
    }
}

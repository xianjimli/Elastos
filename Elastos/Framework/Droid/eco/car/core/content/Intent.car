
module
{
    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Standard intent broadcast actions (see action variable).

    /**
     *  Activity Action: Start as a main entry point, does not expect to
     *  receive data.
     *  <p>Input: nothing
     *  <p>Output: nothing
     */
    const Intent_ACTION_MAIN = "elastos.intent.action.MAIN";

    /**
     * Activity Action: Display the data to the user.  This is the most common
     * action performed on data -- it is the generic action you can use on
     * a piece of data to get the most reasonable thing to occur.  For example,
     * when used on a contacts entry it will view the entry; when used on a
     * mailto: URI it will bring up a compose window filled with the information
     * supplied by the URI; when used with a tel: URI it will invoke the
     * dialer.
     * <p>Input: {@link #getData} is URI from which to retrieve data.
     * <p>Output: nothing.
     */
    const Intent_ACTION_VIEW = "elastos.intent.action.VIEW";

    /**
     * Broadcast Action: Sent after the screen turns off.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_SCREEN_OFF = "elastos.intent.action.SCREEN_OFF";

    /**
     * Broadcast Action: Sent after the screen turns on.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_SCREEN_ON = "elastos.intent.action.SCREEN_ON";

    /**
     * Broadcast Action: Sent when the user is present after device wakes up (e.g when the
     * keyguard is gone).
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_USER_PRESENT = "elastos.intent.action.USER_PRESENT";

    /**
     * Broadcast Action: The current time has changed.  Sent every
     * minute.  You can <em>not</em> receive this through components declared
     * in manifests, only by exlicitly registering for it with
     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
     * Context.registerReceiver()}.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_TIME_TICK = "elastos.intent.action.TIME_TICK";

    /**
     * Broadcast Action: The time was set.
     */
    const Intent_ACTION_TIME_CHANGED = "elastos.intent.action.TIME_SET";

    /**
     * Broadcast Action: The date has changed.
     */
    const Intent_ACTION_DATE_CHANGED = "elastos.intent.action.DATE_CHANGED";

    /**
     * Broadcast Action: The timezone has changed. The intent will have the following extra values:</p>
     * <ul>
     *   <li><em>time-zone</em> - The java.util.TimeZone.getID() value identifying the new time zone.</li>
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_TIMEZONE_CHANGED = "elastos.intent.action.TIMEZONE_CHANGED";

    /**
     * Alarm Changed Action: This is broadcast when the AlarmClock
     * application's alarm is set or unset.  It is used by the
     * AlarmClock application and the StatusBar service.
     * @hide
     */
    const Intent_ACTION_ALARM_CHANGED = "elastos.intent.action.ALARM_CHANGED";

    /**
     * Sync State Changed Action: This is broadcast when the sync starts or stops or when one has
     * been failing for a long time.  It is used by the SyncManager and the StatusBar service.
     * @hide
     */
    const Intent_ACTION_SYNC_STATE_CHANGED = "elastos.intent.action.SYNC_STATE_CHANGED";

    /**
     * Broadcast Action: This is broadcast once, after the system has finished
     * booting.  It can be used to perform application-specific initialization,
     * such as installing alarms.  You must hold the
     * {@link elastos.Manifest.permission#RECEIVE_BOOT_COMPLETED} permission
     * in order to receive this broadcast.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BOOT_COMPLETED = "elastos.intent.action.BOOT_COMPLETED";

    /**
     * Broadcast Action: This is broadcast when a user action should request a
     * temporary system dialog to dismiss.  Some examples of temporary system
     * dialogs are the notification window-shade and the recent tasks dialog.
     */
    const Intent_ACTION_CLOSE_SYSTEM_DIALOGS = "elastos.intent.action.CLOSE_SYSTEM_DIALOGS";

    /**
     * Broadcast Action: Trigger the download and eventual installation
     * of a package.
     * <p>Input: {@link #getData} is the URI of the package file to download.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_INSTALL = "elastos.intent.action.CAPSULE_INSTALL";

    /**
     * Broadcast Action: A new application package has been installed on the
     * device. The data contains the name of the package.  Note that the
     * newly installed package does <em>not</em> receive this broadcast.
     * <p>My include the following extras:
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
     * <li> {@link #EXTRA_REPLACING} is set to true if this is following
     * an {@link #Intent_ACTION_CAPSULE_REMOVED} broadcast for the same package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_ADDED = "elastos.intent.action.CAPSULE_ADDED";

    /**
     * Broadcast Action: A new version of an application package has been
     * installed, replacing an existing version that was previously installed.
     * The data contains the name of the package.
     * <p>My include the following extras:
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_REPLACED = "elastos.intent.action.CAPSULE_REPLACED";

    /**
     * Broadcast Action: An existing application package has been removed from
     * the device.  The data contains the name of the package.  The package
     * that is being installed does <em>not</em> receive this Intent.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
     * to the package.
     * <li> {@link #EXTRA_DATA_REMOVED} is set to true if the entire
     * application -- data and code -- is being removed.
     * <li> {@link #EXTRA_REPLACING} is set to true if this will be followed
     * by an {@link #Intent_ACTION_CAPSULE_ADDED} broadcast for the same package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_REMOVED = "elastos.intent.action.CAPSULE_REMOVED";

    /**
     * Broadcast Action: An existing application package has been changed (e.g.
     * a component has been enabled or disabled).  The data contains the name of
     * the package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * <li> {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST} containing the class name
     * of the changed components.
     * <li> {@link #EXTRA_DONT_KILL_APP} containing boolean field to override the
     * default action of restarting the application.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_CHANGED = "elastos.intent.action.CAPSULE_CHANGED";

    /**
     * @hide
     * Broadcast Action: Ask system services if there is any reason to
     * restart the given package.  The data contains the name of the
     * package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * <li> {@link #EXTRA_CAPSULES} String array of all packages to check.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_QUERY_CAPSULE_RESTART = "elastos.intent.action.QUERY_CAPSULE_RESTART";

    /**
     * Broadcast Action: The user has restarted a package, and all of its
     * processes have been killed.  All runtime state
     * associated with it (processes, alarms, notifications, etc) should
     * be removed.  Note that the restarted package does <em>not</em>
     * receive this broadcast.
     * The data contains the name of the package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_RESTARTED = "elastos.intent.action.CAPSULE_RESTARTED";

    /**
     * Broadcast Action: The user has cleared the data of a package.  This should
     * be preceded by {@link #Intent_ACTION_CAPSULE_RESTARTED}, after which all of
     * its persistent data is erased and this broadcast sent.
     * Note that the cleared package does <em>not</em>
     * receive this broadcast. The data contains the name of the package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_DATA_CLEARED = "elastos.intent.action.CAPSULE_DATA_CLEARED";

    /**
     * Broadcast Action: A user ID has been removed from the system.  The user
     * ID number is stored in the extra data under {@link #EXTRA_UID}.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_UID_REMOVED = "elastos.intent.action.UID_REMOVED";

    /**
     * Broadcast Action: Resources for a set of packages (which were
     * previously unavailable) are currently
     * available since the media on which they exist is available.
     * The extra data {@link #EXTRA_CHANGED_CAPSULE_LIST} contains a
     * list of packages whose availability changed.
     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
     * list of uids of packages whose availability changed.
     * Note that the
     * packages in this list do <em>not</em> receive this broadcast.
     * The specified set of packages are now available on the system.
     * <p>Includes the following extras:
     * <ul>
     * <li> {@link #EXTRA_CHANGED_CAPSULE_LIST} is the set of packages
     * whose resources(were previously unavailable) are currently available.
     * {@link #EXTRA_CHANGED_UID_LIST} is the set of uids of the
     * packages whose resources(were previously unavailable)
     * are  currently available.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_EXTERNAL_APPLICATIONS_AVAILABLE = "elastos.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";

    /**
     * Broadcast Action: Resources for a set of packages are currently
     * unavailable since the media on which they exist is unavailable.
     * The extra data {@link #EXTRA_CHANGED_CAPSULE_LIST} contains a
     * list of packages whose availability changed.
     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
     * list of uids of packages whose availability changed.
     * The specified set of packages can no longer be
     * launched and are practically unavailable on the system.
     * <p>Inclues the following extras:
     * <ul>
     * <li> {@link #EXTRA_CHANGED_CAPSULE_LIST} is the set of packages
     * whose resources are no longer available.
     * {@link #EXTRA_CHANGED_UID_LIST} is the set of packages
     * whose resources are no longer available.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE = "elastos.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";

    /**
     * Broadcast Action:  The current system wallpaper has changed.  See
     * {@link elastos.app.WallpaperManager} for retrieving the new wallpaper.
     */
    const Intent_ACTION_WALLPAPER_CHANGED = "elastos.intent.action.WALLPAPER_CHANGED";

    /**
     * Broadcast Action: The current device {@link elastos.content.res.Configuration}
     * (orientation, locale, etc) has changed.  When such a change happens, the
     * UIs (view hierarchy) will need to be rebuilt based on this new
     * information; for the most part, applications don't need to worry about
     * this, because the system will take care of stopping and restarting the
     * application to make sure it sees the new changes.  Some system code that
     * can not be restarted will need to watch for this action and handle it
     * appropriately.
     *
     * <p class="note">
     * You can <em>not</em> receive this through components declared
     * in manifests, only by explicitly registering for it with
     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
     * Context.registerReceiver()}.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * @see elastos.content.res.Configuration
     */
    const Intent_ACTION_CONFIGURATION_CHANGED = "elastos.intent.action.CONFIGURATION_CHANGED";

    /**
     * Broadcast Action: The current device's locale has changed.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_LOCALE_CHANGED = "elastos.intent.action.LOCALE_CHANGED";

    /**
     * Activity Action: Setup wizard to launch after a platform update.  This
     * activity should have a string meta-data field associated with it,
     * {@link #METADATA_SETUP_VERSION}, which defines the current version of
     * the platform for setup.  The activity will be launched only if
     * {@link android.provider.Settings.Secure#LAST_SETUP_SHOWN} is not the
     * same value.
     * <p>Input: Nothing.
     * <p>Output: Nothing.
     * @hide
     */
    const Intent_ACTION_UPGRADE_SETUP = "android.intent.action.UPGRADE_SETUP";

    /**
     * A string associated with a {@link #ACTION_UPGRADE_SETUP} activity
     * describing the last run version of the platform that was setup.
     * @hide
     */
    const Intent_METADATA_SETUP_VERSION = "android.SETUP_VERSION";

    /**
     * Broadcast Action:  This is a <em>sticky broadcast</em> containing the
     * charging state, level, and other information about the battery.
     * See {@link elastos.os.BatteryManager} for documentation on the
     * contents of the Intent.
     *
     * <p class="note">
     * You can <em>not</em> receive this through components declared
     * in manifests, only by explicitly registering for it with
     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
     * Context.registerReceiver()}.  See {@link #Intent_ACTION_BATTERY_LOW},
     * {@link #Intent_ACTION_BATTERY_OKAY}, {@link #Intent_ACTION_POWER_CONNECTED},
     * and {@link #Intent_ACTION_POWER_DISCONNECTED} for distinct battery-related
     * broadcasts that are sent and can be received through manifest
     * receivers.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BATTERY_CHANGED = "elastos.intent.action.BATTERY_CHANGED";

    /**
     * Broadcast Action:  Indicates low battery condition on the device.
     * This broadcast corresponds to the "Low battery warning" system dialog.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BATTERY_LOW = "elastos.intent.action.BATTERY_LOW";

    /**
     * Broadcast Action:  Indicates the battery is now okay after being low.
     * This will be sent after {@link #Intent_ACTION_BATTERY_LOW} once the battery has
     * gone back up to an okay state.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BATTERY_OKAY = "elastos.intent.action.BATTERY_OKAY";

    /**
     * Broadcast Action:  External power has been connected to the device.
     * This is intended for applications that wish to register specifically to this notification.
     * Unlike Intent_ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
     * stay active to receive this notification.  This action can be used to implement actions
     * that wait until power is available to trigger.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_POWER_CONNECTED = "elastos.intent.action.Intent_ACTION_POWER_CONNECTED";

    /**
     * Broadcast Action:  External power has been removed from the device.
     * This is intended for applications that wish to register specifically to this notification.
     * Unlike Intent_ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
     * stay active to receive this notification.  This action can be used to implement actions
     * that wait until power is available to trigger.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_POWER_DISCONNECTED = "elastos.intent.action.Intent_ACTION_POWER_DISCONNECTED";

    /**
     * Broadcast Action:  Device is shutting down.
     * This is broadcast when the device is being shut down (completely turned
     * off, not sleeping).  Once the broadcast is complete, the final shutdown
     * will proceed and all unsaved data lost.  Apps will not normally need
     * to handle this, since the foreground activity will be paused as well.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_SHUTDOWN = "elastos.intent.action.Intent_ACTION_SHUTDOWN";

    /**
     * Activity Action:  Start this activity to request system shutdown.
     * The optional boolean extra field {@link #EXTRA_KEY_CONFIRM} can be set to true
     * to request confirmation from the user before shutting down.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * {@hide}
     */
    const Intent_ACTION_REQUEST_SHUTDOWN = "elastos.intent.action.Intent_ACTION_REQUEST_SHUTDOWN";

    /**
     * Broadcast Action:  A sticky broadcast that indicates low memory
     * condition on the device
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_DEVICE_STORAGE_LOW = "elastos.intent.action.DEVICE_STORAGE_LOW";

    /**
     * Broadcast Action:  Indicates low memory condition on the device no longer exists
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_DEVICE_STORAGE_OK = "elastos.intent.action.DEVICE_STORAGE_OK";

    /**
     * Broadcast Action:  A sticky broadcast that indicates a memory full
     * condition on the device. This is intended for activities that want
     * to be able to fill the data partition completely, leaving only
     * enough free space to prevent system-wide SQLite failures.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * {@hide}
     */
    const Intent_ACTION_DEVICE_STORAGE_FULL = "elastos.intent.action.DEVICE_STORAGE_FULL";

    /**
     * Broadcast Action:  Indicates memory full condition on the device
     * no longer exists.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * {@hide}
     */
    const Intent_ACTION_DEVICE_STORAGE_NOT_FULL = "elastos.intent.action.DEVICE_STORAGE_NOT_FULL";

    /**
     * Broadcast Action:  Indicates low memory condition notification acknowledged by user
     * and package management should be started.
     * This is triggered by the user from the Intent_ACTION_DEVICE_STORAGE_LOW
     * notification.
     */
    const Intent_ACTION_MANAGE_CAPSULE_STORAGE = "elastos.intent.action.MANAGE_CAPSULE_STORAGE";

    /**
     * Broadcast Action:  The device has entered USB Mass Storage mode.
     * This is used mainly for the USB Settings panel.
     * Apps should listen for Intent_ACTION_MEDIA_MOUNTED and Intent_ACTION_MEDIA_UNMOUNTED broadcasts to be notified
     * when the SD card file system is mounted or unmounted
     */
    const Intent_ACTION_UMS_CONNECTED = "elastos.intent.action.UMS_CONNECTED";

    /**
     * Broadcast Action:  The device has exited USB Mass Storage mode.
     * This is used mainly for the USB Settings panel.
     * Apps should listen for Intent_ACTION_MEDIA_MOUNTED and Intent_ACTION_MEDIA_UNMOUNTED broadcasts to be notified
     * when the SD card file system is mounted or unmounted
     */
    const Intent_ACTION_UMS_DISCONNECTED = "elastos.intent.action.UMS_DISCONNECTED";

    /**
     * Broadcast Action:  External media has been removed.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_REMOVED = "elastos.intent.action.MEDIA_REMOVED";

    /**
     * Broadcast Action:  External media is present, but not mounted at its mount point.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_UNMOUNTED = "elastos.intent.action.MEDIA_UNMOUNTED";

    /**
     * Broadcast Action:  External media is present, and being disk-checked
     * The path to the mount point for the checking media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_CHECKING = "elastos.intent.action.MEDIA_CHECKING";

    /**
     * Broadcast Action:  External media is present, but is using an incompatible fs (or is blank)
     * The path to the mount point for the checking media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_NOFS = "elastos.intent.action.MEDIA_NOFS";

    /**
     * Broadcast Action:  External media is present and mounted at its mount point.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     * The Intent contains an extra with name "read-only" and Boolean value to indicate if the
     * media was mounted read only.
     */
    const Intent_ACTION_MEDIA_MOUNTED = "elastos.intent.action.MEDIA_MOUNTED";

    /**
     * Broadcast Action:  External media is unmounted because it is being shared via USB mass storage.
     * The path to the mount point for the shared media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SHARED = "elastos.intent.action.MEDIA_SHARED";

    /**
     * Broadcast Action:  External media is no longer being shared via USB mass storage.
     * The path to the mount point for the previously shared media is contained in the Intent.mData field.
     *
     * @hide
     */
    const Intent_ACTION_MEDIA_UNSHARED = "elastos.intent.action.MEDIA_UNSHARED";

    /**
     * Broadcast Action:  External media was removed from SD card slot, but mount point was not unmounted.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_BAD_REMOVAL = "elastos.intent.action.MEDIA_BAD_REMOVAL";

    /**
     * Broadcast Action:  External media is present but cannot be mounted.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_UNMOUNTABLE = "elastos.intent.action.MEDIA_UNMOUNTABLE";

   /**
     * Broadcast Action:  User has expressed the desire to remove the external storage media.
     * Applications should close all files they have open within the mount point when they receive this intent.
     * The path to the mount point for the media to be ejected is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_EJECT = "elastos.intent.action.MEDIA_EJECT";

    /**
     * Broadcast Action:  The media scanner has started scanning a directory.
     * The path to the directory being scanned is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SCANNER_STARTED = "elastos.intent.action.MEDIA_SCANNER_STARTED";

   /**
     * Broadcast Action:  The media scanner has finished scanning a directory.
     * The path to the scanned directory is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SCANNER_FINISHED = "elastos.intent.action.MEDIA_SCANNER_FINISHED";

   /**
     * Broadcast Action:  Request the media scanner to scan a file and add it to the media database.
     * The path to the file is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SCANNER_SCAN_FILE = "elastos.intent.action.MEDIA_SCANNER_SCAN_FILE";

   /**
     * Broadcast Action:  The "Media Button" was pressed.  Includes a single
     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
     * caused the broadcast.
     */
    const Intent_ACTION_MEDIA_BUTTON = "elastos.intent.action.MEDIA_BUTTON";

    /**
     * Broadcast Action:  The "Camera Button" was pressed.  Includes a single
     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
     * caused the broadcast.
     */
    const Intent_ACTION_CAMERA_BUTTON = "elastos.intent.action.CAMERA_BUTTON";

    // *** NOTE: @todo(*) The following really should go into a more domain-specific
    // location; they are not general-purpose actions.

    /**
     * Broadcast Action: An GTalk connection has been established.
     */
    const Intent_ACTION_GTALK_SERVICE_CONNECTED = "elastos.intent.action.GTALK_CONNECTED";

    /**
     * Broadcast Action: An GTalk connection has been disconnected.
     */
    const Intent_ACTION_GTALK_SERVICE_DISCONNECTED = "elastos.intent.action.GTALK_DISCONNECTED";

    /**
     * Broadcast Action: An input method has been changed.
     */
    const Intent_ACTION_INPUT_METHOD_CHANGED = "elastos.intent.action.INPUT_METHOD_CHANGED";

    /**
     * <p>Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or
     * more radios have been turned off or on. The intent will have the following extra value:</p>
     * <ul>
     *   <li><em>state</em> - A boolean value indicating whether Airplane Mode is on. If true,
     *   then cell radio and possibly other radios such as bluetooth or WiFi may have also been
     *   turned off</li>
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_AIRPLANE_MODE_CHANGED = "elastos.intent.action.AIRPLANE_MODE";

    /**
     * Broadcast Action: Some content providers have parts of their namespace
     * where they publish new events or items that the user may be especially
     * interested in. For these things, they may broadcast this action when the
     * set of interesting items change.
     *
     * For example, GmailProvider sends this notification when the set of unread
     * mail in the inbox changes.
     *
     * <p>The data of the intent identifies which part of which provider
     * changed. When queried through the content resolver, the data URI will
     * return the data set in question.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>count</em> - The number of items in the data set. This is the
     *       same as the number of items in the cursor returned by querying the
     *       data URI. </li>
     * </ul>
     *
     * This intent will be sent at boot (if the count is non-zero) and when the
     * data set changes. It is possible for the data set to change without the
     * count changing (for example, if a new unread message arrives in the same
     * sync operation in which a message is archived). The phone should still
     * ring/vibrate/etc as normal in this case.
     */
    const Intent_ACTION_PROVIDER_CHANGED = "elastos.intent.action.PROVIDER_CHANGED";

    /**
     * Broadcast Action: Wired Headset plugged in or unplugged.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
     *   <li><em>name</em> - Headset type, human readable string </li>
     *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>
     * </ul>
     * </ul>
     */
    const Intent_ACTION_HEADSET_PLUG = "elastos.intent.action.HEADSET_PLUG";

    /**
     * Broadcast Action: An analog audio speaker/headset plugged in or unplugged.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
     *   <li><em>name</em> - Headset type, human readable string </li>
     * </ul>
     * </ul>
     * @hide
     */
    const Intent_ACTION_ANALOG_AUDIO_DOCK_PLUG = "android.intent.action.ANALOG_AUDIO_DOCK_PLUG";

    /**
     * Broadcast Action: A digital audio speaker/headset plugged in or unplugged.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
     *   <li><em>name</em> - Headset type, human readable string </li>
     * </ul>
     * </ul>
     * @hide
     */
    const Intent_ACTION_DIGITAL_AUDIO_DOCK_PLUG = "android.intent.action.DIGITAL_AUDIO_DOCK_PLUG";

    /**
     * Broadcast Action: A HMDI cable was plugged or unplugged
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
     *   <li><em>name</em> - HDMI cable, human readable string </li>
     * </ul>
     * </ul>
     * @hide
     */
    const Intent_ACTION_HDMI_AUDIO_PLUG = "android.intent.action.HDMI_AUDIO_PLUG";

    /**
     * Broadcast Action: A USB audio accessory was plugged in or unplugged.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
     *   <li><em>card</em> - ALSA card number (integer) </li>
     *   <li><em>device</em> - ALSA device number (integer) </li>
     * </ul>
     * </ul>
     * @hide
     */
    const Intent_ACTION_USB_AUDIO_ACCESSORY_PLUG = "android.intent.action.USB_AUDIO_ACCESSORY_PLUG";

    /**
     * Broadcast Action: A USB audio device was plugged in or unplugged.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
     *   <li><em>card</em> - ALSA card number (integer) </li>
     *   <li><em>device</em> - ALSA device number (integer) </li>
     * </ul>
     * </ul>
     * @hide
     */
    const Intent_ACTION_USB_AUDIO_DEVICE_PLUG = "android.intent.action.USB_AUDIO_DEVICE_PLUG";

    /**
     * <p>Broadcast Action: The user has switched on advanced settings in the settings app:</p>
     * <ul>
     *   <li><em>state</em> - A boolean value indicating whether the settings is on or off.</li>
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * @hide
     */
    const Intent_ACTION_ADVANCED_SETTINGS_CHANGED = "android.intent.action.ADVANCED_SETTINGS";

    /**
     * Broadcast Action: An outgoing call is about to be placed.
     *
     * <p>The Intent will have the following extra value:
     * <ul>
     *   <li><em>{@link elastos.content.Intent#EXTRA_PHONE_NUMBER}</em> -
     *       the phone number originally intended to be dialed.</li>
     * </ul>
     * <p>Once the broadcast is finished, the resultData is used as the actual
     * number to call.  If  <code>null</code>, no call will be placed.</p>
     * <p>It is perfectly acceptable for multiple receivers to process the
     * outgoing call in turn: for example, a parental control application
     * might verify that the user is authorized to place the call at that
     * time, then a number-rewriting application might add an area code if
     * one was not specified.</p>
     * <p>For consistency, any receiver whose purpose is to prohibit phone
     * calls should have a priority of 0, to ensure it will see the final
     * phone number to be dialed.
     * Any receiver whose purpose is to rewrite phone numbers to be called
     * should have a positive priority.
     * Negative priorities are reserved for the system for this broadcast;
     * using them may cause problems.</p>
     * <p>Any BroadcastReceiver receiving this Intent <em>must not</em>
     * abort the broadcast.</p>
     * <p>Emergency calls cannot be intercepted using this mechanism, and
     * other calls cannot be modified to call emergency numbers using this
     * mechanism.
     * <p>You must hold the
     * {@link elastos.Manifest.permission#PROCESS_OUTGOING_CALLS}
     * permission to receive this Intent.</p>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_NEW_OUTGOING_CALL = "elastos.intent.action.NEW_OUTGOING_CALL";

    /**
     * Broadcast Action: Have the device reboot.  This is only for use by
     * system code.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_REBOOT = "elastos.intent.action.REBOOT";

    /**
     * Broadcast Action:  A sticky broadcast for changes in the physical
     * docking state of the device.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>{@link #EXTRA_DOCK_STATE}</em> - the current dock
     *       state, indicating which dock the device is physically in.</li>
     * </ul>
     * <p>This is intended for monitoring the current physical dock state.
     * See {@link elastos.app.UiModeManager} for the normal API dealing with
     * dock mode changes.
     */
    const Intent_ACTION_DOCK_EVENT = "elastos.intent.action.DOCK_EVENT";

    /**
     * Broadcast Action: a remote intent is to be broadcasted.
     *
     * A remote intent is used for remote RPC between devices. The remote intent
     * is serialized and sent from one device to another device. The receiving
     * device parses the remote intent and broadcasts it. Note that anyone can
     * broadcast a remote intent. However, if the intent receiver of the remote intent
     * does not trust intent broadcasts from arbitrary intent senders, it should require
     * the sender to hold certain permissions so only trusted sender's broadcast will be
     * let through.
     * @hide
     */
    const Intent_ACTION_REMOTE_INTENT = "com.kortide.elastos.c2dm.intent.RECEIVE";

    /**
     * Broadcast Action: hook for permforming cleanup after a system update.
     *
     * The broadcast is sent when the system is booting, before the
     * BOOT_COMPLETED broadcast.  It is only sent to receivers in the system
     * image.  A receiver for this should do its work and then disable itself
     * so that it does not get run again at the next boot.
     * @hide
     */
    const Intent_ACTION_PRE_BOOT_COMPLETED = "elastos.intent.action.PRE_BOOT_COMPLETED";

    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Standard intent categories (see addCategory()).

    /**
     * Set if the activity should be an option for the default action
     * (center press) to perform on a piece of data.  Setting this will
     * hide from the user any activities without it set when performing an
     * action on some data.  Note that this is normal -not- set in the
     * Intent when initiating an action -- it is for use in intent filters
     * specified in packages.
     */
    const Intent_CATEGORY_DEFAULT = "elastos.intent.category.DEFAULT";

    /**
     * Activities that can be safely invoked from a browser must support this
     * category.  For example, if the user is viewing a web page or an e-mail
     * and clicks on a link in the text, the Intent generated execute that
     * link will require the BROWSABLE category, so that only activities
     * supporting this category will be considered as possible actions.  By
     * supporting this category, you are promising that there is nothing
     * damaging (without user intervention) that can happen by invoking any
     * matching Intent.
     */
    const Intent_CATEGORY_BROWSABLE = "elastos.intent.category.BROWSABLE";

    /**
     * Set if the activity should be considered as an alternative action to
     * the data the user is currently viewing.  See also
     * {@link #CATEGORY_SELECTED_ALTERNATIVE} for an alternative action that
     * applies to the selection in a list of items.
     *
     * <p>Supporting this category means that you would like your activity to be
     * displayed in the set of alternative things the user can do, usually as
     * part of the current activity's options menu.  You will usually want to
     * include a specific label in the &lt;intent-filter&gt; of this action
     * describing to the user what it does.
     *
     * <p>The action of IntentFilter with this category is important in that it
     * describes the specific action the target will perform.  This generally
     * should not be a generic action (such as {@link #Intent_ACTION_VIEW}, but rather
     * a specific name such as "com.elastos.camera.action.CROP.  Only one
     * alternative of any particular action will be shown to the user, so using
     * a specific action like this makes sure that your alternative will be
     * displayed while also allowing other applications to provide their own
     * overrides of that particular action.
     */
    const Intent_CATEGORY_ALTERNATIVE = "elastos.intent.category.ALTERNATIVE";

    /**
     * Set if the activity should be considered as an alternative selection
     * action to the data the user has currently selected.  This is like
     * {@link #CATEGORY_ALTERNATIVE}, but is used in activities showing a list
     * of items from which the user can select, giving them alternatives to the
     * default action that will be performed on it.
     */
    const Intent_CATEGORY_SELECTED_ALTERNATIVE = "elastos.intent.category.SELECTED_ALTERNATIVE";

    /**
     * Intended to be used as a tab inside of an containing TabActivity.
     */
    const Intent_CATEGORY_TAB = "elastos.intent.category.TAB";

    /**
     * Should be displayed in the top-level launcher.
     */
    const Intent_CATEGORY_LAUNCHER = "elastos.intent.category.LAUNCHER";

    /**
     * Provides information about the package it is in; typically used if
     * a package does not contain a {@link #CATEGORY_LAUNCHER} to provide
     * a front-door to the user without having to be shown in the all apps list.
     */
    const Intent_CATEGORY_INFO = "elastos.intent.category.INFO";

    /**
     * This is the home activity, that is the first activity that is displayed
     * when the device boots.
     */
    const Intent_CATEGORY_HOME = "elastos.intent.category.HOME";

    /**
     * This activity is a preference panel.
     */
    const Intent_CATEGORY_PREFERENCE = "elastos.intent.category.PREFERENCE";

    /**
     * This activity is a development preference panel.
     */
    const Intent_CATEGORY_DEVELOPMENT_PREFERENCE = "elastos.intent.category.DEVELOPMENT_PREFERENCE";

    /**
     * Capable of running inside a parent activity container.
     */
    const Intent_CATEGORY_EMBED = "elastos.intent.category.EMBED";

    /**
     * This activity may be exercised by the monkey or other automated test tools.
     */
    const Intent_CATEGORY_MONKEY = "elastos.intent.category.MONKEY";

    /**
     * To be used as a test (not part of the normal user experience).
     */
    const Intent_CATEGORY_TEST = "elastos.intent.category.TEST";

    /**
     * To be used as a unit test (run through the Test Harness).
     */
    const Intent_CATEGORY_UNIT_TEST = "elastos.intent.category.UNIT_TEST";

    /**
     * To be used as an sample code example (not part of the normal user
     * experience).
     */
    const Intent_CATEGORY_SAMPLE_CODE = "elastos.intent.category.SAMPLE_CODE";

    /**
     * Used to indicate that a GET_CONTENT intent only wants URIs that can be opened with
     * ContentResolver.openInputStream. Openable URIs must support the columns in OpenableColumns
     * when queried, though it is allowable for those columns to be blank.
     */
    const Intent_CATEGORY_OPENABLE = "elastos.intent.category.OPENABLE";

    /**
     * To be used as code under test for framework instrumentation tests.
     */
    const Intent_CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST =
            "elastos.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";

    /**
     * An activity to run when device is inserted into a car dock.
     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
     * information, see {@link android.app.UiModeManager}.
     */
    const Intent_CATEGORY_CAR_DOCK = "elastos.intent.category.CAR_DOCK";

    /**
     * An activity to run when device is inserted into a car dock.
     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
     * information, see {@link android.app.UiModeManager}.
     */
    const Intent_CATEGORY_DESK_DOCK = "elastos.intent.category.DESK_DOCK";

    /**
     * Used to indicate that the activity can be used in a car environment.
     */
    const Intent_CATEGORY_CAR_MODE = "elastos.intent.category.CAR_MODE";

    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Standard extra data keys.

    /**
     * The initial data to place in a newly created record.  Use with
     * {@link #ACTION_INSERT}.  The data here is a Map containing the same
     * fields as would be given to the underlying ContentProvider.insert()
     * call.
     */
    const Intent_EXTRA_TEMPLATE = "android.intent.extra.TEMPLATE";

    /**
     * A constant CharSequence that is associated with the Intent, used with
     * {@link #ACTION_SEND} to supply the literal data to be sent.  Note that
     * this may be a styled CharSequence, so you must use
     * {@link Bundle#getCharSequence(String) Bundle.getCharSequence()} to
     * retrieve it.
     */
    const Intent_EXTRA_TEXT = "android.intent.extra.TEXT";

    /**
     * A content: URI holding a stream of data associated with the Intent,
     * used with {@link #ACTION_SEND} to supply the data being sent.
     */
    const Intent_EXTRA_STREAM = "android.intent.extra.STREAM";

    /**
     * A String[] holding e-mail addresses that should be delivered to.
     */
    const Intent_EXTRA_EMAIL       = "android.intent.extra.EMAIL";

    /**
     * A String[] holding e-mail addresses that should be carbon copied.
     */
    const Intent_EXTRA_CC       = "android.intent.extra.CC";

    /**
     * A String[] holding e-mail addresses that should be blind carbon copied.
     */
    const Intent_EXTRA_BCC      = "android.intent.extra.BCC";

    /**
     * A constant string holding the desired subject line of a message.
     */
    const Intent_EXTRA_SUBJECT  = "android.intent.extra.SUBJECT";

    /**
     * An Intent describing the choices you would like shown with
     * {@link #ACTION_PICK_ACTIVITY}.
     */
    const Intent_EXTRA_INTENT = "android.intent.extra.INTENT";

    /**
     * A CharSequence dialog title to provide to the user when used with a
     * {@link #ACTION_CHOOSER}.
     */
    const Intent_EXTRA_TITLE = "android.intent.extra.TITLE";

    /**
     * A Parcelable[] of {@link Intent} or
     * {@link android.content.pm.LabeledIntent} objects as set with
     * {@link #putExtra(String, Parcelable[])} of additional activities to place
     * a the front of the list of choices, when shown to the user with a
     * {@link #ACTION_CHOOSER}.
     */
    const Intent_EXTRA_INITIAL_INTENTS = "android.intent.extra.INITIAL_INTENTS";

    /**
     * A {@link android.view.KeyEvent} object containing the event that
     * triggered the creation of the Intent it is in.
     */
    const Intent_EXTRA_KEY_EVENT = "android.intent.extra.KEY_EVENT";

    /**
     * Set to true in {@link #ACTION_REQUEST_SHUTDOWN} to request confirmation from the user
     * before shutting down.
     *
     * {@hide}
     */
    const Intent_EXTRA_KEY_CONFIRM = "android.intent.extra.KEY_CONFIRM";

    /**
     * Used as an boolean extra field in {@link android.content.Intent#ACTION_CAPSULE_REMOVED} or
     * {@link android.content.Intent#ACTION_CAPSULE_CHANGED} intents to override the default action
     * of restarting the application.
     */
    const Intent_EXTRA_DONT_KILL_APP = "android.intent.extra.DONT_KILL_APP";

    /**
     * A String holding the phone number originally entered in
     * {@link android.content.Intent#ACTION_NEW_OUTGOING_CALL}, or the actual
     * number to call in a {@link android.content.Intent#ACTION_CALL}.
     */
    const Intent_EXTRA_PHONE_NUMBER = "android.intent.extra.PHONE_NUMBER";

    /**
     * Used as an int extra field in {@link android.content.Intent#ACTION_UID_REMOVED}
     * intents to supply the uid the package had been assigned.  Also an optional
     * extra in {@link android.content.Intent#ACTION_CAPSULE_REMOVED} or
     * {@link android.content.Intent#ACTION_CAPSULE_CHANGED} for the same
     * purpose.
     */
    const Intent_EXTRA_UID = "android.intent.extra.UID";

    /**
     * @hide String array of package names.
     */
    const Intent_EXTRA_CAPSULES = "android.intent.extra.CAPSULES";

    /**
     * Used as a boolean extra field in {@link android.content.Intent#ACTION_CAPSULE_REMOVED}
     * intents to indicate whether this represents a full uninstall (removing
     * both the code and its data) or a partial uninstall (leaving its data,
     * implying that this is an update).
     */
    const Intent_EXTRA_DATA_REMOVED = "android.intent.extra.DATA_REMOVED";

    /**
     * Used as a boolean extra field in {@link android.content.Intent#ACTION_CAPSULE_REMOVED}
     * intents to indicate that this is a replacement of the package, so this
     * broadcast will immediately be followed by an add broadcast for a
     * different version of the same package.
     */
    const Intent_EXTRA_REPLACING = "android.intent.extra.REPLACING";

    /**
     * Used as an int extra field in {@link android.app.AlarmManager} intents
     * to tell the application being invoked how many pending alarms are being
     * delievered with the intent.  For one-shot alarms this will always be 1.
     * For recurring alarms, this might be greater than 1 if the device was
     * asleep or powered off at the time an earlier alarm would have been
     * delivered.
     */
    const Intent_EXTRA_ALARM_COUNT = "android.intent.extra.ALARM_COUNT";

    /**
     * Used as an int extra field in {@link android.content.Intent#ACTION_DOCK_EVENT}
     * intents to request the dock state.  Possible values are
     * {@link android.content.Intent#EXTRA_DOCK_STATE_UNDOCKED},
     * {@link android.content.Intent#EXTRA_DOCK_STATE_DESK}, or
     * {@link android.content.Intent#EXTRA_DOCK_STATE_CAR}.
     */
    const Intent_EXTRA_DOCK_STATE = "android.intent.extra.DOCK_STATE";

    /**
     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
     * to represent that the phone is not in any dock.
     */
    const Intent_EXTRA_DOCK_STATE_UNDOCKED = 0;

    /**
     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
     * to represent that the phone is in a desk dock.
     */
    const Intent_EXTRA_DOCK_STATE_DESK = 1;

    /**
     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
     * to represent that the phone is in a car dock.
     */
    const Intent_EXTRA_DOCK_STATE_CAR = 2;

    /**
     * Boolean that can be supplied as meta-data with a dock activity, to
     * indicate that the dock should take over the home key when it is active.
     */
    const METADATA_DOCK_HOME = "android.dock_home";

    /**
     * Used as a parcelable extra field in {@link #ACTION_APP_ERROR}, containing
     * the bug report.
     *
     * @hide
     */
    const Intent_EXTRA_BUG_REPORT = "android.intent.extra.BUG_REPORT";

    /**
     * Used as a string extra field when sending an intent to PackageInstaller to install a
     * package. Specifies the installer package name; this package will receive the
     * {@link #ACTION_APP_ERROR} intent.
     *
     * @hide
     */
    const Intent_EXTRA_INSTALLER_CAPSULE_NAME
            = "android.intent.extra.INSTALLER_CAPSULE_NAME";

    /**
     * Used in the extra field in the remote intent. It's astring token passed with the
     * remote intent.
     */
    const Intent_EXTRA_REMOTE_INTENT_TOKEN =
            "android.intent.extra.remote_intent_token";

    /**
     * @deprecated See {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST}; this field
     * will contain only the first name in the list.
     */
    const Intent_EXTRA_CHANGED_COMPONENT_NAME =
            "android.intent.extra.changed_component_name";

    /**
     * This field is part of {@link android.content.Intent#ACTION_CAPSULE_CHANGED},
     * and contains a string array of all of the components that have changed.
     */
    const Intent_EXTRA_CHANGED_COMPONENT_NAME_LIST =
            "android.intent.extra.changed_component_name_list";

    /**
     * This field is part of
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
     * and contains a string array of all of the components that have changed.
     */
    const Intent_EXTRA_CHANGED_CAPSULE_LIST =
            "android.intent.extra.changed_package_list";

    /**
     * This field is part of
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
     * and contains an integer array of uids of all of the components
     * that have changed.
     */
    const Intent_EXTRA_CHANGED_UID_LIST =
            "android.intent.extra.changed_uid_list";

    /**
     * @hide
     * Magic extra system code can use when binding, to give a label for
     * who it is that has bound to a service.  This is an integer giving
     * a framework string resource that can be displayed to the user.
     */
    const Intent_EXTRA_CLIENT_LABEL =
            "android.intent.extra.client_label";

    /**
     * @hide
     * Magic extra system code can use when binding, to give a PendingIntent object
     * that can be launched for the user to disable the system's use of this
     * service.
     */
    const Intent_EXTRA_CLIENT_INTENT =
            "android.intent.extra.client_intent";

    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Intent flags (see mFlags variable).

    /**
     * If set, the recipient of this Intent will be granted permission to
     * perform read operations on the Uri in the Intent's data.
     */
    const Intent_FLAG_GRANT_READ_URI_PERMISSION = 0x00000001;

    /**
     * If set, the recipient of this Intent will be granted permission to
     * perform write operations on the Uri in the Intent's data.
     */
    const Intent_FLAG_GRANT_WRITE_URI_PERMISSION = 0x00000002;

    /**
     * Can be set by the caller to indicate that this Intent is coming from
     * a background operation, not from direct user interaction.
     */
    const Intent_FLAG_FROM_BACKGROUND = 0x00000004;

    /**
     * A flag you can enable for debugging: when set, log messages will be
     * printed during the resolution of this intent to show you what has
     * been found to create the final resolved list.
     */
    const Intent_FLAG_DEBUG_LOG_RESOLUTION = 0x00000008;

    /**
     * If set, the new activity is not kept in the history stack.  As soon as
     * the user navigates away from it, the activity is finished.  This may also
     * be set with the {@link elastos.R.styleable#AndroidManifestActivity_noHistory
     * noHistory} attribute.
     */
    const Intent_FLAG_ACTIVITY_NO_HISTORY = 0x40000000;

    /**
     * If set, the activity will not be launched if it is already running
     * at the top of the history stack.
     */
    const Intent_FLAG_ACTIVITY_SINGLE_TOP = 0x20000000;

    /**
     * If set, this activity will become the start of a new task on this
     * history stack.  A task (from the activity that started it to the
     * next task activity) defines an atomic group of activities that the
     * user can move to.  Tasks can be moved to the foreground and background;
     * all of the activities inside of a particular task always remain in
     * the same order.  See
     * <a href="{@docRoot}guide/topics/fundamentals.html#acttask">Application Fundamentals:
     * Activities and Tasks</a> for more details on tasks.
     *
     * <p>This flag is generally used by activities that want
     * to present a "launcher" style behavior: they give the user a list of
     * separate things that can be done, which otherwise run completely
     * independently of the activity launching them.
     *
     * <p>When using this flag, if a task is already running for the activity
     * you are now starting, then a new activity will not be started; instead,
     * the current task will simply be brought to the front of the screen with
     * the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
     * to disable this behavior.
     *
     * <p>This flag can not be used when the caller is requesting a result from
     * the activity being launched.
     */
    const Intent_FLAG_ACTIVITY_NEW_TASK = 0x10000000;

    /**
     * <strong>Do not use this flag unless you are implementing your own
     * top-level application launcher.</strong>  Used in conjunction with
     * {@link #FLAG_ACTIVITY_NEW_TASK} to disable the
     * behavior of bringing an existing task to the foreground.  When set,
     * a new task is <em>always</em> started to host the Activity for the
     * Intent, regardless of whether there is already an existing task running
     * the same thing.
     *
     * <p><strong>Because the default system does not include graphical task management,
     * you should not use this flag unless you provide some way for a user to
     * return back to the tasks you have launched.</strong>
     *
     * <p>This flag is ignored if
     * {@link #FLAG_ACTIVITY_NEW_TASK} is not set.
     *
     * <p>See <a href="{@docRoot}guide/topics/fundamentals.html#acttask">Application Fundamentals:
     * Activities and Tasks</a> for more details on tasks.
     */
    const Intent_FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;

    /**
     * If set, and the activity being launched is already running in the
     * current task, then instead of launching a new instance of that activity,
     * all of the other activities on top of it will be closed and this Intent
     * will be delivered to the (now on top) old activity as a new Intent.
     *
     * <p>For example, consider a task consisting of the activities: A, B, C, D.
     * If D calls startActivity() with an Intent that resolves to the component
     * of activity B, then C and D will be finished and B receive the given
     * Intent, resulting in the stack now being: A, B.
     *
     * <p>The currently running instance of task B in the above example will
     * either receive the new intent you are starting here in its
     * onNewIntent() method, or be itself finished and restarted with the
     * new intent.  If it has declared its launch mode to be "multiple" (the
     * default) it will be finished and re-created; for all other launch modes
     * it will receive the Intent in the current instance.
     *
     * <p>This launch mode can also be used to good effect in conjunction with
     * {@link #FLAG_ACTIVITY_NEW_TASK}: if used to start the root activity
     * of a task, it will bring any currently running instance of that task
     * to the foreground, and then clear it to its root state.  This is
     * especially useful, for example, when launching an activity from the
     * notification manager.
     *
     * <p>See <a href="{@docRoot}guide/topics/fundamentals.html#acttask">Application Fundamentals:
     * Activities and Tasks</a> for more details on tasks.
     */
    const Intent_FLAG_ACTIVITY_CLEAR_TOP = 0x04000000;

    /**
     * If set and this intent is being used to launch a new activity from an
     * existing one, then the reply target of the existing activity will be
     * transfered to the new activity.  This way the new activity can call
     * {@link elastos.app.Activity#setResult} and have that result sent back to
     * the reply target of the original activity.
     */
    const Intent_FLAG_ACTIVITY_FORWARD_RESULT = 0x02000000;

    /**
     * If set and this intent is being used to launch a new activity from an
     * existing one, the current activity will not be counted as the top
     * activity for deciding whether the new intent should be delivered to
     * the top instead of starting a new one.  The previous activity will
     * be used as the top, with the assumption being that the current activity
     * will finish itself immediately.
     */
    const Intent_FLAG_ACTIVITY_PREVIOUS_IS_TOP = 0x01000000;

    /**
     * If set, the new activity is not kept in the list of recently launched
     * activities.
     */
    const Intent_FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS = 0x00800000;

    /**
     * This flag is not normally set by application code, but set for you by
     * the system as described in the
     * {@link elastos.R.styleable#AndroidManifestActivity_launchMode
     * launchMode} documentation for the singleTask mode.
     */
    const Intent_FLAG_ACTIVITY_BROUGHT_TO_FRONT = 0x00400000;

    /**
     * If set, and this activity is either being started in a new task or
     * bringing to the top an existing task, then it will be launched as
     * the front door of the task.  This will result in the application of
     * any affinities needed to have that task in the proper state (either
     * moving activities to or from it), or simply resetting that task to
     * its initial state if needed.
     */
    const Intent_FLAG_ACTIVITY_RESET_TASK_IF_NEEDED = 0x00200000;

    /**
     * This flag is not normally set by application code, but set for you by
     * the system if this activity is being launched from history
     * (longpress home key).
     */
    const Intent_FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY = 0x00100000;

    /**
     * If set, this marks a point in the task's activity stack that should
     * be cleared when the task is reset.  That is, the next time the task
     * is brought to the foreground with
     * {@link #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED} (typically as a result of
     * the user re-launching it from home), this activity and all on top of
     * it will be finished so that the user does not return to them, but
     * instead returns to whatever activity preceeded it.
     *
     * <p>This is useful for cases where you have a logical break in your
     * application.  For example, an e-mail application may have a command
     * to view an attachment, which launches an image view activity to
     * display it.  This activity should be part of the e-mail application's
     * task, since it is a part of the task the user is involved in.  However,
     * if the user leaves that task, and later selects the e-mail app from
     * home, we may like them to return to the conversation they were
     * viewing, not the picture attachment, since that is confusing.  By
     * setting this flag when launching the image viewer, that viewer and
     * any activities it starts will be removed the next time the user returns
     * to mail.
     */
    const Intent_FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET = 0x00080000;

    /**
     * If set, this flag will prevent the normal {@link elastos.app.Activity#onUserLeaveHint}
     * callback from occurring on the current frontmost activity before it is
     * paused as the newly-started activity is brought to the front.
     *
     * <p>Typically, an activity can rely on that callback to indicate that an
     * explicit user action has caused their activity to be moved out of the
     * foreground. The callback marks an appropriate point in the activity's
     * lifecycle for it to dismiss any notifications that it intends to display
     * "until the user has seen them," such as a blinking LED.
     *
     * <p>If an activity is ever started via any non-user-driven events such as
     * phone-call receipt or an alarm handler, this flag should be passed to {@link
     * Context#startActivity Context.startActivity}, ensuring that the pausing
     * activity does not think the user has acknowledged its notification.
     */
    const Intent_FLAG_ACTIVITY_NO_USER_ACTION = 0x00040000;

    /**
     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
     * this flag will cause the launched activity to be brought to the front of its
     * task's history stack if it is already running.
     *
     * <p>For example, consider a task consisting of four activities: A, B, C, D.
     * If D calls startActivity() with an Intent that resolves to the component
     * of activity B, then B will be brought to the front of the history stack,
     * with this resulting order:  A, C, D, B.
     *
     * This flag will be ignored if {@link #FLAG_ACTIVITY_CLEAR_TOP} is also
     * specified.
     */
    const Intent_FLAG_ACTIVITY_REORDER_TO_FRONT = 0X00020000;

    /**
     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
     * this flag will prevent the system from applying an activity transition
     * animation to go to the next activity state.  This doesn't mean an
     * animation will never run -- if another activity change happens that doesn't
     * specify this flag before the activity started here is displayed, then
     * that transition will be used.  This this flag can be put to good use
     * when you are going to do a series of activity operations but the
     * animation seen by the user shouldn't be driven by the first activity
     * change but rather a later one.
     */
    const Intent_FLAG_ACTIVITY_NO_ANIMATION = 0X00010000;

    /**
     * If set, when sending a broadcast only registered receivers will be
     * called -- no BroadcastReceiver components will be launched.
     */
    const Intent_FLAG_RECEIVER_REGISTERED_ONLY = 0x40000000;

    /**
     * If set, when sending a broadcast the new broadcast will replace
     * any existing pending broadcast that matches it.  Matching is defined
     * by {@link Intent#filterEquals(Intent) Intent.filterEquals} returning
     * true for the intents of the two broadcasts.  When a match is found,
     * the new broadcast (and receivers associated with it) will replace the
     * existing one in the pending broadcast list, remaining at the same
     * position in the list.
     *
     * <p>This flag is most typically used with sticky broadcasts, which
     * only care about delivering the most recent values of the broadcast
     * to their receivers.
     */
    const Intent_FLAG_RECEIVER_REPLACE_PENDING = 0x20000000;

    /**
     * If set, when sending a broadcast <i>before boot has completed</i> only
     * registered receivers will be called -- no BroadcastReceiver components
     * will be launched.  Sticky intent state will be recorded properly even
     * if no receivers wind up being called.  If {@link #FLAG_RECEIVER_REGISTERED_ONLY}
     * is specified in the broadcast intent, this flag is unnecessary.
     *
     * <p>This flag is only for use by system sevices as a convenience to
     * avoid having to implement a more complex mechanism around detection
     * of boot completion.
     *
     * @hide
     */
    const Intent_FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = 0x10000000;

    /**
     * Set when this broadcast is for a boot upgrade, a special mode that
     * allows the broadcast to be sent before the system is ready and launches
     * the app process with no providers running in it.
     * @hide
     */
    const Intent_FLAG_RECEIVER_BOOT_UPGRADE = 0x08000000;

    /**
     * @hide Flags that can't be changed with PendingIntent.
     */
    const Intent_IMMUTABLE_FLAGS = 0x00000003; // FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION;

    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // toUri() and parseUri() options.

    /**
     * Flag for use with {@link #toUri} and {@link #parseUri}: the URI string
     * always has the "intent:" scheme.  This syntax can be used when you want
     * to later disambiguate between URIs that are intended to describe an
     * Intent vs. all others that should be treated as raw URIs.  When used
     * with {@link #parseUri}, any other scheme will result in a generic
     * VIEW action for that raw URI.
     */
    const Intent_URI_INTENT_SCHEME = 1; // 1<<0;

    /**
     * Use with {@link #fillIn} to allow the current action value to be
     * overwritten, even if it is already set.
     */
    const Intent_FILL_IN_ACTION = 1; // 1<<0;

    /**
     * Use with {@link #fillIn} to allow the current data or type value
     * overwritten, even if it is already set.
     */
    const Intent_FILL_IN_DATA = 2; // 1<<1;

    /**
     * Use with {@link #fillIn} to allow the current categories to be
     * overwritten, even if they are already set.
     */
    const Intent_FILL_IN_CATEGORIES = 4; // 1<<2;

    /**
     * Use with {@link #fillIn} to allow the current component value to be
     * overwritten, even if it is already set.
     */
    const Intent_FILL_IN_COMPONENT = 8; // 1<<3;

    /**
     * Use with {@link #fillIn} to allow the current package value to be
     * overwritten, even if it is already set.
     */
    const Intent_FILL_IN_PACKAGE = 16; // 1<<4;

    /**
     * Use with {@link #fillIn} to allow the current package value to be
     * overwritten, even if it is already set.
     */
    const Intent_FILL_IN_SOURCE_BOUNDS = 32; // 1<<5;

    interface IDescribable;
    interface IComponentName;
    interface IUri;
    interface IBundle;
    interface ICapsuleManager;
    interface IActivityInfo;
    interface IContentResolver;
    interface IIntent;
    interface ICharSequence;
    interface IParcelable;
    interface IRect;

    interface IIntentFilterComparison {
        /**
         * Return the Intent that this FilterComparison represents.
         * @return Returns the Intent held by the FilterComparison.  Do
         * not modify!
         */
        GetIntent(
            [out] IIntent** intent);

        Equals(
            [in] IIntentFilterComparison* other,
            [out] Boolean* isEqual);

        GetHashCode(
            [out] Int32* hashCode);

        GetDescription(
            [out] String* description);
    }

    [deprecated]
    interface IIntent extends IDescribable{

        /**
         * Make a clone of only the parts of the Intent that are relevant for
         * filter matching: the action, data, type, component, and categories.
         */
        CloneFilter(
            [out] IIntent** result);

        /**
         * Retrieve the general action to be performed, such as
         * {@link #ACTION_VIEW}.  The action describes the general way the rest of
         * the information in the intent should be interpreted -- most importantly,
         * what to do with the data returned by {@link #getData}.
         *
         * @return The action of this intent or null if none is specified.
         *
         * @see #setAction
         */
        GetAction(
            [out] String* action);

        /**
         * Retrieve data this intent is operating on.  This URI specifies the name
         * of the data; often it uses the content: scheme, specifying data in a
         * content provider.  Other schemes may be handled by specific activities,
         * such as http: by the web browser.
         *
         * @return The URI of the data this intent is targeting or null.
         *
         * @see #getScheme
         * @see #setData
         */
        GetData(
            [out] IUri** data);

        /**
         * The same as {@link #getData()}, but returns the URI as an encoded
         * String.
         */
        GetDataString(
            [out] String* dataString);

        /**
         * Return the scheme portion of the intent's data.  If the data is null or
         * does not include a scheme, null is returned.  Otherwise, the scheme
         * prefix without the final ':' is returned, i.e. "http".
         *
         * <p>This is the same as calling getData().getScheme() (and checking for
         * null data).
         *
         * @return The scheme of this intent.
         *
         * @see #getData
         */
        GetScheme(
            [out] String* scheme);

        /**
         * Retrieve any explicit MIME type included in the intent.  This is usually
         * null, as the type is determined by the intent data.
         *
         * @return If a type was manually set, it is returned; else null is
         *         returned.
         *
         * @see #resolveType(ContentResolver)
         * @see #setType
         */
        GetType(
            [out] String* type);

        /**
         * Return the MIME data type of this intent.  If the type field is
         * explicitly set, that is simply returned.  Otherwise, if the data is set,
         * the type of that data is returned.  If neither fields are set, a null is
         * returned.
         *
         * @return The MIME type of this intent.
         *
         * @see #getType
         * @see #resolveType(ContentResolver)
         */
        ResolveType(
            [in] IContext* context,
            [out] String* type);

        /**
         * Return the MIME data type of this intent.  If the type field is
         * explicitly set, that is simply returned.  Otherwise, if the data is set,
         * the type of that data is returned.  If neither fields are set, a null is
         * returned.
         *
         * @param resolver A ContentResolver that can be used to determine the MIME
         *                 type of the intent's data.
         *
         * @return The MIME type of this intent.
         *
         * @see #getType
         * @see #resolveType(Context)
         */
        ResolveTypeEx(
            [in] IContentResolver* resolver,
            [out] String* type);

        /**
         * Return the MIME data type of this intent, only if it will be needed for
         * intent resolution.  This is not generally useful for application code;
         * it is used by the frameworks for communicating with back-end system
         * services.
         *
         * @param resolver A ContentResolver that can be used to determine the MIME
         *                 type of the intent's data.
         *
         * @return The MIME type of this intent, or null if it is unknown or not
         *         needed.
         */
        ResolveTypeIfNeeded(
            [in] IContentResolver* resolver,
            [out] String* type);

        /**
         * Check if an category exists in the intent.
         *
         * @param category The category to check.
         *
         * @return boolean True if the intent contains the category, else false.
         *
         * @see #getCategories
         * @see #addCategory
         */
        HasCategory(
            [in] String category,
            [out] Boolean* result);

        /**
         * Return the set of all categories in the intent.  If there are no categories,
         * returns NULL.
         *
         * @return Set The set of categories you can examine.  Do not modify!
         *
         * @see #hasCategory
         * @see #addCategory
         */
        GetCategories(
            [out, callee] ArrayOf<String>* categories);

        /**
         * Sets the ClassLoader that will be used when unmarshalling
         * any Parcelable values from the extras of this Intent.
         *
         * @param loader a ClassLoader, or null to use the default loader
         * at the time of unmarshalling.
         */
        SetExtrasClassLoader(
            [in] IClassLoader* loader);

        /**
         * Returns true if an extra value is associated with the given name.
         * @param name the extra's name
         * @return true if the given extra is present.
         */
        HasExtra(
            [in] String name,
            [out] Boolean* result);

        /**
         * Returns true if the Intent's extras contain a parcelled file descriptor.
         * @return true if the Intent contains a parcelled file descriptor.
         */
        HasFileDescriptors(
            [out] Boolean* result);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if none was found.
         *
         * @deprecated
         * @hide
         */
        // @Deprecated
        // public Object getExtra(String name);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, boolean)
         */
        GetBooleanExtraEx(
            [in] String name,
            [in] Boolean defaultValue,
            [out] Boolean* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, byte)
         */
        GetByteExtraEx(
            [in] String name,
            [in] Byte defaultValue,
            [out] Byte* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, short)
         */
        GetInt16ExtraEx(
            [in] String name,
            [in] Int16 defaultValue,
            [out] Int16* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, char)
         */
        GetCharExtraEx(
            [in] String name,
            [in] Char32 defaultValue,
            [out] Char32* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, int)
         */
        GetInt32ExtraEx(
            [in] String name,
            [in] Int32 defaultValue,
            [out] Int32* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, long)
         */
        GetInt64ExtraEx(
            [in] String name,
            [in] Int64 defaultValue,
            [out] Int64* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra(),
         * or the default value if no such item is present
         *
         * @see #putExtra(String, float)
         */
        GetFloatExtraEx(
            [in] String name,
            [in] Float defaultValue,
            [out] Float* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, double)
         */
        GetDoubleExtraEx(
            [in] String name,
            [in] Double defaultValue,
            [out] Double* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no String value was found.
         *
         * @see #putExtra(String, String)
         */
        GetStringExtra(
            [in] String name,
            [out] String* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no CharSequence value was found.
         *
         * @see #putExtra(String, CharSequence)
         */
        GetCharSequenceExtra(
            [in] String name,
            [out] ICharSequence** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Parcelable value was found.
         *
         * @see #putExtra(String, Parcelable)
         */
        GetParcelableExtra(
            [in] String name,
            [out] IParcelable** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Parcelable[] value was found.
         *
         * @see #putExtra(String, Parcelable[])
         */
        GetParcelableArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<IParcelable*>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<Parcelable> value was found.
         *
         * @see #putParcelableArrayListExtra(String, ArrayList)
         */
        GetParcelableArrayListExtra(
            [in] String name,
            [out] IObjectContainer** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Serializable value was found.
         *
         * @see #putExtra(String, Serializable)
         */
        // GetSerializableExtra(
        //     [in] String name,
        //     [out] ISerializable** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<Integer> value was found.
         *
         * @see #putIntegerArrayListExtra(String, ArrayList)
         */
        GetIntegerArrayListExtra(
            [in] String name,
            [out] IObjectContainer** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *a
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<String> value was found.
         *
         * @see #putStringArrayListExtra(String, ArrayList)
         */
        GetStringArrayListExtra(
            [in] String name,
            [out] IObjectContainer** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<CharSequence> value was found.
         *
         * @see #putCharSequenceArrayListExtra(String, ArrayList)
         */
        GetCharSequenceArrayListExtra(
            [in] String name,
            [out] IObjectContainer** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no boolean array value was found.
         *
         * @see #putExtra(String, boolean[])
         */
        GetBooleanArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Boolean>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no byte array value was found.
         *
         * @see #putExtra(String, byte[])
         */
        GetByteArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Byte>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no short array value was found.
         *
         * @see #putExtra(String, short[])
         */
        GetInt16ArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Int16>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no char array value was found.
         *
         * @see #putExtra(String, char[])
         */
        GetCharArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Char32>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no int array value was found.
         *
         * @see #putExtra(String, int[])
         */
        GetInt32ArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Int32>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no long array value was found.
         *
         * @see #putExtra(String, long[])
         */
        GetInt64ArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Int64>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no float array value was found.
         *
         * @see #putExtra(String, float[])
         */
        GetFloatArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Float>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no double array value was found.
         *
         * @see #putExtra(String, double[])
         */
        GetDoubleArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Double>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no String array value was found.
         *
         * @see #putExtra(String, String[])
         */
        GetStringArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<String>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no CharSequence array value was found.
         *
         * @see #putExtra(String, CharSequence[])
         */
        GetCharSequenceArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<ICharSequence*>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Bundle value was found.
         *
         * @see #putExtra(String, Bundle)
         */
        GetBundleExtra(
            [in] String name,
            [out] IBundle** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no IBinder value was found.
         *
         * @see #putExtra(String, IBinder)
         *
         * @deprecated
         * @hide
         */
        // @Deprecated
        // public IBinder getIBinderExtra(String name);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue The default value to return in case no item is
         * associated with the key 'name'
         *
         * @return the value of an item that previously added with putExtra()
         * or defaultValue if none was found.
         *
         * @see #putExtra
         *
         * @deprecated
         * @hide
         */
        // @Deprecated
        // public Object getExtra(String name, Object defaultValue);

        /**
         * Retrieves a map of extended data from the intent.
         *
         * @return the map of all extras previously added with putExtra(),
         * or null if none have been added.
         */
        GetExtras(
            [out] IBundle** extras);

        /**
         * Retrieve any special flags associated with this intent.  You will
         * normally just set them with {@link #setFlags} and let the system
         * take the appropriate action with them.
         *
         * @return int The currently set flags.
         *
         * @see #setFlags
         */
        GetFlags(
            [out] Int32* flags);

        /**
         * Retrieve the application package name this Intent is limited to.  When
         * resolving an Intent, if non-null this limits the resolution to only
         * components in the given application package.
         *
         * @return The name of the application package for the Intent.
         *
         * @see #resolveActivity
         * @see #setPackage
         */
        GetCapsule(
            [out] String* capsuleName);

        /**
         * Retrieve the concrete component associated with the intent.  When receiving
         * an intent, this is the component that was found to best handle it (that is,
         * yourself) and will always be non-null; in all other cases it will be
         * null unless explicitly set.
         *
         * @return The name of the application component to handle the intent.
         *
         * @see #resolveActivity
         * @see #setComponent
         */
        GetComponent(
            [out] IComponentName** result);

        /**
         * Get the bounds of the sender of this intent, in screen coordinates.  This can be
         * used as a hint to the receiver for animations and the like.  Null means that there
         * is no source bounds.
         */
        GetSourceBounds(
            [out] IRect** result);

        /**
         * Return the Activity component that should be used to handle this intent.
         * The appropriate component is determined based on the information in the
         * intent, evaluated as follows:
         *
         * <p>If {@link #getComponent} returns an explicit class, that is returned
         * without any further consideration.
         *
         * <p>The activity must handle the {@link Intent#CATEGORY_DEFAULT} Intent
         * category to be considered.
         *
         * <p>If {@link #getAction} is non-NULL, the activity must handle this
         * action.
         *
         * <p>If {@link #resolveType} returns non-NULL, the activity must handle
         * this type.
         *
         * <p>If {@link #addCategory} has added any categories, the activity must
         * handle ALL of the categories specified.
         *
         * <p>If {@link #getPackage} is non-NULL, only activity components in
         * that application package will be considered.
         *
         * <p>If there are no activities that satisfy all of these conditions, a
         * null string is returned.
         *
         * <p>If multiple activities are found to satisfy the intent, the one with
         * the highest priority will be used.  If there are multiple activities
         * with the same priority, the system will either pick the best activity
         * based on user preference, or resolve to a system class that will allow
         * the user to pick an activity and forward from there.
         *
         * <p>This method is implemented simply by calling
         * {@link PackageManager#resolveActivity} with the "defaultOnly" parameter
         * true.</p>
         * <p> This API is called for you as part of starting an activity from an
         * intent.  You do not normally need to call it yourself.</p>
         *
         * @param pm The package manager with which to resolve the Intent.
         *
         * @return Name of the component implementing an activity that can
         *         display the intent.
         *
         * @see #setComponent
         * @see #getComponent
         * @see #resolveActivityInfo
         */
        ResolveActivity(
            [in] ICapsuleManager* cm,
            [out] IComponentName** result);

        /**
         * Resolve the Intent into an {@link ActivityInfo}
         * describing the activity that should execute the intent.  Resolution
         * follows the same rules as described for {@link #resolveActivity}, but
         * you get back the completely information about the resolved activity
         * instead of just its class name.
         *
         * @param pm The package manager with which to resolve the Intent.
         * @param flags Addition information to retrieve as per
         * {@link PackageManager#getActivityInfo(ComponentName, int)
         * PackageManager.getActivityInfo()}.
         *
         * @return PackageManager.ActivityInfo
         *
         * @see #resolveActivity
         */
        ResolveActivityInfo(
            [in] ICapsuleManager* cm,
            [in] Int32 flags,
            [out] IActivityInfo** result);

        /**
         * Set the general action to be performed.
         *
         * @param action An action name, such as ACTION_VIEW.  Application-specific
         *               actions should be prefixed with the vendor's package name.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getAction
         */
        SetActionEx(
            [in] String action,
            [out] IIntent** result);

        /**
         * Set the data this intent is operating on.  This method automatically
         * clears any type that was previously set by {@link #setType}.
         *
         * <p><em>Note: scheme and host name matching in the Android framework is
         * case-sensitive, unlike the formal RFC.  As a result,
         * you should always ensure that you write your Uri with these elements
         * using lower case letters, and normalize any Uris you receive from
         * outside of Android to ensure the scheme and host is lower case.</em></p>
         *
         * @param data The URI of the data this intent is now targeting.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getData
         * @see #setType
         * @see #setDataAndType
         */
        SetDataEx(
            [in] IUri* data,
            [out] IIntent** result);

        /**
         * Set an explicit MIME data type.  This is used to create intents that
         * only specify a type and not data, for example to indicate the type of
         * data to return.  This method automatically clears any data that was
         * previously set by {@link #setData}.
         *
         * <p><em>Note: MIME type matching in the Android framework is
         * case-sensitive, unlike formal RFC MIME types.  As a result,
         * you should always write your MIME types with lower case letters,
         * and any MIME types you receive from outside of Android should be
         * converted to lower case before supplying them here.</em></p>
         *
         * @param type The MIME type of the data being handled by this intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getType
         * @see #setData
         * @see #setDataAndType
         */
        SetTypeEx(
	        [in] String type,
	        [out] IIntent** result);

        /**
         * (Usually optional) Set the data for the intent along with an explicit
         * MIME data type.  This method should very rarely be used -- it allows you
         * to override the MIME type that would ordinarily be inferred from the
         * data with your own type given here.
         *
         * <p><em>Note: MIME type, Uri scheme, and host name matching in the
         * Android framework is case-sensitive, unlike the formal RFC definitions.
         * As a result, you should always write these elements with lower case letters,
         * and normalize any MIME types or Uris you receive from
         * outside of Android to ensure these elements are lower case before
         * supplying them here.</em></p>
         *
         * @param data The URI of the data this intent is now targeting.
         * @param type The MIME type of the data being handled by this intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setData
         * @see #setType
         */
        SetDataAndTypeEx(
    	    [in] IUri* data,
    	    [in] String type,
    	    [out] IIntent** result);

        /**
         * Add a new category to the intent.  Categories provide additional detail
         * about the action the intent is perform.  When resolving an intent, only
         * activities that provide <em>all</em> of the requested categories will be
         * used.
         *
         * @param category The desired category.  This can be either one of the
         *               predefined Intent categories, or a custom category in your own
         *               namespace.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #hasCategory
         * @see #removeCategory
         */
        AddCategoryEx(
            [in] String category,
            [out] IIntent** result);

        /**
         * Remove an category from an intent.
         *
         * @param category The category to remove.
         *
         * @see #addCategory
         */
        RemoveCategory(
            [in] String category);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The boolean data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getBooleanExtra(String, boolean)
         */
        PutBooleanExtraEx(
            [in] String name,
            [in] Boolean value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The byte data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getByteExtra(String, byte)
         */
        PutByteExtraEx(
            [in] String name,
            [in] Byte value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The char data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharExtra(String, char)
         */
        PutCharExtraEx(
            [in] String name,
            [in] Char32 value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The short data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getShortExtra(String, short)
         */
        PutInt16ExtraEx(
            [in] String name,
            [in] Int16 value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The integer data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIntExtra(String, int)
         */
        PutInt32ExtraEx(
            [in] String name,
            [in] Int32 value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The long data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getLongExtra(String, long)
         */
        PutInt64ExtraEx(
            [in] String name,
            [in] Int64 value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The float data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getFloatExtra(String, float)
         */
        PutFloatExtraEx(
            [in] String name,
            [in] Float value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The double data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getDoubleExtra(String, double)
         */
        PutDoubleExtraEx(
            [in] String name,
            [in] Double value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The String data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getStringExtra(String)
         */
        PutStringExtraEx(
            [in] String name,
            [in] String value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The CharSequence data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharSequenceExtra(String)
         */
        PutCharSequenceExtra(
            [in] String name,
            [in] ICharSequence* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Parcelable data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getParcelableExtra(String)
         */
        PutParcelableExtraEx(
            [in] String name,
            [in] IParcelable* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Parcelable[] data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getParcelableArrayExtra(String)
         */
        PutParcelableArrayExtra(
            [in] String name,
            [in] ArrayOf<IParcelable*>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<Parcelable> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getParcelableArrayListExtra(String)
         */
        PutParcelableArrayListExtra(
            [in] String name,
            [in] IObjectContainer* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<Integer> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIntegerArrayListExtra(String)
         */
        PutIntegerArrayListExtra(
            [in] String name,
            [in] IObjectContainer* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<String> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getStringArrayListExtra(String)
         */
        PutStringArrayListExtra(
            [in] String name,
            [in] IObjectContainer* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<CharSequence> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharSequenceArrayListExtra(String)
         */
        PutCharSequenceArrayListExtra(
            [in] String name,
            [in] IObjectContainer* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Serializable data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getSerializableExtra(String)
         */
        // PutSerializableExtra(
        //     [in] String name,
        //     [in] ISerializable* value,
        //     [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The boolean array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getBooleanArrayExtra(String)
         */
        PutBooleanArrayExtra(
            [in] String name,
            [in] ArrayOf<Boolean>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The byte array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getByteArrayExtra(String)
         */
        PutByteArrayExtra(
            [in] String name,
            [in] ArrayOf<Byte>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The short array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getShortArrayExtra(String)
         */
        PutInt16ArrayExtra(
            [in] String name,
            [in] ArrayOf<Int16>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The char array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharArrayExtra(String)
         */
        PutCharArrayExtra(
            [in] String name,
            [in] ArrayOf<Char32>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The int array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIntArrayExtra(String)
         */
        PutInt32ArrayExtra(
            [in] String name,
            [in] ArrayOf<Int32>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The byte array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getLongArrayExtra(String)
         */
        PutInt64ArrayExtra(
            [in] String name,
            [in] ArrayOf<Int64>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The float array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getFloatArrayExtra(String)
         */
        PutFloatArrayExtra(
            [in] String name,
            [in] ArrayOf<Float>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The double array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getDoubleArrayExtra(String)
         */
        PutDoubleArrayExtra(
            [in] String name,
            [in] ArrayOf<Double>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The String array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getStringArrayExtra(String)
         */
        PutStringArrayExtra(
            [in] String name,
            [in] ArrayOf<String>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The CharSequence array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharSequenceArrayExtra(String)
         */
        PutCharSequenceArrayExtra(
            [in] String name,
            [in] ArrayOf<ICharSequence*>* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Bundle data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getBundleExtra(String)
         */
        PutBundleExtra(
            [in] String name,
            [in] IBundle* value,
            [out] IIntent** result);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The IBinder data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIBinderExtra(String)
         *
         * @deprecated
         * @hide
         */
        // @Deprecated
        // public Intent putExtra(String name, IBinder value);

        /**
         * Copy all extras in 'src' in to this intent.
         *
         * @param src Contains the extras to copy.
         *
         * @see #putExtra
         */
        PutExtras2(
            [in] IIntent* src,
            [out] IIntent** result);

        /**
         * Add a set of extended data to the intent.  The keys must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param extras The Bundle of extras to add to this intent.
         *
         * @see #putExtra
         * @see #removeExtra
         */
        PutExtrasEx(
            [in] IBundle* extras,
            [out] IIntent** result);

        /**
         * Completely replace the extras in the Intent with the extras in the
         * given Intent.
         *
         * @param src The exact extras contained in this Intent are copied
         * into the target intent, replacing any that were previously there.
         */
        ReplaceExtrasEx(
            [in] IIntent* src,
            [out] IIntent** result);

        /**
         * Completely replace the extras in the Intent with the given Bundle of
         * extras.
         *
         * @param extras The new set of extras in the Intent, or null to erase
         * all extras.
         */
        ReplaceExtras2(
            [in] IBundle* extras,
            [out] IIntent** result);

        /**
         * Remove extended data from the intent.
         *
         * @see #putExtra
         */
        RemoveExtra(
            [in] String name);

        /**
         * Set special flags controlling how this intent is handled.  Most values
         * here depend on the type of component being executed by the Intent,
         * specifically the FLAG_ACTIVITY_* flags are all for use with
         * {@link Context#startActivity Context.startActivity()} and the
         * FLAG_RECEIVER_* flags are all for use with
         * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
         *
         * <p>See the <a href="{@docRoot}guide/topics/fundamentals.html#acttask">Application Fundamentals:
         * Activities and Tasks</a> documentation for important information on how some of these options impact
         * the behavior of your application.
         *
         * @param flags The desired flags.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getFlags
         * @see #addFlags
         *
         * @see #FLAG_GRANT_READ_URI_PERMISSION
         * @see #FLAG_GRANT_WRITE_URI_PERMISSION
         * @see #FLAG_DEBUG_LOG_RESOLUTION
         * @see #FLAG_FROM_BACKGROUND
         * @see #FLAG_ACTIVITY_BROUGHT_TO_FRONT
         * @see #FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET
         * @see #FLAG_ACTIVITY_CLEAR_TOP
         * @see #FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
         * @see #FLAG_ACTIVITY_FORWARD_RESULT
         * @see #FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
         * @see #FLAG_ACTIVITY_MULTIPLE_TASK
         * @see #FLAG_ACTIVITY_NEW_TASK
         * @see #FLAG_ACTIVITY_NO_HISTORY
         * @see #FLAG_ACTIVITY_NO_USER_ACTION
         * @see #FLAG_ACTIVITY_PREVIOUS_IS_TOP
         * @see #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
         * @see #FLAG_ACTIVITY_SINGLE_TOP
         * @see #FLAG_RECEIVER_REGISTERED_ONLY
         */
        SetFlagsEx(
            [in] Int32 flags,
            [out] IIntent** result);

        /**
         * Add additional flags to the intent (or with existing flags
         * value).
         *
         * @param flags The new flags to set.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setFlags
         */
        AddFlagsEx(
            [in] Int32 flags,
            [out] IIntent** result);

        /**
         * (Usually optional) Set an explicit application package name that limits
         * the components this Intent will resolve to.  If left to the default
         * value of null, all components in all applications will considered.
         * If non-null, the Intent can only match the components in the given
         * application package.
         *
         * @param packageName The name of the application package to handle the
         * intent, or null to allow any application package.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getPackage
         * @see #resolveActivity
         */
        SetCapsule(
            [in] String capsuleName);

        /**
         * (Usually optional) Explicitly set the component to handle the intent.
         * If left with the default value of null, the system will determine the
         * appropriate class to use based on the other fields (action, data,
         * type, categories) in the Intent.  If this class is defined, the
         * specified class will always be used regardless of the other fields.  You
         * should only set this value when you know you absolutely want a specific
         * class to be used; otherwise it is better to let the system find the
         * appropriate class so that you will respect the installed applications
         * and user preferences.
         *
         * @param component The name of the application component to handle the
         * intent, or null to let the system find one for you.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setClass
         * @see #setClassName(Context, String)
         * @see #setClassName(String, String)
         * @see #getComponent
         * @see #resolveActivity
         */
        SetComponentEx(
            [in] IComponentName* component,
            [out] IIntent** result);

        /**
         * Convenience for calling {@link #setComponent} with an
         * explicit class name.
         *
         * @param packageContext A Context of the application package implementing
         * this class.
         * @param className The name of a class inside of the application package
         * that will be used as the component for this Intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setComponent
         * @see #setClass
         */
        SetClassName2(
            [in] IContext* packageContext,
            [in] String className,
            [out] IIntent** result);

        /**
         * Convenience for calling {@link #setComponent} with an
         * explicit application package name and class name.
         *
         * @param packageName The name of the package implementing the desired
         * component.
         * @param className The name of a class inside of the application package
         * that will be used as the component for this Intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setComponent
         * @see #setClass
         */
        SetClassNameEx(
            [in] String packageName,
            [in] String className,
            [out] IIntent** result);

        /**
         * Convenience for calling {@link #setComponent(ComponentName)} with the
         * name returned by a {@link Class} object.
         *
         * @param packageContext A Context of the application package implementing
         * this class.
         * @param cls The class name to set, equivalent to
         *            <code>setClassName(context, cls.getName())</code>.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setComponent
         */
        // TODO: ALEX
        // public Intent setClass(Context packageContext, Class<?> cls);

        /**
         * Set the bounds of the sender of this intent, in screen coordinates.  This can be
         * used as a hint to the receiver for animations and the like.  Null means that there
         * is no source bounds.
         */
        SetSourceBounds(
            [in] IRect* r);

        /**
         * Copy the contents of <var>other</var> in to this object, but only
         * where fields are not defined by this object.  For purposes of a field
         * being defined, the following pieces of data in the Intent are
         * considered to be separate fields:
         *
         * <ul>
         * <li> action, as set by {@link #setAction}.
         * <li> data URI and MIME type, as set by {@link #setData(Uri)},
         * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
         * <li> categories, as set by {@link #addCategory}.
         * <li> package, as set by {@link #setPackage}.
         * <li> component, as set by {@link #setComponent(ComponentName)} or
         * related methods.
         * <li> source bounds, as set by {@link #setSourceBounds}
         * <li> each top-level name in the associated extras.
         * </ul>
         *
         * <p>In addition, you can use the {@link #FILL_IN_ACTION},
         * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
         * and {@link #FILL_IN_COMPONENT} to override the restriction where the
         * corresponding field will not be replaced if it is already set.
         *
         * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT} is explicitly
         * specified.
         *
         * <p>For example, consider Intent A with {data="foo", categories="bar"}
         * and Intent B with {action="gotit", data-type="some/thing",
         * categories="one","two"}.
         *
         * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
         * containing: {action="gotit", data-type="some/thing",
         * categories="bar"}.
         *
         * @param other Another Intent whose values are to be used to fill in
         * the current one.
         * @param flags Options to control which fields can be filled in.
         *
         * @return Returns a bit mask of {@link #FILL_IN_ACTION},
         * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
         * and {@link #FILL_IN_COMPONENT} indicating which fields were changed.
         */
        FillIn(
            [in] IIntent* other,
            [in] Int32 flags,
            [out] Int32* result);

        /**
         * Determine if two intents are the same for the purposes of intent
         * resolution (filtering). That is, if their action, data, type,
         * class, and categories are the same.  This does <em>not</em> compare
         * any extra data included in the intents.
         *
         * @param other The other Intent to compare against.
         *
         * @return Returns true if action, data, type, class, and categories
         *         are the same.
         */
        FilterEquals(
            [in] IIntent* other,
            [out] Boolean* isEqual);

        /**
         * Generate hash code that matches semantics of filterEquals().
         *
         * @return Returns the hash value of the action, data, type, class, and
         *         categories.
         *
         * @see #filterEquals
         */
        FilterHashCode(
            [out] Int32* result);

        // @Override
        // public String toString();

        /** @hide */
        ToShortString(
            [in] Boolean comp,
            [in] Boolean extras,
            [out] String* result);

        /** @hide */
        ToShortString2(
            [in] String b,
            [in] Boolean comp,
            [in] Boolean extras);

        /**
         * Call {@link #toUri} with 0 flags.
         * @deprecated Use {@link #toUri} instead.
         */
        // @Deprecated
        // public String toURI();

        /**
         * Convert this Intent into a String holding a URI representation of it.
         * The returned URI string has been properly URI encoded, so it can be
         * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
         * Intent's data as the base URI, with an additional fragment describing
         * the action, categories, type, flags, package, component, and extras.
         *
         * <p>You can convert the returned string back to an Intent with
         * {@link #getIntent}.
         *
         * @param flags Additional operating flags.  Either 0 or
         * {@link #URI_INTENT_SCHEME}.
         *
         * @return Returns a URI encoding URI string describing the entire contents
         * of the Intent.
         */
        ToUri(
            [in] Int32 flags,
            [out] String* result);

        SetComponent(
            [in] IComponentName* component);

        SetAction(
            [in] String action);

        SetData(
            [in] IUri* data);

        SetType(
	        [in] String type);

        SetDataAndType(
	        [in] IUri* data,
	        [in] String type);

        SetFlags(
            [in] Int32 flags);

        AddFlags(
            [in] Int32 flags);

        SetClassName(
            [in] String capsuleName,
            [in] String className);

        AddCategory(
            [in] String category);

        PutBooleanExtra(
            [in] String name,
            [in] Boolean value);

        GetBooleanExtra(
            [in] String name,
            [out] Boolean* value);

        PutByteExtra(
            [in] String name,
            [in] Byte value);

        GetByteExtra(
            [in] String name,
            [out] Byte* value);

        PutCharExtra(
            [in] String name,
            [in] Char32 value);

        GetCharExtra(
            [in] String name,
            [out] Char32* value);

        PutInt16Extra(
            [in] String name,
            [in] Int16 value);

        GetInt16Extra(
            [in] String name,
            [out] Int16* value);

        PutInt32Extra(
            [in] String name,
            [in] Int32 value);

        GetInt32Extra(
            [in] String name,
            [out] Int32* value);

        PutInt64Extra(
            [in] String name,
            [in] Int64 value);

        GetInt64Extra(
            [in] String name,
            [out] Int64* value);

        PutFloatExtra(
            [in] String name,
            [in] Float value);

        GetFloatExtra(
            [in] String name,
            [out] Float* value);

        PutDoubleExtra(
            [in] String name,
            [in] Double value);

        GetDoubleExtra(
            [in] String name,
            [out] Double* value);

        PutStringExtra(
            [in] String name,
            [in] String value);

        PutExtras(
            [in] IBundle* extras);

        PutParcelableExtra(
            [in] String name,
            [in] IParcelable* value);

        /**
         * Completely replace the extras in the Intent with the extras in the
         * given Intent.
         *
         * @param src The exact extras contained in this Intent are copied
         * into the target intent, replacing any that were previously there.
         */
        ReplaceExtras(
            [in] IIntent* src);
    }
}

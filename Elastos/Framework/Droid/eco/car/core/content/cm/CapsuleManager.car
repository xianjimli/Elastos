
module
{
    /**
     * {@link PackageInfo} flag: return information about
     * activities in the package in {@link PackageInfo#activities}.
     */
    const CapsuleManager_GET_ACTIVITIES             = 0x00000001;

    /**
     * {@link PackageInfo} flag: return information about
     * intent receivers in the package in
     * {@link PackageInfo#receivers}.
     */
    const CapsuleManager_GET_RECEIVERS              = 0x00000002;

    /**
     * {@link PackageInfo} flag: return information about
     * services in the package in {@link PackageInfo#services}.
     */
    const CapsuleManager_GET_SERVICES               = 0x00000004;

    /**
     * {@link PackageInfo} flag: return information about
     * content providers in the package in
     * {@link PackageInfo#providers}.
     */
    const CapsuleManager_GET_PROVIDERS              = 0x00000008;

    /**
     * {@link PackageInfo} flag: return information about
     * instrumentation in the package in
     * {@link PackageInfo#instrumentation}.
     */
    const CapsuleManager_GET_INSTRUMENTATION        = 0x00000010;

    /**
     * {@link PackageInfo} flag: return information about the
     * intent filters supported by the activity.
     */
    const CapsuleManager_GET_INTENT_FILTERS          = 0x00000020;

    /**
     * {@link PackageInfo} flag: return information about the
     * signatures included in the package.
     */
    const CapsuleManager_GET_SIGNATURES             = 0x00000040;

    /**
     * {@link ResolveInfo} flag: return the IntentFilter that
     * was matched for a particular ResolveInfo in
     * {@link ResolveInfo#filter}.
     */
    const CapsuleManager_GET_RESOLVED_FILTER         = 0x00000040;

    /**
     * {@link ComponentInfo} flag: return the {@link ComponentInfo#metaData}
     * data {@link android.os.Bundle}s that are associated with a component.
     * This applies for any API returning a ComponentInfo subclass.
     */
    const CapsuleManager_GET_META_DATA               = 0x00000080;

    /**
     * {@link PackageInfo} flag: return the
     * {@link PackageInfo#gids group ids} that are associated with an
     * application.
     * This applies for any API returning an PackageInfo class, either
     * directly or nested inside of another.
     */
    const CapsuleManager_GET_GIDS                   = 0x00000100;

    /**
     * {@link PackageInfo} flag: include disabled components in the returned info.
     */
    const CapsuleManager_GET_DISABLED_COMPONENTS     = 0x00000200;

    /**
     * {@link ApplicationInfo} flag: return the
     * {@link ApplicationInfo#sharedLibraryFiles paths to the shared libraries}
     * that are associated with an application.
     * This applies for any API returning an ApplicationInfo class, either
     * directly or nested inside of another.
     */
    const CapsuleManager_GET_SHARED_LIBRARY_FILES   = 0x00000400;

    /**
     * {@link ProviderInfo} flag: return the
     * {@link ProviderInfo#uriPermissionPatterns URI permission patterns}
     * that are associated with a content provider.
     * This applies for any API returning an ProviderInfo class, either
     * directly or nested inside of another.
     */
    const CapsuleManager_GET_URI_PERMISSION_PATTERNS   = 0x00000800;

    /**
     * {@link PackageInfo} flag: return information about
     * permissions in the package in
     * {@link PackageInfo#permissions}.
     */
    const CapsuleManager_GET_PERMISSIONS            = 0x00001000;

    /**
     * Flag parameter to retrieve all applications(even uninstalled ones) with data directories.
     * This state could have resulted if applications have been deleted with flag
     * DONT_DELETE_DATA
     * with a possibility of being replaced or reinstalled in future
     */
    const CapsuleManager_GET_UNINSTALLED_CAPSULES   = 0x00002000;

    /**
     * {@link PackageInfo} flag: return information about
     * hardware preferences
     * {@link PackageInfo#configPreferences}
     */
    const CapsuleManager_GET_CONFIGURATIONS         = 0x00004000;

    /**
     * Resolution and querying flag: if set, only filters that support the
     * {@link android.content.Intent#CATEGORY_DEFAULT} will be considered for
     * matching.  This is a synonym for including the CATEGORY_DEFAULT in your
     * supplied Intent.
     */
    const CapsuleManager_MATCH_DEFAULT_ONLY         = 0x00010000;

    /**
     * Permission check result: this is returned by {@link #checkPermission}
     * if the permission has been granted to the given package.
     */
    const CapsuleManager_PERMISSION_GRANTED         = 0;

    /**
     * Permission check result: this is returned by {@link #checkPermission}
     * if the permission has not been granted to the given package.
     */
    const CapsuleManager_PERMISSION_DENIED          = -1;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if all signatures on the two packages match.
     */
    const CapsuleManager_SIGNATURE_MATCH = 0;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if neither of the two packages is signed.
     */
    const CapsuleManager_SIGNATURE_NEITHER_SIGNED = 1;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if the first package is not signed but the second is.
     */
    const CapsuleManager_SIGNATURE_FIRST_NOT_SIGNED = -1;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if the second package is not signed but the first is.
     */
    const CapsuleManager_SIGNATURE_SECOND_NOT_SIGNED = -2;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if not all signatures on both packages match.
     */
    const CapsuleManager_SIGNATURE_NO_MATCH = -3;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if either of the packages are not valid.
     */
    const CapsuleManager_SIGNATURE_UNKNOWN_CAPSULE = -4;

    const CapsuleManager_COMPONENT_ENABLED_STATE_DEFAULT = 0;
    const CapsuleManager_COMPONENT_ENABLED_STATE_ENABLED = 1;
    const CapsuleManager_COMPONENT_ENABLED_STATE_DISABLED = 2;

    /**
     * Flag parameter for {@link #deletePackage} to indicate that you don't want to delete the
     * package's data directory.
     *
     * @hide
     */
    const CapsuleManager_DONT_DELETE_DATA = 0x00000001;

    /**
     * Return code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * when the package has been successfully moved by the system.
     * @hide
     */
    const CapsuleManager_MOVE_SUCCEEDED = 1;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * when the package hasn't been successfully moved by the system
     * because of insufficient memory on specified media.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_INSUFFICIENT_STORAGE = -1;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package doesn't exist.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_DOESNT_EXIST = -2;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved since its a system package.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_SYSTEM_CAPSULE = -3;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved since its forward locked.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_FORWARD_LOCKED = -4;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved to the specified location.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_INVALID_LOCATION = -5;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved to the specified location.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_INTERNAL_ERROR = -6;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)} if the
     * specified package already has an operation pending in the
     * {@link PackageHandler} queue.
     *
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_OPERATION_PENDING = -7;

    /**
     * Flag parameter for {@link #movePackage} to indicate that
     * the package should be moved to internal storage if its
     * been installed on external media.
     * @hide
     */
    const CapsuleManager_MOVE_INTERNAL = 0x00000001;

    /**
     * Flag parameter for {@link #movePackage} to indicate that
     * the package should be moved to external media.
     * @hide
     */
    const CapsuleManager_MOVE_EXTERNAL_MEDIA = 0x00000002;


    interface ICapsuleInfo;
    interface IPermissionInfo;
    interface IObjectContainer;
    interface IPermissionGroupInfo;
    interface IApplicationInfo;
    interface IComponentName;
    interface IActivityInfo;
    interface IServiceInfo;
    interface IContentProviderInfo;
    interface IIntent;
    interface IResolveInfo;
    interface IInstrumentationInfo;
    interface IUri;
    interface ICapsuleInstallObserver;
    interface ICapsuleDeleteObserver;
    interface IIntentFilter;
    interface ICapsuleDataObserver;
    interface ICapsuleStatsObserver;
    interface IIntentSender;
    interface ICapsuleMoveObserver;

    [deprecated]
    interface ILocalCapsuleManager {
         /**
         * Retrieve overall information about an application package that is
         * installed on the system.
         *
         * <p>Throws {@link NameNotFoundException} if a package with the given
         * name can not be found on the system.
         *
         * @param packageName The full name (i.e. com.google.apps.contacts) of the
         *                    desired package.

         * @param flags Additional option flags. Use any combination of
         * {@link #GET_ACTIVITIES},
         * {@link #GET_GIDS},
         * {@link #GET_CONFIGURATIONS},
         * {@link #GET_INSTRUMENTATION},
         * {@link #GET_PERMISSIONS},
         * {@link #GET_PROVIDERS},
         * {@link #GET_RECEIVERS},
         * {@link #GET_SERVICES},
         * {@link #GET_SIGNATURES},
         * {@link #GET_UNINSTALLED_PACKAGES} to modify the data returned.
         *
         * @return Returns a PackageInfo object containing information about the package.
         *         If flag GET_UNINSTALLED_PACKAGES is set and  if the package is not
         *         found in the list of installed applications, the package information is
         *         retrieved from the list of uninstalled applications(which includes
         *         installed applications as well as applications
         *         with data directory ie applications which had been
         *         deleted with DONT_DELTE_DATA flag set).
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         * @see #GET_UNINSTALLED_PACKAGES
         *
         */
        GetCapsuleInfo(
            [in] String capsuleName,
            [in] Int32 flags,
            [out] ICapsuleInfo** capInfo);

        /**
         * Map from the current package names in use on the device to whatever
         * the current canonical name of that package is.
         * @param names Array of current names to be mapped.
         * @return Returns an array of the same size as the original, containing
         * the canonical name for each package.
         */
        CurrentToCanonicalCapsuleNames(
            [in] ArrayOf<String> names,
            [out, callee] ArrayOf<String>* cnames);

        /**
         * Map from a packages canonical name to the current name in use on the device.
         * @param names Array of new names to be mapped.
         * @return Returns an array of the same size as the original, containing
         * the current name for each package.
         */
        CanonicalToCurrentCapsuleNames(
            [in] ArrayOf<String> names,
            [out, callee] ArrayOf<String>* cnames);

        /**
         * Return a "good" intent to launch a front-door activity in a package,
         * for use for example to implement an "open" button when browsing through
         * packages.  The current implementation will look first for a main
         * activity in the category {@link Intent#CATEGORY_INFO}, next for a
         * main activity in the category {@link Intent#CATEGORY_LAUNCHER}, or return
         * null if neither are found.
         *
         * <p>Throws {@link NameNotFoundException} if a package with the given
         * name can not be found on the system.
         *
         * @param packageName The name of the package to inspect.
         *
         * @return Returns either a fully-qualified Intent that can be used to
         * launch the main activity in the package, or null if the package does
         * not contain such an activity.
         */
        GetLaunchIntentForCapsuel(
            [in] String capsuleName,
            [out] IIntent** intent);

        /**
         * Return an array of all of the secondary group-ids that have been
         * assigned to a package.
         *
         * <p>Throws {@link NameNotFoundException} if a package with the given
         * name can not be found on the system.
         *
         * @param packageName The full name (i.e. com.google.apps.contacts) of the
         *                    desired package.
         *
         * @return Returns an int array of the assigned gids, or null if there
         * are none.
         */
        GetCapsuleGids(
            [in] String capsuleName,
            [out, callee] ArrayOf<Int32>* gids);

        /**
         * Retrieve all of the information we know about a particular permission.
         *
         * <p>Throws {@link NameNotFoundException} if a permission with the given
         * name can not be found on the system.
         *
         * @param name The fully qualified name (i.e. com.google.permission.LOGIN)
         *             of the permission you are interested in.
         * @param flags Additional option flags.  Use {@link #GET_META_DATA} to
         * retrieve any meta-data associated with the permission.
         *
         * @return Returns a {@link PermissionInfo} containing information about the
         *         permission.
         */
        GetPermissionInfo(
            [in] String name,
            [in] Int32 flags,
            [out] IPermissionInfo** info);

        /**
         * Query for all of the permissions associated with a particular group.
         *
         * <p>Throws {@link NameNotFoundException} if the given group does not
         * exist.
         *
         * @param group The fully qualified name (i.e. com.google.permission.LOGIN)
         *             of the permission group you are interested in.  Use null to
         *             find all of the permissions not associated with a group.
         * @param flags Additional option flags.  Use {@link #GET_META_DATA} to
         * retrieve any meta-data associated with the permissions.
         *
         * @return Returns a list of {@link PermissionInfo} containing information
         * about all of the permissions in the given group.
         */
        QueryPermissionsByGroup(
            [in] String group,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Retrieve all of the information we know about a particular group of
         * permissions.
         *
         * <p>Throws {@link NameNotFoundException} if a permission group with the given
         * name can not be found on the system.
         *
         * @param name The fully qualified name (i.e. com.google.permission_group.APPS)
         *             of the permission you are interested in.
         * @param flags Additional option flags.  Use {@link #GET_META_DATA} to
         * retrieve any meta-data associated with the permission group.
         *
         * @return Returns a {@link PermissionGroupInfo} containing information
         * about the permission.
         */
        GetPermissionGroupInfo(
            [in] String name,
            [in] Int32 flags,
            [out] IPermissionGroupInfo** info);

        /**
         * Retrieve all of the known permission groups in the system.
         *
         * @param flags Additional option flags.  Use {@link #GET_META_DATA} to
         * retrieve any meta-data associated with the permission group.
         *
         * @return Returns a list of {@link PermissionGroupInfo} containing
         * information about all of the known permission groups.
         */
        GetAllPermissionGroups(
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Retrieve all of the information we know about a particular
         * package/application.
         *
         * <p>Throws {@link NameNotFoundException} if an application with the given
         * package name can not be found on the system.
         *
         * @param packageName The full name (i.e. com.google.apps.contacts) of an
         *                    application.
         * @param flags Additional option flags. Use any combination of
         * {@link #GET_META_DATA}, {@link #GET_SHARED_LIBRARY_FILES},
         * {@link #GET_UNINSTALLED_PACKAGES} to modify the data returned.
         *
         * @return  {@link ApplicationInfo} Returns ApplicationInfo object containing
         *         information about the package.
         *         If flag GET_UNINSTALLED_PACKAGES is set and  if the package is not
         *         found in the list of installed applications,
         *         the application information is retrieved from the
         *         list of uninstalled applications(which includes
         *         installed applications as well as applications
         *         with data directory ie applications which had been
         *         deleted with DONT_DELTE_DATA flag set).
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         * @see #GET_UNINSTALLED_PACKAGES
         */
        GetApplicationInfo(
            [in] String capsuleName,
            [in] Int32 flags,
            [out] IApplicationInfo** appInfo);

        /**
         * Retrieve all of the information we know about a particular activity
         * class.
         *
         * <p>Throws {@link NameNotFoundException} if an activity with the given
         * class name can not be found on the system.
         *
         * @param component The full component name (i.e.
         * com.google.apps.contacts/com.google.apps.contacts.ContactsList) of an Activity
         * class.
         * @param flags Additional option flags. Use any combination of
         * {@link #GET_META_DATA}, {@link #GET_SHARED_LIBRARY_FILES},
         * to modify the data (in ApplicationInfo) returned.
         *
         * @return {@link ActivityInfo} containing information about the activity.
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetActivityInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IActivityInfo** activityInfo);

        /**
         * Retrieve all of the information we know about a particular receiver
         * class.
         *
         * <p>Throws {@link NameNotFoundException} if a receiver with the given
         * class name can not be found on the system.
         *
         * @param component The full component name (i.e.
         * com.google.apps.calendar/com.google.apps.calendar.CalendarAlarm) of a Receiver
         * class.
         * @param flags Additional option flags.  Use any combination of
         * {@link #GET_META_DATA}, {@link #GET_SHARED_LIBRARY_FILES},
         * to modify the data returned.
         *
         * @return {@link ActivityInfo} containing information about the receiver.
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetReceiverInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IActivityInfo** info);

        /**
         * Retrieve all of the information we know about a particular service
         * class.
         *
         * <p>Throws {@link NameNotFoundException} if a service with the given
         * class name can not be found on the system.
         *
         * @param component The full component name (i.e.
         * com.google.apps.media/com.google.apps.media.BackgroundPlayback) of a Service
         * class.
         * @param flags Additional option flags.  Use any combination of
         * {@link #GET_META_DATA}, {@link #GET_SHARED_LIBRARY_FILES},
         * to modify the data returned.
         *
         * @return ServiceInfo containing information about the service.
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetServiceInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IServiceInfo** info);

        /**
         * Retrieve all of the information we know about a particular content
         * provider class.
         *
         * <p>Throws {@link NameNotFoundException} if a provider with the given
         * class name can not be found on the system.
         *
         * @param component The full component name (i.e.
         * com.google.providers.media/com.google.providers.media.MediaProvider) of a
         * ContentProvider class.
         * @param flags Additional option flags.  Use any combination of
         * {@link #GET_META_DATA}, {@link #GET_SHARED_LIBRARY_FILES},
         * to modify the data returned.
         *
         * @return ProviderInfo containing information about the service.
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetContentProviderInfo(
            [in] IComponentName* className,
            [in] Int32 flags,
            [out] IContentProviderInfo** info);

        /**
         * Return a List of all packages that are installed
         * on the device.
         *
         * @param flags Additional option flags. Use any combination of
         * {@link #GET_ACTIVITIES},
         * {@link #GET_GIDS},
         * {@link #GET_CONFIGURATIONS},
         * {@link #GET_INSTRUMENTATION},
         * {@link #GET_PERMISSIONS},
         * {@link #GET_PROVIDERS},
         * {@link #GET_RECEIVERS},
         * {@link #GET_SERVICES},
         * {@link #GET_SIGNATURES},
         * {@link #GET_UNINSTALLED_PACKAGES} to modify the data returned.
         *
         * @return A List of PackageInfo objects, one for each package that is
         *         installed on the device.  In the unlikely case of there being no
         *         installed packages, an empty list is returned.
         *         If flag GET_UNINSTALLED_PACKAGES is set, a list of all
         *         applications including those deleted with DONT_DELETE_DATA
         *         (partially installed apps with data directory) will be returned.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         * @see #GET_UNINSTALLED_PACKAGES
         *
         */
        GetInstalledCapsules(
            [in] Int32 flags,
            [out] IObjectContainer** caps);

        /**
         * Check whether a particular package has been granted a particular
         * permission.
         *
         * @param permName The name of the permission you are checking for,
         * @param pkgName The name of the package you are checking against.
         *
         * @return If the package has the permission, PERMISSION_GRANTED is
         * returned.  If it does not have the permission, PERMISSION_DENIED
         * is returned.
         *
         * @see #PERMISSION_GRANTED
         * @see #PERMISSION_DENIED
         */
        CheckPermission(
            [in] String permName,
            [in] String capName,
            [out] Int32* perm);

        /**
         * Add a new dynamic permission to the system.  For this to work, your
         * package must have defined a permission tree through the
         * {@link android.R.styleable#AndroidManifestPermissionTree
         * &lt;permission-tree&gt;} tag in its manifest.  A package can only add
         * permissions to trees that were defined by either its own package or
         * another with the same user id; a permission is in a tree if it
         * matches the name of the permission tree + ".": for example,
         * "com.foo.bar" is a member of the permission tree "com.foo".
         *
         * <p>It is good to make your permission tree name descriptive, because you
         * are taking possession of that entire set of permission names.  Thus, it
         * must be under a domain you control, with a suffix that will not match
         * any normal permissions that may be declared in any applications that
         * are part of that domain.
         *
         * <p>New permissions must be added before
         * any .apks are installed that use those permissions.  Permissions you
         * add through this method are remembered across reboots of the device.
         * If the given permission already exists, the info you supply here
         * will be used to update it.
         *
         * @param info Description of the permission to be added.
         *
         * @return Returns true if a new permission was created, false if an
         * existing one was updated.
         *
         * @throws SecurityException if you are not allowed to add the
         * given permission name.
         *
         * @see #removePermission(String)
         */
        AddPermission(
            [in] IPermissionInfo* info,
            [out] Boolean* isAdded);

        /**
         * Like {@link #addPermission(PermissionInfo)} but asynchronously
         * persists the package manager state after returning from the call,
         * allowing it to return quicker and batch a series of adds at the
         * expense of no guarantee the added permission will be retained if
         * the device is rebooted before it is written.
         */
        AddPermissionAsync(
            [in] IPermissionInfo* info,
            [out] Boolean* isAdded);

        /**
         * Removes a permission that was previously added with
         * {@link #addPermission(PermissionInfo)}.  The same ownership rules apply
         * -- you are only allowed to remove permissions that you are allowed
         * to add.
         *
         * @param name The name of the permission to remove.
         *
         * @throws SecurityException if you are not allowed to remove the
         * given permission name.
         *
         * @see #addPermission(PermissionInfo)
         */
        RemovePermission(
            [in] String name);

        /**
         * Compare the signatures of two packages to determine if the same
         * signature appears in both of them.  If they do contain the same
         * signature, then they are allowed special privileges when working
         * with each other: they can share the same user-id, run instrumentation
         * against each other, etc.
         *
         * @param pkg1 First package name whose signature will be compared.
         * @param pkg2 Second package name whose signature will be compared.
         *
         * @return Returns an integer indicating whether all signatures on the
         * two packages match. The value is >= 0 ({@link #SIGNATURE_MATCH}) if
         * all signatures match or < 0 if there is not a match ({@link
         * #SIGNATURE_NO_MATCH} or {@link #SIGNATURE_UNKNOWN_PACKAGE}).
         *
         * @see #checkSignatures(int, int)
         * @see #SIGNATURE_MATCH
         * @see #SIGNATURE_NO_MATCH
         * @see #SIGNATURE_UNKNOWN_PACKAGE
         */
        CheckSignatures(
            [in] String cap1,
            [in] String cap2,
            [out] Int32* sig);

        /**
         * Like {@link #checkSignatures(String, String)}, but takes UIDs of
         * the two packages to be checked.  This can be useful, for example,
         * when doing the check in an IPC, where the UID is the only identity
         * available.  It is functionally identical to determining the package
         * associated with the UIDs and checking their signatures.
         *
         * @param uid1 First UID whose signature will be compared.
         * @param uid2 Second UID whose signature will be compared.
         *
         * @return Returns an integer indicating whether all signatures on the
         * two packages match. The value is >= 0 ({@link #SIGNATURE_MATCH}) if
         * all signatures match or < 0 if there is not a match ({@link
         * #SIGNATURE_NO_MATCH} or {@link #SIGNATURE_UNKNOWN_PACKAGE}).
         *
         * @see #checkSignatures(String, String)
         * @see #SIGNATURE_MATCH
         * @see #SIGNATURE_NO_MATCH
         * @see #SIGNATURE_UNKNOWN_PACKAGE
         */
        CheckUidSignatures(
            [in] Int32 uid1,
            [in] Int32 uid2,
            [out] Int32* sig);

        /**
         * Retrieve the names of all packages that are associated with a particular
         * user id.  In most cases, this will be a single package name, the package
         * that has been assigned that user id.  Where there are multiple packages
         * sharing the same user id through the "sharedUserId" mechanism, all
         * packages with that id will be returned.
         *
         * @param uid The user id for which you would like to retrieve the
         * associated packages.
         *
         * @return Returns an array of one or more packages assigned to the user
         * id, or null if there are no known packages with the given id.
         */
        GetCapsulesForUid(
            [in] Int32 uid,
            [out, callee] ArrayOf<String>* capsules);

        /**
         * Retrieve the official name associated with a user id.  This name is
         * guaranteed to never change, though it is possibly for the underlying
         * user id to be changed.  That is, if you are storing information about
         * user ids in persistent storage, you should use the string returned
         * by this function instead of the raw user-id.
         *
         * @param uid The user id for which you would like to retrieve a name.
         * @return Returns a unique name for the given user id, or null if the
         * user id is not currently assigned.
         */
        GetNameForUid(
            [in] Int32 uid,
            [out] String* name);

        /**
         * Return the user id associated with a shared user name. Multiple
         * applications can specify a shared user name in their manifest and thus
         * end up using a common uid. This might be used for new applications
         * that use an existing shared user name and need to know the uid of the
         * shared user.
         *
         * @param sharedUserName The shared user name whose uid is to be retrieved.
         * @return Returns the uid associated with the shared user, or  NameNotFoundException
         * if the shared user name is not being used by any installed packages
         * @hide
         */
        GetUidForSharedUser(
            [in] String sharedUserName,
            [out] Int32* uid);

        /**
         * Return a List of all application packages that are installed on the
         * device. If flag GET_UNINSTALLED_PACKAGES has been set, a list of all
         * applications including those deleted with DONT_DELETE_DATA(partially
         * installed apps with data directory) will be returned.
         *
         * @param flags Additional option flags. Use any combination of
         * {@link #GET_META_DATA}, {@link #GET_SHARED_LIBRARY_FILES},
         * {link #GET_UNINSTALLED_PACKAGES} to modify the data returned.
         *
         * @return A List of ApplicationInfo objects, one for each application that
         *         is installed on the device.  In the unlikely case of there being
         *         no installed applications, an empty list is returned.
         *         If flag GET_UNINSTALLED_PACKAGES is set, a list of all
         *         applications including those deleted with DONT_DELETE_DATA
         *         (partially installed apps with data directory) will be returned.
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         * @see #GET_UNINSTALLED_PACKAGES
         */
        GetInstalledApplications(
            [in] Int32 flags,
            [out] IObjectContainer** apps);

        /**
         * Get a list of shared libraries that are available on the
         * system.
         *
         * @return An array of shared library names that are
         * available on the system, or null if none are installed.
         *
         */
        GetSystemSharedLibraryNames(
            [out, callee] ArrayOf<String>* names);

        /**
         * Get a list of features that are available on the
         * system.
         *
         * @return An array of FeatureInfo classes describing the features
         * that are available on the system, or null if there are none(!!).
         */
        GetSystemAvailableFeatures(
            [out] IObjectContainer** infos);

        /**
         * Check whether the given feature name is one of the available
         * features as returned by {@link #getSystemAvailableFeatures()}.
         *
         * @return Returns true if the devices supports the feature, else
         * false.
         */
        HasSystemFeature(
            [in] String name,
            [out] Boolean* result);

        /**
         * Determine the best action to perform for a given Intent.  This is how
         * {@link Intent#resolveActivity} finds an activity if a class has not
         * been explicitly specified.
         *
         * <p><em>Note: if using an implicit Intent (without an explicit ComponentName
         * specified), be sure to consider whether to set the {@link #MATCH_DEFAULT_ONLY}
         * only flag.  You need to do so to resolve the activity in the same way
         * that {@link android.content.Context#startActivity(Intent)} and
         * {@link android.content.Intent#resolveActivity(PackageManager)
         * Intent.resolveActivity(PackageManager)} do.</p>
         *
         * @param intent An intent containing all of the desired specification
         *               (action, data, type, category, and/or component).
         * @param flags Additional option flags.  The most important is
         * {@link #MATCH_DEFAULT_ONLY}, to limit the resolution to only
         * those activities that support the {@link android.content.Intent#CATEGORY_DEFAULT}.
         *
         * @return Returns a ResolveInfo containing the final activity intent that
         *         was determined to be the best action.  Returns null if no
         *         matching activity was found. If multiple matching activities are
         *         found and there is no default set, returns a ResolveInfo
         *         containing something else, such as the activity resolver.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        ResolveActivity(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IResolveInfo** resolveInfo);

        /**
         * Retrieve all activities that can be performed for the given intent.
         *
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.  The most important is
         * {@link #MATCH_DEFAULT_ONLY}, to limit the resolution to only
         * those activities that support the {@link android.content.Intent#CATEGORY_DEFAULT}.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Activity. These are ordered from best to worst match -- that
         *         is, the first item in the list is what is returned by
         *         {@link #resolveActivity}.  If there are no matching activities, an empty
         *         list is returned.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryIntentActivities(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Retrieve a set of activities that should be presented to the user as
         * similar options.  This is like {@link #queryIntentActivities}, except it
         * also allows you to supply a list of more explicit Intents that you would
         * like to resolve to particular options, and takes care of returning the
         * final ResolveInfo list in a reasonable order, with no duplicates, based
         * on those inputs.
         *
         * @param caller The class name of the activity that is making the
         *               request.  This activity will never appear in the output
         *               list.  Can be null.
         * @param specifics An array of Intents that should be resolved to the
         *                  first specific results.  Can be null.
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.  The most important is
         * {@link #MATCH_DEFAULT_ONLY}, to limit the resolution to only
         * those activities that support the {@link android.content.Intent#CATEGORY_DEFAULT}.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Activity. These are ordered first by all of the intents resolved
         *         in <var>specifics</var> and then any additional activities that
         *         can handle <var>intent</var> but did not get included by one of
         *         the <var>specifics</var> intents.  If there are no matching
         *         activities, an empty list is returned.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryIntentActivityOptions(
            [in] IComponentName* caller,
            [in] ArrayOf<IIntent*>* specifics,
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Retrieve all receivers that can handle a broadcast of the given intent.
         *
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Receiver. These are ordered from first to last in priority.  If
         *         there are no matching receivers, an empty list is returned.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryBroadcastReceivers(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Determine the best service to handle for a given Intent.
         *
         * @param intent An intent containing all of the desired specification
         *               (action, data, type, category, and/or component).
         * @param flags Additional option flags.
         *
         * @return Returns a ResolveInfo containing the final service intent that
         *         was determined to be the best action.  Returns null if no
         *         matching service was found.
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        ResolveService(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IResolveInfo** resolveInfo);

        /**
         * Retrieve all services that can match the given intent.
         *
         * @param intent The desired intent as per resolveService().
         * @param flags Additional option flags.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         ServiceInfo. These are ordered from best to worst match -- that
         *         is, the first item in the list is what is returned by
         *         resolveService().  If there are no matching services, an empty
         *         list is returned.
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryIntentServices(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Find a single content provider by its base path name.
         *
         * @param name The name of the provider to find.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return ContentProviderInfo Information about the provider, if found,
         *         else null.
         */
        ResolveContentProvider(
            [in] String name,
            [in] Int32 flags,
            [out] IContentProviderInfo** info);

        /**
         * Retrieve content provider information.
         *
         * <p><em>Note: unlike most other methods, an empty result set is indicated
         * by a null return instead of an empty list.</em>
         *
         * @param processName If non-null, limits the returned providers to only
         *                    those that are hosted by the given process.  If null,
         *                    all content providers are returned.
         * @param uid If <var>processName</var> is non-null, this is the required
         *        uid owning the requested content providers.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return A List&lt;ContentProviderInfo&gt; containing one entry for each
         *         content provider either patching <var>processName</var> or, if
         *         <var>processName</var> is null, all known content providers.
         *         <em>If there are no matching providers, null is returned.</em>
         */
        QueryContentProviders(
            [in] String processName,
            [in] Int32 uid,
            [in] Int32 flags,
            [out] IObjectContainer** providers);

        /**
         * Retrieve all of the information we know about a particular
         * instrumentation class.
         *
         * <p>Throws {@link NameNotFoundException} if instrumentation with the
         * given class name can not be found on the system.
         *
         * @param className The full name (i.e.
         *                  com.google.apps.contacts.InstrumentList) of an
         *                  Instrumentation class.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return InstrumentationInfo containing information about the
         *         instrumentation.
         */
        GetInstrumentationInfo(
            [in] IComponentName* className,
            [in] Int32 flags,
            [out] IInstrumentationInfo** info);

        /**
         * Retrieve information about available instrumentation code.  May be used
         * to retrieve either all instrumentation code, or only the code targeting
         * a particular package.
         *
         * @param targetPackage If null, all instrumentation is returned; only the
         *                      instrumentation targeting this package name is
         *                      returned.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return A List&lt;InstrumentationInfo&gt; containing one entry for each
         *         matching available Instrumentation.  Returns an empty list if
         *         there is no instrumentation available for the given package.
         */
        QueryInstrumentation(
            [in] String targetCapsule,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Retrieve an image from a package.  This is a low-level API used by
         * the various package manager info structures (such as
         * {@link ComponentInfo} to implement retrieval of their associated
         * icon.
         *
         * @param packageName The name of the package that this icon is coming from.
         * Can not be null.
         * @param resid The resource identifier of the desired image.  Can not be 0.
         * @param appInfo Overall information about <var>packageName</var>.  This
         * may be null, in which case the application information will be retrieved
         * for you if needed; if you already have this information around, it can
         * be much more efficient to supply it here.
         *
         * @return Returns a Drawable holding the requested image.  Returns null if
         * an image could not be found for any reason.
         */
        GetDrawable(
            [in] String capsuleName,
            [in] Int32 resid,
            [in] IApplicationInfo* appInfo,
            [out] IDrawable** drawable);

        /**
         * Retrieve the icon associated with an activity.  Given the full name of
         * an activity, retrieves the information about it and calls
         * {@link ComponentInfo#loadIcon ComponentInfo.loadIcon()} to return its icon.
         * If the activity can not be found, NameNotFoundException is thrown.
         *
         * @param activityName Name of the activity whose icon is to be retrieved.
         *
         * @return Returns the image of the icon, or the default activity icon if
         * it could not be found.  Does not return null.
         * @throws NameNotFoundException Thrown if the resources for the given
         * activity could not be loaded.
         *
         * @see #getActivityIcon(Intent)
         */
        GetActivityIcon(
            [in] IComponentName* activityName,
            [out] IDrawable** icon);

        /**
         * Retrieve the icon associated with an Intent.  If intent.getClassName() is
         * set, this simply returns the result of
         * getActivityIcon(intent.getClassName()).  Otherwise it resolves the intent's
         * component and returns the icon associated with the resolved component.
         * If intent.getClassName() can not be found or the Intent can not be resolved
         * to a component, NameNotFoundException is thrown.
         *
         * @param intent The intent for which you would like to retrieve an icon.
         *
         * @return Returns the image of the icon, or the default activity icon if
         * it could not be found.  Does not return null.
         * @throws NameNotFoundException Thrown if the resources for application
         * matching the given intent could not be loaded.
         *
         * @see #getActivityIcon(ComponentName)
         */
        GetActivityIconEx(
            [in] IIntent* intent,
            [out] IDrawable** icon);

        /**
         * Return the generic icon for an activity that is used when no specific
         * icon is defined.
         *
         * @return Drawable Image of the icon.
         */
        GetDefaultActivityIcon(
            [out] IDrawable** icon);

        /**
         * Retrieve the icon associated with an application.  If it has not defined
         * an icon, the default app icon is returned.  Does not return null.
         *
         * @param info Information about application being queried.
         *
         * @return Returns the image of the icon, or the default application icon
         * if it could not be found.
         *
         * @see #getApplicationIcon(String)
         */
        GetApplicationIcon(
            [in] IApplicationInfo* info,
            [out] IDrawable** icon);

        /**
         * Retrieve the icon associated with an application.  Given the name of the
         * application's package, retrieves the information about it and calls
         * getApplicationIcon() to return its icon. If the application can not be
         * found, NameNotFoundException is thrown.
         *
         * @param packageName Name of the package whose application icon is to be
         *                    retrieved.
         *
         * @return Returns the image of the icon, or the default application icon
         * if it could not be found.  Does not return null.
         * @throws NameNotFoundException Thrown if the resources for the given
         * application could not be loaded.
         *
         * @see #getApplicationIcon(ApplicationInfo)
         */
        GetApplicationIconEx(
            [in] String capsuleName,
            [out] IDrawable** icon);

        /**
         * Retrieve the logo associated with an activity.  Given the full name of
         * an activity, retrieves the information about it and calls
         * {@link ComponentInfo#loadLogo ComponentInfo.loadLogo()} to return its logo.
         * If the activity can not be found, NameNotFoundException is thrown.
         *
         * @param activityName Name of the activity whose logo is to be retrieved.
         *
         * @return Returns the image of the logo or null if the activity has no
         * logo specified.
         *
         * @throws NameNotFoundException Thrown if the resources for the given
         * activity could not be loaded.
         *
         * @see #getActivityLogo(Intent)
         */
        GetActivityLogo(
            [in] IComponentName* activityName,
            [out] IDrawable** logo);

        /**
         * Retrieve the logo associated with an Intent.  If intent.getClassName() is
         * set, this simply returns the result of
         * getActivityLogo(intent.getClassName()).  Otherwise it resolves the intent's
         * component and returns the logo associated with the resolved component.
         * If intent.getClassName() can not be found or the Intent can not be resolved
         * to a component, NameNotFoundException is thrown.
         *
         * @param intent The intent for which you would like to retrieve a logo.
         *
         * @return Returns the image of the logo, or null if the activity has no
         * logo specified.
         *
         * @throws NameNotFoundException Thrown if the resources for application
         * matching the given intent could not be loaded.
         *
         * @see #getActivityLogo(ComponentName)
         */
        GetActivityLogoEx(
            [in] IIntent* intent,
            [out] IDrawable** logo);

        /**
         * Retrieve the logo associated with an application.  If it has not specified
         * a logo, this method returns null.
         *
         * @param info Information about application being queried.
         *
         * @return Returns the image of the logo, or null if no logo is specified
         * by the application.
         *
         * @see #getApplicationLogo(String)
         */
        GetApplicationLogo(
            [in] IApplicationInfo* info,
            [out] IDrawable** logo);

        /**
         * Retrieve the logo associated with an application.  Given the name of the
         * application's package, retrieves the information about it and calls
         * getApplicationLogo() to return its logo. If the application can not be
         * found, NameNotFoundException is thrown.
         *
         * @param packageName Name of the package whose application logo is to be
         *                    retrieved.
         *
         * @return Returns the image of the logo, or null if no application logo
         * has been specified.
         *
         * @throws NameNotFoundException Thrown if the resources for the given
         * application could not be loaded.
         *
         * @see #getApplicationLogo(ApplicationInfo)
         */
        GetApplicationLogoEx(
            [in] String capsuleName,
            [out] IDrawable** logo);

        /**
         * Retrieve text from a package.  This is a low-level API used by
         * the various package manager info structures (such as
         * {@link ComponentInfo} to implement retrieval of their associated
         * labels and other text.
         *
         * @param packageName The name of the package that this text is coming from.
         * Can not be null.
         * @param resid The resource identifier of the desired text.  Can not be 0.
         * @param appInfo Overall information about <var>packageName</var>.  This
         * may be null, in which case the application information will be retrieved
         * for you if needed; if you already have this information around, it can
         * be much more efficient to supply it here.
         *
         * @return Returns a CharSequence holding the requested text.  Returns null
         * if the text could not be found for any reason.
         */
        GetText(
            [in] String capsuleName,
            [in] Int32 resid,
            [in] IApplicationInfo* appInfo,
            [out] ICharSequence** text);

        /**
         * Retrieve an XML file from a package.  This is a low-level API used to
         * retrieve XML meta data.
         *
         * @param packageName The name of the package that this xml is coming from.
         * Can not be null.
         * @param resid The resource identifier of the desired xml.  Can not be 0.
         * @param appInfo Overall information about <var>packageName</var>.  This
         * may be null, in which case the application information will be retrieved
         * for you if needed; if you already have this information around, it can
         * be much more efficient to supply it here.
         *
         * @return Returns an XmlPullParser allowing you to parse out the XML
         * data.  Returns null if the xml resource could not be found for any
         * reason.
         */
        GetXml(
            [in] String capsuleName,
            [in] Int32 resid,
            [in] IApplicationInfo* appInfo,
            [out] IXmlResourceParser** parser);

        /**
         * Return the label to use for this application.
         *
         * @return Returns the label associated with this application, or null if
         * it could not be found for any reason.
         * @param info The application to get the label of
         */
        GetApplicationLabel(
            [in] IApplicationInfo* info,
            [out] ICharSequence** label);

        /**
         * Retrieve the resources associated with an activity.  Given the full
         * name of an activity, retrieves the information about it and calls
         * getResources() to return its application's resources.  If the activity
         * can not be found, NameNotFoundException is thrown.
         *
         * @param activityName Name of the activity whose resources are to be
         *                     retrieved.
         *
         * @return Returns the application's Resources.
         * @throws NameNotFoundException Thrown if the resources for the given
         * application could not be loaded.
         *
         * @see #getResourcesForApplication(ApplicationInfo)
         */
        GetResourcesForActivity(
            [in] IComponentName* activityName,
            [out] IResources** res);

        /**
         * Retrieve the resources for an application.  Throws NameNotFoundException
         * if the package is no longer installed.
         *
         * @param app Information about the desired application.
         *
         * @return Returns the application's Resources.
         * @throws NameNotFoundException Thrown if the resources for the given
         * application could not be loaded (most likely because it was uninstalled).
         */
        GetResourcesForApplication(
            [in] IApplicationInfo* app,
            [out] IResources** res);

        /**
         * Retrieve the resources associated with an application.  Given the full
         * package name of an application, retrieves the information about it and
         * calls getResources() to return its application's resources.  If the
         * appPackageName can not be found, NameNotFoundException is thrown.
         *
         * @param appPackageName Package name of the application whose resources
         *                       are to be retrieved.
         *
         * @return Returns the application's Resources.
         * @throws NameNotFoundException Thrown if the resources for the given
         * application could not be loaded.
         *
         * @see #getResourcesForApplication(ApplicationInfo)
         */
        GetResourcesForApplicationEx(
            [in] String appCapsuleName,
            [out] IResources** res);

        /**
         * Retrieve overall information about an application package defined
         * in a package archive file
         *
         * @param archiveFilePath The path to the archive file
         * @param flags Additional option flags. Use any combination of
         * {@link #GET_ACTIVITIES},
         * {@link #GET_GIDS},
         * {@link #GET_CONFIGURATIONS},
         * {@link #GET_INSTRUMENTATION},
         * {@link #GET_PERMISSIONS},
         * {@link #GET_PROVIDERS},
         * {@link #GET_RECEIVERS},
         * {@link #GET_SERVICES},
         * {@link #GET_SIGNATURES}, to modify the data returned.
         *
         * @return Returns the information about the package. Returns
         * null if the package could not be successfully parsed.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         *
         */
        GetCapsuleArchiveInfo(
            [in] String archiveFilePath,
            [in] Int32 flags,
            [out] ICapsuleInfo** info);

        /**
         * @hide
         *
         * Install a package. Since this may take a little while, the result will
         * be posted back to the given observer.  An installation will fail if the calling context
         * lacks the {@link android.Manifest.permission#INSTALL_PACKAGES} permission, if the
         * package named in the package file's manifest is already installed, or if there's no space
         * available on the device.
         *
         * @param packageURI The location of the package file to install.  This can be a 'file:' or a
         * 'content:' URI.
         * @param observer An observer callback to get notified when the package installation is
         * complete. {@link IPackageInstallObserver#packageInstalled(String, int)} will be
         * called when that happens.  observer may be null to indicate that no callback is desired.
         * @param flags - possible values: {@link #INSTALL_FORWARD_LOCK},
         * {@link #INSTALL_REPLACE_EXISTING}, {@link #INSTALL_ALLOW_TEST}.
         * @param installerPackageName Optional package name of the application that is performing the
         * installation. This identifies which market the package came from.
         */
        InstallCapsule(
            [in] IUri* capsuleURI,
            [in] ICapsuleInstallObserver* observer,
            [in] Int32 flags,
            [in] String installerCapsuleName);

        /**
         * Attempts to delete a package.  Since this may take a little while, the result will
         * be posted back to the given observer.  A deletion will fail if the calling context
         * lacks the {@link android.Manifest.permission#DELETE_PACKAGES} permission, if the
         * named package cannot be found, or if the named package is a "system package".
         * (TODO: include pointer to documentation on "system packages")
         *
         * @param packageName The name of the package to delete
         * @param observer An observer callback to get notified when the package deletion is
         * complete. {@link android.content.pm.IPackageDeleteObserver#packageDeleted(boolean)} will be
         * called when that happens.  observer may be null to indicate that no callback is desired.
         * @param flags - possible values: {@link #DONT_DELETE_DATA}
         *
         * @hide
         */
        DeleteCapsule(
            [in] String capsuleName,
            [in] ICapsuleDeleteObserver* observer,
            [in] Int32 flags);

        /**
         * Retrieve the package name of the application that installed a package. This identifies
         * which market the package came from.
         *
         * @param packageName The name of the package to query
         */
        GetInstallerCapsuleName(
            [in] String capsuleName,
            [out] String* name);

        /**
         * Attempts to clear the user data directory of an application.
         * Since this may take a little while, the result will
         * be posted back to the given observer.  A deletion will fail if the
         * named package cannot be found, or if the named package is a "system package".
         *
         * @param packageName The name of the package
         * @param observer An observer callback to get notified when the operation is finished
         * {@link android.content.pm.IPackageDataObserver#onRemoveCompleted(String, boolean)}
         * will be called when that happens.  observer may be null to indicate that
         * no callback is desired.
         *
         * @hide
         */
        ClearApplicationUserData(
            [in] String capsuleName,
            [in] ICapsuleDataObserver* observer);

        /**
         * Attempts to delete the cache files associated with an application.
         * Since this may take a little while, the result will
         * be posted back to the given observer.  A deletion will fail if the calling context
         * lacks the {@link android.Manifest.permission#DELETE_CACHE_FILES} permission, if the
         * named package cannot be found, or if the named package is a "system package".
         *
         * @param packageName The name of the package to delete
         * @param observer An observer callback to get notified when the cache file deletion
         * is complete.
         * {@link android.content.pm.IPackageDataObserver#onRemoveCompleted(String, boolean)}
         * will be called when that happens.  observer may be null to indicate that
         * no callback is desired.
         *
         * @hide
         */
        DeleteApplicationCacheFiles(
            [in] String capsuleName,
            [in] ICapsuleDataObserver* observer);

        /**
         * Free storage by deleting LRU sorted list of cache files across
         * all applications. If the currently available free storage
         * on the device is greater than or equal to the requested
         * free storage, no cache files are cleared. If the currently
         * available storage on the device is less than the requested
         * free storage, some or all of the cache files across
         * all applications are deleted (based on last accessed time)
         * to increase the free storage space on the device to
         * the requested value. There is no guarantee that clearing all
         * the cache files from all applications will clear up
         * enough storage to achieve the desired value.
         * @param freeStorageSize The number of bytes of storage to be
         * freed by the system. Say if freeStorageSize is XX,
         * and the current free storage is YY,
         * if XX is less than YY, just return. if not free XX-YY number
         * of bytes if possible.
         * @param observer call back used to notify when
         * the operation is completed
         *
         * @hide
         */
        FreeStorageAndNotify(
            [in] Int64 freeStorageSize,
            [in] ICapsuleDataObserver* observer);

        /**
         * Free storage by deleting LRU sorted list of cache files across
         * all applications. If the currently available free storage
         * on the device is greater than or equal to the requested
         * free storage, no cache files are cleared. If the currently
         * available storage on the device is less than the requested
         * free storage, some or all of the cache files across
         * all applications are deleted (based on last accessed time)
         * to increase the free storage space on the device to
         * the requested value. There is no guarantee that clearing all
         * the cache files from all applications will clear up
         * enough storage to achieve the desired value.
         * @param freeStorageSize The number of bytes of storage to be
         * freed by the system. Say if freeStorageSize is XX,
         * and the current free storage is YY,
         * if XX is less than YY, just return. if not free XX-YY number
         * of bytes if possible.
         * @param pi IntentSender call back used to
         * notify when the operation is completed.May be null
         * to indicate that no call back is desired.
         *
         * @hide
         */
        FreeStorage(
            [in] Int64 freeStorageSize,
            [in] IIntentSender* pi);

        /**
         * Retrieve the size information for a package.
         * Since this may take a little while, the result will
         * be posted back to the given observer.  The calling context
         * should have the {@link android.Manifest.permission#GET_PACKAGE_SIZE} permission.
         *
         * @param packageName The name of the package whose size information is to be retrieved
         * @param observer An observer callback to get notified when the operation
         * is complete.
         * {@link android.content.pm.IPackageStatsObserver#onGetStatsCompleted(PackageStats, boolean)}
         * The observer's callback is invoked with a PackageStats object(containing the
         * code, data and cache sizes of the package) and a boolean value representing
         * the status of the operation. observer may be null to indicate that
         * no callback is desired.
         *
         * @hide
         */
        GetCapsuleSizeInfo(
            [in] String capsuleName,
            [in/*, out */] ICapsuleStatsObserver* observer);

        /**
         * @deprecated This function no longer does anything; it was an old
         * approach to managing preferred activities, which has been superceeded
         * (and conflicts with) the modern activity-based preferences.
         */
        //@Deprecated
        AddCapsuleToPreferred(
            [in] String capsuleName);

        /**
         * @deprecated This function no longer does anything; it was an old
         * approach to managing preferred activities, which has been superceeded
         * (and conflicts with) the modern activity-based preferences.
         */
        //@Deprecated
        RemoveCapsuleFromPreferred(
            [in] String capsuleName);

        /**
         * Retrieve the list of all currently configured preferred packages.  The
         * first package on the list is the most preferred, the last is the
         * least preferred.
         *
         * @param flags Additional option flags. Use any combination of
         * {@link #GET_ACTIVITIES},
         * {@link #GET_GIDS},
         * {@link #GET_CONFIGURATIONS},
         * {@link #GET_INSTRUMENTATION},
         * {@link #GET_PERMISSIONS},
         * {@link #GET_PROVIDERS},
         * {@link #GET_RECEIVERS},
         * {@link #GET_SERVICES},
         * {@link #GET_SIGNATURES}, to modify the data returned.
         *
         * @return Returns a list of PackageInfo objects describing each
         * preferred application, in order of preference.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         */
        GetPreferredCapsules(
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * @deprecated This is a protected API that should not have been available
         * to third party applications.  It is the platform's responsibility for
         * assigning preferred activities and this can not be directly modified.
         *
         * Add a new preferred activity mapping to the system.  This will be used
         * to automatically select the given activity component when
         * {@link Context#startActivity(Intent) Context.startActivity()} finds
         * multiple matching activities and also matches the given filter.
         *
         * @param filter The set of intents under which this activity will be
         * made preferred.
         * @param match The IntentFilter match category that this preference
         * applies to.
         * @param set The set of activities that the user was picking from when
         * this preference was made.
         * @param activity The component name of the activity that is to be
         * preferred.
         */
        //@Deprecated
        AddPreferredActivity(
            [in] IIntentFilter* filter,
            [in] Int32 match,
            [in] ArrayOf<IComponentName*> set,
            [in] IComponentName* activity);

        /**
         * @deprecated This is a protected API that should not have been available
         * to third party applications.  It is the platform's responsibility for
         * assigning preferred activities and this can not be directly modified.
         *
         * Replaces an existing preferred activity mapping to the system, and if that were not present
         * adds a new preferred activity.  This will be used
         * to automatically select the given activity component when
         * {@link Context#startActivity(Intent) Context.startActivity()} finds
         * multiple matching activities and also matches the given filter.
         *
         * @param filter The set of intents under which this activity will be
         * made preferred.
         * @param match The IntentFilter match category that this preference
         * applies to.
         * @param set The set of activities that the user was picking from when
         * this preference was made.
         * @param activity The component name of the activity that is to be
         * preferred.
         * @hide
         */
        //@Deprecated
        ReplacePreferredActivity(
            [in] IIntentFilter* filter,
            [in] Int32 match,
            [in] ArrayOf<IComponentName*> set,
            [in] IComponentName* activity);

        /**
         * Remove all preferred activity mappings, previously added with
         * {@link #addPreferredActivity}, from the
         * system whose activities are implemented in the given package name.
         * An application can only clear its own package(s).
         *
         * @param packageName The name of the package whose preferred activity
         * mappings are to be removed.
         */
        ClearCapsulePreferredActivities(
            [in] String capsuleName);

        /**
         * Retrieve all preferred activities, previously added with
         * {@link #addPreferredActivity}, that are
         * currently registered with the system.
         *
         * @param outFilters A list in which to place the filters of all of the
         * preferred activities, or null for none.
         * @param outActivities A list in which to place the component names of
         * all of the preferred activities, or null for none.
         * @param packageName An option package in which you would like to limit
         * the list.  If null, all activities will be returned; if non-null, only
         * those activities in the given package are returned.
         *
         * @return Returns the total number of registered preferred activities
         * (the number of distinct IntentFilter records, not the number of unique
         * activity components) that were found.
         */
        GetPreferredActivities(
            [in] IObjectContainer* outFilters,
            [in] IObjectContainer* outActivities,
            [in] String capsuleName,
            [out] Int32* count);

        /**
         * Set the enabled setting for a package component (activity, receiver, service, provider).
         * This setting will override any enabled state which may have been set by the component in its
         * manifest.
         *
         * @param componentName The component to enable
         * @param newState The new enabled state for the component.  The legal values for this state
         *                 are:
         *                   {@link #COMPONENT_ENABLED_STATE_ENABLED},
         *                   {@link #COMPONENT_ENABLED_STATE_DISABLED}
         *                   and
         *                   {@link #COMPONENT_ENABLED_STATE_DEFAULT}
         *                 The last one removes the setting, thereby restoring the component's state to
         *                 whatever was set in it's manifest (or enabled, by default).
         * @param flags Optional behavior flags: {@link #DONT_KILL_APP} or 0.
         */
        SetComponentEnabledSetting(
            [in] IComponentName* componentName,
            [in] Int32 newState,
            [in] Int32 flags);

        /**
         * Return the the enabled setting for a package component (activity,
         * receiver, service, provider).  This returns the last value set by
         * {@link #setComponentEnabledSetting(ComponentName, int, int)}; in most
         * cases this value will be {@link #COMPONENT_ENABLED_STATE_DEFAULT} since
         * the value originally specified in the manifest has not been modified.
         *
         * @param componentName The component to retrieve.
         * @return Returns the current enabled state for the component.  May
         * be one of {@link #COMPONENT_ENABLED_STATE_ENABLED},
         * {@link #COMPONENT_ENABLED_STATE_DISABLED}, or
         * {@link #COMPONENT_ENABLED_STATE_DEFAULT}.  The last one means the
         * component's enabled state is based on the original information in
         * the manifest as found in {@link ComponentInfo}.
         */
        GetComponentEnabledSetting(
            [in] IComponentName* componentName,
            [out] Int32* setting);

        /**
         * Set the enabled setting for an application
         * This setting will override any enabled state which may have been set by the application in
         * its manifest.  It also overrides the enabled state set in the manifest for any of the
         * application's components.  It does not override any enabled state set by
         * {@link #setComponentEnabledSetting} for any of the application's components.
         *
         * @param packageName The package name of the application to enable
         * @param newState The new enabled state for the component.  The legal values for this state
         *                 are:
         *                   {@link #COMPONENT_ENABLED_STATE_ENABLED},
         *                   {@link #COMPONENT_ENABLED_STATE_DISABLED}
         *                   and
         *                   {@link #COMPONENT_ENABLED_STATE_DEFAULT}
         *                 The last one removes the setting, thereby restoring the applications's state to
         *                 whatever was set in its manifest (or enabled, by default).
         * @param flags Optional behavior flags: {@link #DONT_KILL_APP} or 0.
         */
        SetApplicationEnabledSetting(
            [in] String capsuleName,
            [in] Int32 newState,
            [in] Int32 flags);

        /**
         * Return the the enabled setting for an application.  This returns
         * the last value set by
         * {@link #setApplicationEnabledSetting(String, int, int)}; in most
         * cases this value will be {@link #COMPONENT_ENABLED_STATE_DEFAULT} since
         * the value originally specified in the manifest has not been modified.
         *
         * @param packageName The component to retrieve.
         * @return Returns the current enabled state for the component.  May
         * be one of {@link #COMPONENT_ENABLED_STATE_ENABLED},
         * {@link #COMPONENT_ENABLED_STATE_DISABLED}, or
         * {@link #COMPONENT_ENABLED_STATE_DEFAULT}.  The last one means the
         * application's enabled state is based on the original information in
         * the manifest as found in {@link ComponentInfo}.
         */
        GetApplicationEnabledSetting(
            [in] String capsuleName,
            [out] Int32* setting);

        /**
         * Return whether the device has been booted into safe mode.
         */
        IsSafeMode(
            [out] Boolean* isSafeMode);

        /**
         * Attempts to move package resources from internal to external media or vice versa.
         * Since this may take a little while, the result will
         * be posted back to the given observer.   This call may fail if the calling context
         * lacks the {@link android.Manifest.permission#MOVE_PACKAGE} permission, if the
         * named package cannot be found, or if the named package is a "system package".
         *
         * @param packageName The name of the package to delete
         * @param observer An observer callback to get notified when the package move is
         * complete. {@link android.content.pm.IPackageMoveObserver#packageMoved(boolean)} will be
         * called when that happens.  observer may be null to indicate that no callback is desired.
         * @param flags To indicate install location {@link #MOVE_INTERNAL} or
         * {@link #MOVE_EXTERNAL_MEDIA}
         *
         * @hide
         */
        MoveCapsule(
            [in] String capsuleName,
            [in] ICapsuleMoveObserver* observer,
            [in] Int32 flags);
    }
}

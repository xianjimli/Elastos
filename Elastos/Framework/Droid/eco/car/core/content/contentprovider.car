
module
{
    /* IPC constants */
    const contentprovider_descriptor = "elastos.content.IContentProvider";

    const contentprovider_QUERY_TRANSACTION = 0x00000001;

    const contentprovider_GET_TYPE_TRANSACTION = 0x00000002;

    const contentprovider_INSERT_TRANSACTION = 0x00000003;

    const contentprovider_DELETE_TRANSACTION = 0x00000004;

    const contentprovider_UPDATE_TRANSACTION = 0x0000000a;

    const contentprovider_BULK_INSERT_TRANSACTION = 0x0000000d;

    const contentprovider_OPEN_FILE_TRANSACTION = 0x0000000e;

    const contentprovider_OPEN_ASSET_FILE_TRANSACTION = 0x0000000f;

    const contentprovider_APPLY_BATCH_TRANSACTION = 0x00000014;
    
    const contentprovider_CALL_TRANSACTION = 0x00000015;

    interface IContext;
    interface IContentProviderInfo;
    interface IUri;
    interface IContentValues;
    interface ICursor;
    interface IParcelFileDescriptor;
    interface IAssetFileDescriptor;
    interface IBundle;
    interface IContentObserver;
    interface ICursorWindow;
    interface IBulkCursor;

    interface IContentProvider {
        /**
        * Remote version of a query, which returns an IBulkCursor. The bulk
        * cursor should be wrapped with BulkCursorToCursorAdaptor before use.
        */
        BulkQuery(
        [in] IUri* uri,
        [in] ArrayOf<String> projection,
        [in] String selection,
        [in] ArrayOf<String> selectionArgs,
        [in] String sortOrder,
        [in] IContentObserver* observer,
        [in] ICursorWindow* window,
        [out] IBulkCursor** cursor);

        /**
         * Receives a query request from a client in a local process,
         * and returns a Cursor.
         */
        Query(
            [in] IUri* uri,
            [in] ArrayOf<String> projection,
            [in] String selection,
            [in] ArrayOf<String> selectionArgs,
            [in] String sortOrder,
            [out] ICursor** cursor);

        /**
         * Return the MIME type of the data at the given URI.
         */
        GetType(
            [in] IUri* uri,
            [out] String* type);

        /**
         * Implement this to insert a new row.
         */
        Insert(
            [in] IUri* uri,
            [in] IContentValues* values,
            [out] IUri** insertedItemUri);

        /**
         * Override this to handle requests to insert a set of new rows, or the
         * default implementation will iterate over the values and call
         * {@link #insert} on each of them.
         * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
         * after inserting.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals:
         * Processes and Threads</a>.
         *
         * @param uri The content:// URI of the insertion request.
         * @param values An array of sets of column_name/value pairs to add to the database.
         * @return The number of values that were inserted.
         */
        BulkInsert(
            [in] IUri* uri,
            [in] ArrayOf<IContentValues*> values,
            [out] Int32* number);

        /**
         * A request to delete one or more rows.
         */
        Delete(
            [in] IUri* uri,
            [in] String selection,
            [in] ArrayOf<String> selectionArgs,
            [out] Int32* rowsAffected);

        /**
         * Update a content URI.
         */
        Update(
            [in] IUri* uri,
            [in] IContentValues* values,
            [in] String selection,
            [in] ArrayOf<String> selectionArgs,
            [out] Int32* rowsAffected);

        /**
         * Override this to handle requests to open a file blob.
         * The default implementation always throws {@link FileNotFoundException}.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals:
         * Processes and Threads</a>.
         *
         * <p>This method returns a ParcelFileDescriptor, which is returned directly
         * to the caller.  This way large data (such as images and documents) can be
         * returned without copying the content.
         *
         * <p>The returned ParcelFileDescriptor is owned by the caller, so it is
         * their responsibility to close it when done.  That is, the implementation
         * of this method should create a new ParcelFileDescriptor for each call.
         *
         * @param uri The URI whose file is to be opened.
         * @param mode Access mode for the file.  May be "r" for read-only access,
         * "rw" for read and write access, or "rwt" for read and write access
         * that truncates any existing file.
         *
         * @return Returns a new ParcelFileDescriptor which you can use to access
         * the file.
         *
         * @throws FileNotFoundException Throws FileNotFoundException if there is
         * no file associated with the given URI or the mode is invalid.
         * @throws SecurityException Throws SecurityException if the caller does
         * not have permission to access the file.
         *
         * @see #openAssetFile(Uri, String)
         * @see #openFileHelper(Uri, String)
         */
        OpenFile(
            [in] IUri* uri,
            [in] String mode,
            [out] IParcelFileDescriptor** fileDescriptor);

        /**
         * This is like {@link #openFile}, but can be implemented by providers
         * that need to be able to return sub-sections of files, often assets
         * inside of their .apk.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals:
         * Processes and Threads</a>.
         *
         * <p>If you implement this, your clients must be able to deal with such
         * file slices, either directly with
         * {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level
         * {@link ContentResolver#openInputStream ContentResolver.openInputStream}
         * or {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}
         * methods.
         *
         * <p class="note">If you are implementing this to return a full file, you
         * should create the AssetFileDescriptor with
         * {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible with
         * applications that can not handle sub-sections of files.</p>
         *
         * @param uri The URI whose file is to be opened.
         * @param mode Access mode for the file.  May be "r" for read-only access,
         * "w" for write-only access (erasing whatever data is currently in
         * the file), "wa" for write-only access to append to any existing data,
         * "rw" for read and write access on any existing data, and "rwt" for read
         * and write access that truncates any existing file.
         *
         * @return Returns a new AssetFileDescriptor which you can use to access
         * the file.
         *
         * @throws FileNotFoundException Throws FileNotFoundException if there is
         * no file associated with the given URI or the mode is invalid.
         * @throws SecurityException Throws SecurityException if the caller does
         * not have permission to access the file.
         *
         * @see #openFile(Uri, String)
         * @see #openFileHelper(Uri, String)
         */
        OpenAssetFile(
            [in] IUri* uri,
            [in] String mode,
            [out] IAssetFileDescriptor** fileDescriptor);

        /**
         * After being instantiated, this is called to tell the content provider
         * about itself.
         *
         * @param context The context this provider is running in
         * @param info Registered information about this content provider
         */
        AttachInfo(
            [in] IContext* ctx,
            [in] IContentProviderInfo* providerInfo);

        /**
         * Override this to handle requests to perform a batch of operations, or the
         * default implementation will iterate over the operations and call
         * {@link ContentProviderOperation#apply} on each of them.
         * If all calls to {@link ContentProviderOperation#apply} succeed
         * then a {@link ContentProviderResult} array with as many
         * elements as there were operations will be returned.  If any of the calls
         * fail, it is up to the implementation how many of the others take effect.
         * This method can be called from multiple threads, as described in
         * <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals:
         * Processes and Threads</a>.
         *
         * @param operations the operations to apply
         * @return the results of the applications
         * @throws OperationApplicationException thrown if any operation fails.
         * @see ContentProviderOperation#apply
         */
        //ApplyBatch(ArrayList<ContentProviderOperation> operations);

        /**
         * @hide -- until interface has proven itself
         *
         * Call an provider-defined method.  This can be used to implement
         * interfaces that are cheaper than using a Cursor.
         *
         * @param method Method name to call.  Opaque to framework.
         * @param request Nullable String argument passed to method.
         * @param args Nullable Bundle argument passed to method.
         */
        Call(
            [in] String method,
            [in] String request,
            [in] IBundle* args,
            [out] IBundle** bundle);
    }

    interface IContentProviderTransport extends IContentProvider{

    }
}

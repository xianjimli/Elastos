
module
{
    interface IDialogInterface;

    /**
     * Base class for Dialogs.
     *
     * <p>Note: Activities provide a facility to manage the creation, saving and
     * restoring of dialogs. See {@link Activity#onCreateDialog(int)},
     * {@link Activity#onPrepareDialog(int, Dialog)},
     * {@link Activity#showDialog(int)}, and {@link Activity#dismissDialog(int)}. If
     * these methods are used, {@link #getOwnerActivity()} will return the Activity
     * that managed this dialog.
     *
     * <p>Often you will want to have a Dialog display on top of the current
     * input method, because there is no reason for it to accept text.  You can
     * do this by setting the {@link WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM
     * WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM} window flag (assuming
     * your Dialog takes input focus, as it the default) with the following code:
     *
     * <pre>
     *     getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
     *             WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
     * </pre>
     */
    interface IDialog extends IDialogInterface {
        /**
         * Retrieve the Context this Dialog is running in.
         *
         * @return Context The Context that was supplied to the constructor.
         */
        GetContext(
            [out] IContext** context);

        /**
         * Sets the Activity that owns this dialog. An example use: This Dialog will
         * use the suggested volume control stream of the Activity.
         *
         * @param activity The Activity that owns this dialog.
         */
        SetOwnerActivity(
            [in] IActivity* activity);

        /**
         * Returns the Activity that owns this Dialog. For example, if
         * {@link Activity#showDialog(Int32)} is used to show this Dialog, that
         * Activity will be the owner (by default). Depending on how this dialog was
         * created, this may return NULL.
         *
         * @return The Activity that owns this Dialog.
         */
        GetOwnerActivity(
            [out] IActivity** activity);

        /**
         * @return Whether the dialog is currently showing.
         */
        IsShowing(
            [out] Boolean* isShowing);

        /**
         * Start the dialog and display it on screen.  The window is placed in the
         * application layer and opaque.  Note that you should not override this
         * method to do initialization when the dialog is shown, instead implement
         * that in {@link #OnStart}.
         */
        Show();

        /**
         * Hide the dialog, but do not dismiss it.
         */
        Hide();

        // internal method to make sure mcreated is set properly without requiring
        // users to call through to super in onCreate
        DispatchOnCreate(
            [in] IBundle* savedInstanceState);

        /**a
         * Saves the state of the dialog into a bundle.
         *
         * The default implementation saves the state of its view hierarchy, so you'll
         * likely want to call through to super if you override this to save additional
         * state.
         * @return A bundle with the state of the dialog.
         */
        OnSaveInstanceState(
            [out] IBundle** bundle);

        /**
         * Restore the state of the dialog from a previously saved bundle.
         *
         * The default implementation restores the state of the dialog's view
         * hierarchy that was saved in the default implementation of {@link #onSaveInstanceState()},
         * so be sure to call through to super when overriding unless you want to
         * do all restoring of state yourself.
         * @param savedInstanceState The state of the dialog previously saved by
         *     {@link #onSaveInstanceState()}.
         */
        OnRestoreInstanceState(
            [in] IBundle* savedInstanceState);

        /**
         * Retrieve the current Window for the activity.  This can be used to
         * directly access parts of the Window API that are not available
         * through Activity/Screen.
         *
         * @return Window The current window, or NULL if the activity is not
         *         visual.
         */
        GetWindow(
            [out] IWindow** window);

        /**
         * Call {@link android.view.Window#getCurrentFocus} on the
         * Window if this Activity to return the currently focused view.
         *
         * @return View The current View with focus or NULL.
         *
         * @see #GetWindow
         * @see android.view.Window#getCurrentFocus
         */
        GetCurrentFocus(
            [out] IView** view);

        /**
         * Finds a view that was identified by the id attribute from the XML that
         * was processed in {@link #OnStart}.
         *
         * @param id the identifier of the view to find
         * @return The view if found or NULL otherwise.
         */
        FindViewById(
            [in] Int32 id,
            [out] IView** view);

        /**
         * Set the screen content from a layout resource.  The resource will be
         * inflated, adding all top-level views to the screen.
         *
         * @param layoutResID Resource ID to be inflated.
         */
        SetContentView(
            [in] Int32 layoutResID);

        /**
         * Set the screen content to an explicit view.  This view is placed
         * directly into the screen's view hierarchy.  It can itself be a complex
         * view hierarhcy.
         *
         * @param view The desired content to display.
         */
        SetContentViewEx(
            [in] IView* view);

        /**
         * Set the screen content to an explicit view.  This view is placed
         * directly into the screen's view hierarchy.  It can itself be a complex
         * view hierarhcy.
         *
         * @param view The desired content to display.
         * @param params Layout parameters for the view.
         */
        SetContentViewEx2(
            [in] IView* view,
            [in] IViewGroupLayoutParams* params);

        /**
         * Add an additional content view to the screen.  Added after any existing
         * ones in the screen -- existing views are NOT removed.
         *
         * @param view The desired content to display.
         * @param params Layout parameters for the view.
         */
        AddContentView(
            [in] IView* view,
            [in] IViewGroupLayoutParams* params);

        /**
         * Set the title text for this dialog's window.
         *
         * @param title The new text to display in the title.
         */
        SetTitle(
            [in] ICharSequence* title);

        /**
         * Set the title text for this dialog's window. The text is retrieved
         * from the resources with the supplied identifier.
         *
         * @param titleId the title's text resource identifier
         */
        SetTitleEx(
            [in] Int32 titleId);

        /**
         * Called when the dialog has detected the user's press of the back
         * key.  The default implementation simply cancels the dialog (only if
         * it is cancelable), but you can override this to do whatever you want.
         */
        OnBackPressed();

        /**
         * Called when a touch screen event was not handled by any of the views
         * under it. This is most useful to process touch events that happen outside
         * of your window bounds, where there is no view to receive it.
         *
         * @param event The touch screen event being processed.
         * @return Return TRUE if you have consumed the event, FALSE if you haven't.
         *         The default implementation will cancel the dialog when a touch
         *         happens outside of the window bounds.
         */
        OnTouchEvent(
            [in] IMotionEvent* event,
            [out] Boolean* res);

        /**
         * Called when the trackball was moved and not handled by any of the
         * views inside of the activity.  So, for example, if the trackball moves
         * while focus is on a button, you will receive a call here because
         * buttons do not normally do anything with trackball events.  The call
         * here happens <em>before</em> trackball movements are converted to
         * DPAD key events, which then get sent back to the view hierarchy, and
         * will be processed at the point for things like focus navigation.
         *
         * @param event The trackball event being processed.
         *
         * @return Return TRUE if you have consumed the event, FALSE if you haven't.
         * The default implementation always returns FALSE.
         */
        OnTrackballEvent(
            [in] IMotionEvent* event,
            [out] Boolean* res);

        /**
         * It is usually safe to proxy this call to the owner activity's
         * {@link Activity#onCreateOptionsMenu(Menu)} if the client desires the same
         * menu for this Dialog.
         *
         * @see Activity#onCreateOptionsMenu(Menu)
         * @see #getOwnerActivity()
         */
        OnCreateOptionsMenu(
            [in] IMenu* menu,
            [out] Boolean* res);

        /**
         * It is usually safe to proxy this call to the owner activity's
         * {@link Activity#onPrepareOptionsMenu(Menu)} if the client desires the
         * same menu for this Dialog.
         *
         * @see Activity#onPrepareOptionsMenu(Menu)
         * @see #getOwnerActivity()
         */
        OnPrepareOptionsMenu(
            [in] IMenu* menu,
            [out] Boolean* res);

        /**
         * @see Activity#onOptionsItemSelected(MenuItem)
         */
        OnOptionsItemSelected(
            [in] IMenuItem* item,
            [out] Boolean* res);

        /**
         * @see Activity#onOptionsMenuClosed(Menu)
         */
        OnOptionsMenuClosed(
            [in] IMenu* menu);

        /**
         * @see Activity#openOptionsMenu()
         */
        OpenOptionsMenu();

        /**
         * @see Activity#closeOptionsMenu()
         */
        CloseOptionsMenu();

        /**
         * @see Activity#registerForContextMenu(View)
         */
        RegisterForContextMenu(
            [in] IView* view);

        /**
         * @see Activity#unregisterForContextMenu(View)
         */
        UnregisterForContextMenu(
            [in] IView* view);

        /**
         * @see Activity#openContextMenu(View)
         */
        OpenContextMenu(
            [in] IView* view);

        /**
         * @see Activity#onContextItemSelected(MenuItem)
         */
        OnContextItemSelected(
            [in] IMenuItem* item,
            [out] Boolean* res);

        /**
         * @see Activity#onContextMenuClosed(Menu)
         */
        OnContextMenuClosed(
            [in] IMenu* menu);

        /**
         * Request that key events come to this dialog. Use this if your
         * dialog has no views with focus, but the dialog still wants
         * a chance to process key events.
         *
         * @param get TRUE if the dialog should receive key events, FALSE otherwise
         * @see android.view.Window#takeKeyEvents
         */
        TakeKeyEvents(
            [in] Boolean get);

        /**
         * Enable extended window features.  This is a convenience for calling
         * {@link android.view.Window#requestFeature GetWindow().requestFeature()}.
         *
         * @param featureId The desired feature as defined in
         *                  {@link android.view.Window}.
         * @return Returns TRUE if the requested feature is supported and now
         *         enabled.
         *
         * @see android.view.Window#requestFeature
         */
        RequestWindowFeature(
            [in] Int32 featureId,
            [out] Boolean* res);

        /**
         * Convenience for calling
         * {@link android.view.Window#setFeatureDrawableResource}.
         */
        SetFeatureDrawableResource(
            [in] Int32 featureId,
            [in] Int32 resId);

        /**
         * Convenience for calling
         * {@link android.view.Window#setFeatureDrawableUri}.
         */
        SetFeatureDrawableUri(
            [in] Int32 featureId,
            [in] IUri* uri);

        /**
         * Convenience for calling
         * {@link android.view.Window#setFeatureDrawable(Int32, Drawable)}.
         */
        SetFeatureDrawable(
            [in] Int32 featureId,
            [in] IDrawable* drawable);

        /**
         * Convenience for calling
         * {@link android.view.Window#setFeatureDrawableAlpha}.
         */
        SetFeatureDrawableAlpha(
            [in] Int32 featureId,
            [in] Int32 alpha);

        GetLayoutInflater(
            [out] ILayoutInflater** layout);

        /**
         * Sets whether this dialog is cancelable with the
         * {@link KeyEvent#KEYCODE_BACK BACK} key.
         */
        SetCancelable(
            [in] Boolean flag);

        /**
         * Sets whether this dialog is canceled when touched outside the window's
         * bounds. If setting to TRUE, the dialog is set to be cancelable if not
         * already set.
         *
         * @param cancel Whether the dialog should be canceled when touched outside
         *            the window.
         */
        SetCanceledOnTouchOutside(
            [in] Boolean cancel);

        /**
         * Set a listener to be invoked when the dialog is canceled.
         * <p>
         * This will only be invoked when the dialog is canceled, if the creator
         * needs to know when it is dismissed in general, use
         * {@link #setOnDismissListener}.
         *
         * @param listener The {@link DialogInterface.OnCancelListener} to use.
         */
        SetOnCancelListener(
            [in] IDialogInterfaceOnCancelListener* listener);

        /**
         * Set a listener to be invoked when the dialog is dismissed.
         * @param listener The {@link DialogInterface.OnDismissListener} to use.
         */
        SetOnDismissListener(
            [in] IDialogInterfaceOnDismissListener* listener);

        /**
         * Sets a listener to be invoked when the dialog is shown.
         * @param listener The {@link DialogInterface.OnShowListener} to use.
         */
        SetOnShowListener(
            [in] IDialogInterfaceOnShowListener* listener);

        /**
         * By default, this will use the owner Activity's suggested stream type.
         *
         * @see Activity#setVolumeControlStream(Int32)
         * @see #setOwnerActivity(Activity)
         */ //final
        SetVolumeControlStream(
            [in] Int32 streamType);

        /**
         * @see Activity#getVolumeControlStream()
         */ //final
        GetVolumeControlStream(
            [out] Int32* stream);

        /**
         * Sets the callback that will be called if a key is dispatched to the dialog.
         */
        SetOnKeyListener(
            [in] IDialogInterfaceOnKeyListener* onKeyListener);
    }
}


module
{
    interface ITextPaint;

    enum BufferType {
        BufferType_NORMAL,
        BufferType_SPANNABLE,
        BufferType_EDITABLE,
    }

    enum TextUtilsTruncateAt;

    /**
     * Interface definition for a callback to be invoked when an action is
     * performed on the editor.
     */
    //interface IOnEditorActionListener {
        /**
         * Called when an action is being performed.
         *
         * @param v The view that was clicked.
         * @param actionId Identifier of the action.  This will be either the
         * identifier you supplied, or {@link EditorInfo#IME_NULL
         * EditorInfo.IME_NULL} if being called due to the enter key
         * being pressed.
         * @param event If triggered by an enter key, this is the event;
         * otherwise, this is null.
         * @return Return true if you have consumed the action, else false.
         */
        //OnEditorAction(
            //[in] ITextView* v,
            //[in] Int32 actionId,
            //[in] IKeyEvent* event,
            //[out] Boolean* result);
    //}

    interface ITextView extends IView {

        /**
         * Sets the typeface and style in which the text should be displayed,
         * and turns on the fake bold and italic bits in the Paint if the
         * Typeface that you provided does not have all the bits in the
         * style that you specified.
         *
         * @attr ref android.R.styleable#TextView_typeface
         * @attr ref android.R.styleable#TextView_textStyle
         */
        SetTypeface(
            [in] ITypeface* tf,
            [in] Int32 style);

        /**
         * Return the text the TextView is displaying. If setText() was called with
         * an argument of BufferType.SPANNABLE or BufferType.EDITABLE, you can cast
         * the return value from this method to Spannable or Editable, respectively.
         *
         * Note: The content of the return value should not be modified. If you want
         * a modifiable one, you should make your own copy first.
         */
        GetText(
            [out] ICharSequence** text);

        /**
         * Returns the length, in characters, of the text managed by this TextView
         */
        GetLength(
            [out] Int32* length);

        /**
         * Return the text the TextView is displaying as an Editable object.  If
         * the text is not editable, null is returned.
         *
         * @see #getText
         */
        //GetEditableText(
        //    [out] IEditable* editable);

        /**
         * @return the height of one standard line in pixels.  Note that markup
         * within the text can cause individual lines to be taller or shorter
         * than this height, and the layout may contain additional first-
         * or last-line padding.
         */
        GetLineHeight(
            [out] Int32* height);

        /**
         * @return the Layout that is currently being used to display the text.
         * This can be null if the text or width has recently changes.
         */
        //GetLayout(
        //    [out] ILayout** layout);

        /**
         * @return the current key listener for this TextView.
         * This will frequently be null for non-EditText TextViews.
         */
        //GetKeyListener(
        //    [out] IKeyListener** listener);

        /**
         * Sets the key listener to be used with this TextView.  This can be null
         * to disallow user input.  Note that this method has significant and
         * subtle interactions with soft keyboards and other input method:
         * see {@link KeyListener#getInputType() KeyListener.getContentType()}
         * for important details.  Calling this method will replace the current
         * content type of the text view with the content type returned by the
         * key listener.
         * <p>
         * Be warned that if you want a TextView with a key listener or movement
         * method not to be focusable, or if you want a TextView without a
         * key listener or movement method to be focusable, you must call
         * {@link #setFocusable} again after calling this to get the focusability
         * back the way you want it.
         *
         * @attr ref android.R.styleable#TextView_numeric
         * @attr ref android.R.styleable#TextView_digits
         * @attr ref android.R.styleable#TextView_phoneNumber
         * @attr ref android.R.styleable#TextView_inputMethod
         * @attr ref android.R.styleable#TextView_capitalize
         * @attr ref android.R.styleable#TextView_autoText
         */
        //SetKeyListener(
        //    [in] IKeyListener* input);

        /**
         * @return the movement method being used for this TextView.
         * This will frequently be null for non-EditText TextViews.
         */
        //GetMovementMethod(
        //    [out] IMovementMethod** movement);

        /**
         * Sets the movement method (arrow key handler) to be used for
         * this TextView.  This can be null to disallow using the arrow keys
         * to move the cursor or scroll the view.
         * <p>
         * Be warned that if you want a TextView with a key listener or movement
         * method not to be focusable, or if you want a TextView without a
         * key listener or movement method to be focusable, you must call
         * {@link #setFocusable} again after calling this to get the focusability
         * back the way you want it.
         */
        //SetMovementMethod(
        //    [in] IMovementMethod* movement);

        /**
         * @return the current transformation method for this TextView.
         * This will frequently be null except for single-line and password
         * fields.
         */
        //GetTransformationMethod(
        //    [out] ITransformationMethod** method);

        /**
         * Sets the transformation that is applied to the text that this
         * TextView is displaying.
         *
         * @attr ref android.R.styleable#TextView_password
         * @attr ref android.R.styleable#TextView_singleLine
         */
        //SetTransformationMethod(
        //    [in] ITransformationMethod* method);

        /**
         * Returns the top padding of the view, plus space for the top
         * Drawable if any.
         */
        GetCompoundPaddingTop(
            [out] Int32* top);

        /**
         * Returns the bottom padding of the view, plus space for the bottom
         * Drawable if any.
         */
        GetCompoundPaddingBottom(
            [out] Int32* bottom);

        /**
         * Returns the left padding of the view, plus space for the left
         * Drawable if any.
         */
        GetCompoundPaddingLeft(
            [out] Int32* left);

        /**
         * Returns the right padding of the view, plus space for the right
         * Drawable if any.
         */
        GetCompoundPaddingRight(
            [out] Int32* right);

        /**
         * Returns the extended top padding of the view, including both the
         * top Drawable if any and any extra space to keep more than maxLines
         * of text from showing.  It is only valid to call this after measuring.
         */
        GetExtendedPaddingTop(
            [out] Int32* top);

        /**
         * Returns the extended bottom padding of the view, including both the
         * bottom Drawable if any and any extra space to keep more than maxLines
         * of text from showing.  It is only valid to call this after measuring.
         */
        GetExtendedPaddingBottom(
            [out] Int32* bottom);

        /**
         * Returns the total left padding of the view, including the left
         * Drawable if any.
         */
        GetTotalPaddingLeft(
            [out] Int32* left);

        /**
         * Returns the total right padding of the view, including the right
         * Drawable if any.
         */
        GetTotalPaddingRight(
            [out] Int32* right);

        /**
         * Returns the total top padding of the view, including the top
         * Drawable if any, the extra space to keep more than maxLines
         * from showing, and the vertical offset for gravity, if any.
         */
        GetTotalPaddingTop(
            [out] Int32* top);

        /**
         * Returns the total bottom padding of the view, including the bottom
         * Drawable if any, the extra space to keep more than maxLines
         * from showing, and the vertical offset for gravity, if any.
         */
        GetTotalPaddingBottom(
            [out] Int32* bottom);

        /**
         * Sets the Drawables (if any) to appear to the left of, above,
         * to the right of, and below the text.  Use null if you do not
         * want a Drawable there.  The Drawables must already have had
         * {@link Drawable#setBounds} called.
         *
         * @attr ref android.R.styleable#TextView_drawableLeft
         * @attr ref android.R.styleable#TextView_drawableTop
         * @attr ref android.R.styleable#TextView_drawableRight
         * @attr ref android.R.styleable#TextView_drawableBottom
         */
        SetCompoundDrawables(
            [in] IDrawable* left,
            [in] IDrawable* top,
            [in] IDrawable* right,
            [in] IDrawable* bottom);

        /**
         * Sets the Drawables (if any) to appear to the left of, above,
         * to the right of, and below the text.  Use 0 if you do not
         * want a Drawable there. The Drawables' bounds will be set to
         * their intrinsic bounds.
         *
         * @param left Resource identifier of the left Drawable.
         * @param top Resource identifier of the top Drawable.
         * @param right Resource identifier of the right Drawable.
         * @param bottom Resource identifier of the bottom Drawable.
         *
         * @attr ref android.R.styleable#TextView_drawableLeft
         * @attr ref android.R.styleable#TextView_drawableTop
         * @attr ref android.R.styleable#TextView_drawableRight
         * @attr ref android.R.styleable#TextView_drawableBottom
         */
        SetCompoundDrawablesWithIntrinsicBounds(
            [in] Int32 left,
            [in] Int32 top,
            [in] Int32 right,
            [in] Int32 bottom);

        /**
         * Sets the Drawables (if any) to appear to the left of, above,
         * to the right of, and below the text.  Use null if you do not
         * want a Drawable there. The Drawables' bounds will be set to
         * their intrinsic bounds.
         *
         * @attr ref android.R.styleable#TextView_drawableLeft
         * @attr ref android.R.styleable#TextView_drawableTop
         * @attr ref android.R.styleable#TextView_drawableRight
         * @attr ref android.R.styleable#TextView_drawableBottom
         */
        SetCompoundDrawablesWithIntrinsicBoundsEx(
            [in] IDrawable* left,
            [in] IDrawable* top,
            [in] IDrawable* right,
            [in] IDrawable* bottom);

        /**
         * Returns drawables for the left, top, right, and bottom borders.
         */
        GetCompoundDrawables(
            [out, callee] ArrayOf<IDrawable*>* drawables);

        /**
         * Sets the size of the padding between the compound drawables and
         * the text.
         *
         * @attr ref android.R.styleable#TextView_drawablePadding
         */
        SetCompoundDrawablePadding(
            [in] Int32 pad);

        /**
         * Returns the padding between the compound drawables and the text.
         */
        GetCompoundDrawablePadding(
            [out] Int32* pad);

        /**
         * Gets the autolink mask of the text.  See {@link
         * android.text.util.Linkify#ALL Linkify.ALL} and peers for
         * possible values.
         *
         * @attr ref android.R.styleable#TextView_autoLink
         */
        GetAutoLinkMask(
            [out] Int32* mask);

        /**
         * Sets the text color, size, style, hint color, and highlight color
         * from the specified TextAppearance resource.
         */
        SetTextAppearance(
            [in] IContext* contxt,
            [in] Int32 resid);

        /**
         * @return the size (in pixels) of the default text size in this TextView.
         */
        GetTextSize(
            [out] Float* size);

        /**
         * Set the default text size to the given value, interpreted as "scaled
         * pixel" units.  This size is adjusted based on the current density and
         * user font size preference.
         *
         * @param size The scaled pixel size.
         *
         * @attr ref android.R.styleable#TextView_textSize
         */
        SetTextSize(
            [in] Float size);

        /**
         * Set the default text size to a given unit and value.  See {@link
         * TypedValue} for the possible dimension units.
         *
         * @param unit The desired dimension unit.
         * @param size The desired size in the given units.
         *
         * @attr ref android.R.styleable#TextView_textSize
         */
        SetTextSizeEx(
            [in] Int32 unit,
            [in] Float size);

        /**
         * @return the extent by which text is currently being stretched
         * horizontally.  This will usually be 1.
         */
        GetTextScaleX(
            [out] Float* size);

        /**
         * Sets the extent by which text should be stretched horizontally.
         *
         * @attr ref android.R.styleable#TextView_textScaleX
         */
        SetTextScaleX(
            [in] Float size);

        /**
         * Sets the typeface and style in which the text should be displayed.
         * Note that not all Typeface families actually have bold and italic
         * variants, so you may need to use
         * {@link #setTypeface(Typeface, Int32)} to get the appearance
         * that you actually want.
         *
         * @attr ref android.R.styleable#TextView_typeface
         * @attr ref android.R.styleable#TextView_textStyle
         */
        SetTypefaceEx(
            [in] ITypeface* tf);

        /**
         * @return the current typeface and style in which the text is being
         * displayed.
         */
        GetTypeface(
            [out] ITypeface** face);

        /**
         * Sets the text color for all the states (normal, selected,
         * focused) to be this color.
         *
         * @attr ref android.R.styleable#TextView_textColor
         */
        SetTextColor(
            [in] Int32 color);

        /**
         * Sets the text color.
         *
         * @attr ref android.R.styleable#TextView_textColor
         */
        SetTextColorEx(
            [in] IColorStateList* colors);

        /**
         * Return the set of text colors.
         *
         * @return Returns the set of text colors.
         */
        GetTextColors(
            [out] IColorStateList** colors);

        /**
         * <p>Return the current color selected for normal text.</p>
         *
         * @return Returns the current text color.
         */
        GetCurrentTextColor(
            [out] Int32* color);

        /**
         * Sets the color used to display the selection highlight.
         *
         * @attr ref android.R.styleable#TextView_textColorHighlight
         */
        SetHighlightColor(
            [in] Int32 color);

        /**
         * Gives the text a shadow of the specified radius and color, the specified
         * distance from its normal position.
         *
         * @attr ref android.R.styleable#TextView_shadowColor
         * @attr ref android.R.styleable#TextView_shadowDx
         * @attr ref android.R.styleable#TextView_shadowDy
         * @attr ref android.R.styleable#TextView_shadowRadius
         */
        SetShadowLayer(
            [in] Float radius,
            [in] Float dx,
            [in] Float dy,
            [in] Int32 color);

        /**
         * @return the base paint used for the text.  Please use this only to
         * consult the Paint's properties and not to change them.
         */
        GetPaint(
            [out] ITextPaint** paint);

        /**
         * Sets the autolink mask of the text.  See {@link
         * android.text.util.Linkify#ALL Linkify.ALL} and peers for
         * possible values.
         *
         * @attr ref android.R.styleable#TextView_autoLink
         */
        SetAutoLinkMask(
            [in] Int32 mask);

        /**
         * Sets whether the movement method will automatically be set to
         * {@link LinkMovementMethod} if {@link #setAutoLinkMask} has been
         * set to nonzero and links are detected in {@link #setText}.
         * The default is true.
         *
         * @attr ref android.R.styleable#TextView_linksClickable
         */
        SetLinksClickable(
            [in] Boolean whether);

        /**
         * Returns whether the movement method will automatically be set to
         * {@link LinkMovementMethod} if {@link #setAutoLinkMask} has been
         * set to nonzero and links are detected in {@link #setText}.
         * The default is true.
         *
         * @attr ref android.R.styleable#TextView_linksClickable
         */
        GetLinksClickable(
            [out] Boolean* whether);

        /**
         * Returns the list of URLSpans attached to the text
         * (by {@link Linkify} or otherwise) if any.  You can call
         * {@link URLSpan#getURL} on them to find where they link to
         * or use {@link Spanned#getSpanStart} and {@link Spanned#getSpanEnd}
         * to find the region of the text they are attached to.
         */
        //GetUrls(
        //    [out, callee] ArrayOf<IURLSpan*>* urls);

        /**
         * Sets the color of the hint text.
         *
         * @attr ref android.R.styleable#TextView_textColorHint
         */
        SetHintTextColor(
            [in] Int32 color);

        /**
         * Sets the color of the hint text.
         *
         * @attr ref android.R.styleable#TextView_textColorHint
         */
        SetHintTextColorEx(
            [in] IColorStateList* colors);

        /**
         * <p>Return the color used to paint the hint text.</p>
         *
         * @return Returns the list of hint text colors.
         */
        GetHintTextColors(
            [out] IColorStateList** colors);

        /**
         * <p>Return the current color selected to paint the hint text.</p>
         *
         * @return Returns the current hint text color.
         */
        GetCurrentHintTextColor(
            [out] Int32* color);

        /**
         * Sets the color of links in the text.
         *
         * @attr ref android.R.styleable#TextView_textColorLink
         */
        SetLinkTextColor(
            [in] Int32 color);

        /**
         * Sets the color of links in the text.
         *
         * @attr ref android.R.styleable#TextView_textColorLink
         */
        SetLinkTextColorEx(
            [in] IColorStateList* colors);

        /**
         * <p>Returns the color used to paint links in the text.</p>
         *
         * @return Returns the list of link text colors.
         */
        GetLinkTextColors(
            [out] IColorStateList** colors);

        /**
         * Sets the horizontal alignment of the text and the
         * vertical gravity that will be used when there is extra space
         * in the TextView beyond what is required for the text itself.
         *
         * @see android.view.Gravity
         * @attr ref android.R.styleable#TextView_gravity
         */
        SetGravity(
            [in] Int32 gravity);

        /**
         * Returns the horizontal and vertical alignment of this TextView.
         *
         * @see android.view.Gravity
         * @attr ref android.R.styleable#TextView_gravity
         */
        GetGravity(
            [out] Int32* gravity);

        /**
         * @return the flags on the Paint being used to display the text.
         * @see Paint#getFlags
         */
        GetPaintFlags(
            [out] Int32* flags);

        /**
         * Sets flags on the Paint being used to display the text and
         * reflows the text if they are different from the old flags.
         * @see Paint#setFlags
         */
        SetPaintFlags(
            [in] Int32 flags);

        /**
         * Sets whether the text should be allowed to be wider than the
         * View is.  If false, it will be wrapped to the width of the View.
         *
         * @attr ref android.R.styleable#TextView_scrollHorizontally
         */
        SetHorizontallyScrolling(
            [in] Boolean whether);

        /**
         * Makes the TextView at least this many lines tall
         *
         * @attr ref android.R.styleable#TextView_minLines
         */
        SetMinLines(
            [in] Int32 minlines);

        /**
         * Makes the TextView at least this many pixels tall
         *
         * @attr ref android.R.styleable#TextView_minHeight
         */
        SetMinHeight(
            [in] Int32 minHeight);

        /**
         * Makes the TextView at most this many lines tall
         *
         * @attr ref android.R.styleable#TextView_maxLines
         */
        SetMaxLines(
            [in] Int32 maxlines);

        /**
         * Makes the TextView at most this many pixels tall
         *
         * @attr ref android.R.styleable#TextView_maxHeight
         */
        SetMaxHeight(
            [in] Int32 maxHeight);

        /**
         * Makes the TextView exactly this many lines tall
         *
         * @attr ref android.R.styleable#TextView_lines
         */
        SetLines(
            [in] Int32 lines);

        /**
         * Makes the TextView exactly this many pixels tall.
         * You could do the same thing by specifying this number in the
         * LayoutParams.
         *
         * @attr ref android.R.styleable#TextView_height
         */
        SetHeight(
            [in] Int32 pixels);

        /**
         * Makes the TextView at least this many ems wide
         *
         * @attr ref android.R.styleable#TextView_minEms
         */
        SetMinEms(
            [in] Int32 minems);

        /**
         * Makes the TextView at least this many pixels wide
         *
         * @attr ref android.R.styleable#TextView_minWidth
         */
        SetMinWidth(
            [in] Int32 minpixels);

        /**
         * Makes the TextView at most this many ems wide
         *
         * @attr ref android.R.styleable#TextView_maxEms
         */
        SetMaxEms(
            [in] Int32 maxems);

        /**
         * Makes the TextView at most this many pixels wide
         *
         * @attr ref android.R.styleable#TextView_maxWidth
         */
        SetMaxWidth(
            [in] Int32 maxpixels);

        /**
         * Makes the TextView exactly this many ems wide
         *
         * @attr ref android.R.styleable#TextView_ems
         */
        SetEms(
            [in] Int32 ems);

        /**
         * Makes the TextView exactly this many pixels wide.
         * You could do the same thing by specifying this number in the
         * LayoutParams.
         *
         * @attr ref android.R.styleable#TextView_width
         */
        SetWidth(
            [in] Int32 pixels);

        /**
         * Sets line spacing for this TextView.  Each line will have its height
         * multiplied by <code>mult</code> and have <code>add</code> added to it.
         *
         * @attr ref android.R.styleable#TextView_lineSpacingExtra
         * @attr ref android.R.styleable#TextView_lineSpacingMultiplier
         */
        SetLineSpacing(
            [in] Float add,
            [in] Float mult);

        /**
         * Convenience method: Append the specified text to the TextView's
         * display buffer, upgrading it to BufferType.EDITABLE if it was
         * not already editable.
         */
        Append(
            [in] ICharSequence* text);

        /**
         * Convenience method: Append the specified text slice to the TextView's
         * display buffer, upgrading it to BufferType.EDITABLE if it was
         * not already editable.
         */
        AppendEx(
            [in] ICharSequence* text,
            [in] Int32 start,
            [in] Int32 end);

        /**
         * Control whether this text view saves its entire text contents when
         * freezing to an icicle, in addition to dynamic state such as cursor
         * position.  By default this is false, not saving the text.  Set to true
         * if the text in the text view is not being saved somewhere else in
         * persistent storage (such as in a content provider) so that if the
         * view is later thawed the user will not lose their data.
         *
         * @param freezesText Controls whether a frozen icicle should include the
         * entire text data: true to include it, false to not.
         *
         * @attr ref android.R.styleable#TextView_freezesText
         */
        SetFreezesText(
            [in] Boolean freezesText);

        /**
         * Return whether this text view is including its entire text contents
         * in frozen icicles.
         *
         * @return Returns true if text is included, false if it isn't.
         *
         * @see #setFreezesText
         */
        GetFreezesText(
            [out] Boolean* text);

        /**
         * Sets the Factory used to create new Editables.
         */
        //SetEditableFactory(
        //    [in] IEditableFactory* factory);

        /**
         * Sets the Factory used to create new Spannables.
         */
        //SetSpannableFactory(
        //    [in] ISpannableFactory* factory);

        /**
         * Sets the string value of the TextView. TextView <em>does not</em> accept
         * HTML-like formatting, which you can do with text strings in XML resource files.
         * To style your strings, attach android.text.style.* objects to a
         * {@link android.text.SpannableString SpannableString}, or see the
         * <a href="{@docRoot}guide/topics/resources/available-resources.html#stringresources">
         * Available Resource Types</a> documentation for an example of setting
         * formatted text in the XML resource file.
         *
         * @attr ref android.R.styleable#TextView_text
         */
        SetText(
            [in] ICharSequence* text);

        /**
         * Like {@link #setText(CharSequence)},
         * except that the cursor position (if any) is retained in the new text.
         *
         * @param text The new text to place in the text view.
         *
         * @see #setText(CharSequence)
         */
        SetTextKeepState(
            [in] ICharSequence* text);

        /**
         * Sets the text that this TextView is to display (see
         * {@link #setText(CharSequence)}) and also sets whether it is stored
         * in a styleable/spannable buffer and whether it is editable.
         *
         * @attr ref android.R.styleable#TextView_text
         * @attr ref android.R.styleable#TextView_bufferType
         */
        SetTextEx(
            [in] ICharSequence* text,
            [in] BufferType type);

        /**
         * Sets the TextView to display the specified slice of the specified
         * char array.  You must promise that you will not change the contents
         * of the array except for right before another call to setText(),
         * since the TextView has no way to know that the text
         * has changed and that it needs to invalidate and re-layout.
         */
        SetTextEx2(
            [in] ArrayOf<Char8> text,
            [in] Int32 start,
            [in] Int32 len);

        /**
         * Like {@link #setText(CharSequence, android.widget.TextView.BufferType)},
         * except that the cursor position (if any) is retained in the new text.
         *
         * @see #setText(CharSequence, android.widget.TextView.BufferType)
         */
        SetTextKeepStateEx(
            [in] ICharSequence* text,
            [in] BufferType type);

        SetTextEx3(
            [in] Int32 resid);

        SetTextEx4(
            [in] Int32 resid,
            [in] BufferType type);

        /**
         * Sets the text to be displayed when the text of the TextView is empty.
         * Null means to use the normal empty text. The hint does not currently
         * participate in determining the size of the view.
         *
         * @attr ref android.R.styleable#TextView_hint
         */
        SetHint(
            [in] ICharSequence* hint);

        /**
         * Sets the text to be displayed when the text of the TextView is empty,
         * from a resource.
         *
         * @attr ref android.R.styleable#TextView_hint
         */
        SetHintEx(
            [in] Int32 resid);

        /**
         * Returns the hint that is displayed when the text of the TextView
         * is empty.
         *
         * @attr ref android.R.styleable#TextView_hint
         */
        GetHint(
            [out] ICharSequence** hint);

        /**
         * Set the type of the content with a constant as defined for
         * {@link EditorInfo#inputType}.  This will take care of changing
         * the key listener, by calling {@link #setKeyListener(KeyListener)}, to
         * match the given content type.  If the given content type is
         * {@link EditorInfo#TYPE_NULL} then a soft keyboard will
         * not be displayed for this text view.
         *
         * @see #getInputType()
         * @see #setRawInputType(Int32)
         * @see android.text.InputType
         * @attr ref android.R.styleable#TextView_inputType
         */
        SetInputType(
            [in] Int32 type);

        /**
         * Directly change the content type integer of the text view, without
         * modifying any other state.
         * @see #setInputType(Int32)
         * @see android.text.InputType
         * @attr ref android.R.styleable#TextView_inputType
         */
        SetRawInputType(
            [in] Int32 type);

        /**
         * Get the type of the content.
         *
         * @see #setInputType(Int32)
         * @see android.text.InputType
         */
        GetInputType(
            [out] Int32* type);

        /**
         * Change the editor type integer associated with the text view, which
         * will be reported to an IME with {@link EditorInfo#imeOptions} when it
         * has focus.
         * @see #getImeOptions
         * @see android.view.inputmethod.EditorInfo
         * @attr ref android.R.styleable#TextView_imeOptions
         */
        SetImeOptions(
            [in] Int32 imeOptions);

        /**
         * Get the type of the IME editor.
         *
         * @see #setImeOptions(Int32)
         * @see android.view.inputmethod.EditorInfo
         */
        GetImeOptions(
            [out] Int32* options);

        /**
         * Change the custom IME action associated with the text view, which
         * will be reported to an IME with {@link EditorInfo#actionLabel}
         * and {@link EditorInfo#actionId} when it has focus.
         * @see #getImeActionLabel
         * @see #getImeActionId
         * @see android.view.inputmethod.EditorInfo
         * @attr ref android.R.styleable#TextView_imeActionLabel
         * @attr ref android.R.styleable#TextView_imeActionId
         */
        SetImeActionLabel(
            [in] ICharSequence* label,
            [in] Int32 actionId);

        /**
         * Get the IME action label previous set with {@link #setImeActionLabel}.
         *
         * @see #setImeActionLabel
         * @see android.view.inputmethod.EditorInfo
         */
        GetImeActionLabel(
            [out] ICharSequence** label);

        /**
         * Get the IME action ID previous set with {@link #setImeActionLabel}.
         *
         * @see #setImeActionLabel
         * @see android.view.inputmethod.EditorInfo
         */
        GetImeActionId(
            [out] Int32* id);

        /**
         * Set a special listener to be called when an action is performed
         * on the text view.  This will be called when the enter key is pressed,
         * or when an action supplied to the IME is selected by the user.  Setting
         * this means that the normal hard key event will not insert a newline
         * into the text view, even if it is multi-line; holding down the ALT
         * modifier will, however, allow the user to insert a newline character.
         */
        //SetOnEditorActionListener(
            //[in] IOnEditorActionListener* l);

        /**
         * Called when an attached input method calls
         * {@link InputConnection#performEditorAction(Int32)
         * InputConnection.performEditorAction()}
         * for this text view.  The default implementation will call your action
         * listener supplied to {@link #setOnEditorActionListener}, or perform
         * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
         * EditorInfo.IME_ACTION_NEXT} or {@link EditorInfo#IME_ACTION_DONE
         * EditorInfo.IME_ACTION_DONE}.
         *
         * <p>For backwards compatibility, if no IME options have been set and the
         * text view would not normally advance focus on enter, then
         * the NEXT and DONE actions received here will be turned into an enter
         * key down/up pair to go through the normal key handling.
         *
         * @param actionCode The code of the action being performed.
         *
         * @see #setOnEditorActionListener
         */
        OnEditorAction(
            [in] Int32 actionCode);

        /**
         * Set the private content type of the text, which is the
         * {@link EditorInfo#privateImeOptions EditorInfo.privateImeOptions}
         * field that will be filled in when creating an input connection.
         *
         * @see #getPrivateImeOptions()
         * @see EditorInfo#privateImeOptions
         * @attr ref android.R.styleable#TextView_privateImeOptions
         */
        SetPrivateImeOptions(
            [in] String type);

        /**
         * Get the private type of the content.
         *
         * @see #setPrivateImeOptions(String)
         * @see EditorInfo#privateImeOptions
         */
        GetPrivateImeOptions(
            [out] String* options);

        /**
         * Set the extra input data of the text, which is the
         * {@link EditorInfo#extras TextBoxAttribute.extras}
         * Bundle that will be filled in when creating an input connection.  The
         * given integer is the resource ID of an XML resource holding an
         * {@link android.R.styleable#InputExtras &lt;input-extras&gt;} XML tree.
         *
         * @see #getInputExtras(Boolean)
         * @see EditorInfo#extras
         * @attr ref android.R.styleable#TextView_editorExtras
         */
        SetInputExtras(
            [in] Int32 xmlResId);

        /**
         * Retrieve the input extras currently associated with the text view, which
         * can be viewed as well as modified.
         *
         * @param create If true, the extras will be created if they don't already
         * exist.  Otherwise, null will be returned if none have been created.
         * @see #setInputExtras(Int32)
         * @see EditorInfo#extras
         * @attr ref android.R.styleable#TextView_editorExtras
         */
        GetInputExtras(
            [in] Boolean create,
            [out] IBundle** bundle);

        /**
         * Returns the error message that was set to be displayed with
         * {@link #setError}, or <code>null</code> if no error was set
         * or if it the error was cleared by the widget after user input.
         */
        GetError(
            [out] ICharSequence** error);

        /**
         * Sets the right-hand compound drawable of the TextView to the "error"
         * icon and sets an error message that will be displayed in a popup when
         * the TextView has focus.  The icon and error message will be reset to
         * null when any key events cause changes to the TextView's text.  If the
         * <code>error</code> is <code>null</code>, the error message and icon
         * will be cleared.
         */
        SetError(
            [in] ICharSequence* error);

        /**
         * Sets the right-hand compound drawable of the TextView to the specified
         * icon and sets an error message that will be displayed in a popup when
         * the TextView has focus.  The icon and error message will be reset to
         * null when any key events cause changes to the TextView's text.  The
         * drawable must already have had {@link Drawable#setBounds} set on it.
         * If the <code>error</code> is <code>null</code>, the error message will
         * be cleared (and you should provide a <code>null</code> icon as well).
         */
        SetErrorEx(
            [in] ICharSequence* error,
            [in] IDrawable* icon);

        /**
         * Sets the list of input filters that will be used if the buffer is
         * Editable.  Has no effect otherwise.
         *
         * @attr ref android.R.styleable#TextView_maxLength
         */
        //SetFilters(
        //    [in] ArrayOf<IInputFilter*> filters);

        /**
         * Returns the current list of input filters.
         */
        //GetFilters(
        //    [out, callee] ArrayOf<IInputFilter*>* filters);

        /**
         * Return the number of lines of text, or 0 if the internal Layout has not
         * been built.
         */
        GetLineCount(
            [out] Int32* count);

        /**
         * Return the baseline for the specified line (0...getLineCount() - 1)
         * If bounds is not null, return the top, left, right, bottom extents
         * of the specified line in it. If the internal Layout has not been built,
         * return 0 and set bounds to (0, 0, 0, 0)
         * @param line which line to examine (0..getLineCount() - 1)
         * @param bounds Optional. If not null, it returns the extent of the line
         * @return the Y-coordinate of the baseline
         */
        GetLineBounds(
            [in] Int32 line,
            [in] IRect* bounds,
            [out] Int32* y);

        /**
         * If this TextView contains editable content, extract a portion of it
         * based on the information in <var>request</var> in to <var>outText</var>.
         * @return Returns true if the text was successfully extracted, else false.
         */
        ExtractText(
            [in] IExtractedTextRequest* request,
            [in] IExtractedText* outText,
            [out] Boolean* result);

        /**
         * Apply to this text view the given extracted text, as previously
         * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
         */
        SetExtractedText(
            [in] IExtractedText* text);

        /**
         * @hide
         */
        SetExtracting(
            [in] IExtractedTextRequest* req);

        /**
         * Called by the framework in response to a text completion from
         * the current input method, provided by it calling
         * {@link InputConnection#commitCompletion
         * InputConnection.commitCompletion()}.  The default implementation does
         * nothing; text views that are supporting auto-completion should override
         * this to do their desired behavior.
         *
         * @param text The auto complete text the user has selected.
         */
        OnCommitCompletion(
            [in] ICompletionInfo* text);

        BeginBatchEdit();

        EndBatchEdit();

        /**
         * Called by the framework in response to a request to begin a batch
         * of edit operations through a call to link {@link #beginBatchEdit()}.
         */
        OnBeginBatchEdit();

        /**
         * Called by the framework in response to a request to end a batch
         * of edit operations through a call to link {@link #endBatchEdit}.
         */
        OnEndBatchEdit();

        /**
         * Called by the framework in response to a private command from the
         * current method, provided by it calling
         * {@link InputConnection#performPrivateCommand
         * InputConnection.performPrivateCommand()}.
         *
         * @param action The action name of the command.
         * @param data Any additional data for the command.  This may be null.
         * @return Return true if you handled the command, else false.
         */
        OnPrivateIMECommand(
            [in] String action,
            [in] IBundle* data,
            [out] Boolean* result);

        /**
         * Set whether the TextView includes extra top and bottom padding to make
         * room for accents that go above the normal ascent and descent.
         * The default is true.
         *
         * @attr ref android.R.styleable#TextView_includeFontPadding
         */
        SetIncludeFontPadding(
            [in] Boolean includepad);

        /**
         * Move the point, specified by the offset, into the view if it is needed.
         * This has to be called after layout. Returns true if anything changed.
         */
        BringPointIntoView(
            [in] Int32 offset,
            [out] Boolean* result);

        /**
         * Move the cursor, if needed, so that it is at an offset that is visible
         * to the user.  This will not move the cursor if it represents more than
         * one character (a selection range).  This will only work if the
         * TextView contains spannable text; otherwise it will do nothing.
         *
         * @return True if the cursor was actually moved, false otherwise.
         */
        MoveCursorToVisibleOffset(
            [out] Boolean* result);

        /**
         * Convenience for {@link Selection#getSelectionStart}.
         */
        GetSelectionStart(
            [out] Int32* start);

        /**
         * Convenience for {@link Selection#getSelectionEnd}.
         */
        GetSelectionEnd(
            [out] Int32* end);

        /**
         * Return true if there is a selection inside this text view.
         */
        HasSelection(
            [out] Boolean* result);

        /**
         * Sets the properties of this field (lines, horizontally scrolling,
         * transformation method) to be for a single-line input.
         *
         * @attr ref android.R.styleable#TextView_singleLine
         */
        SetSingleLine();

        /**
         * If true, sets the properties of this field (lines, horizontally
         * scrolling, transformation method) to be for a single-line input;
         * if false, restores these to the default conditions.
         * Note that calling this with false restores default conditions,
         * not necessarily those that were in effect prior to calling
         * it with true.
         *
         * @attr ref android.R.styleable#TextView_singleLine
         */
        SetSingleLineEx(
            [in] Boolean singleLine);

        /**
         * Causes words in the text that are longer than the view is wide
         * to be ellipsized instead of broken in the middle.  You may also
         * want to {@link #setSingleLine} or {@link #setHorizontallyScrolling}
         * to constrain the text to a single line.  Use <code>null</code>
         * to turn off ellipsizing.
         *
         * @attr ref android.R.styleable#TextView_ellipsize
         */
        SetEllipsize(
            [in] TextUtilsTruncateAt where);

        /**
         * Sets how many times to repeat the marquee animation. Only applied if the
         * TextView has marquee enabled. Set to -1 to repeat indefinitely.
         *
         * @attr ref android.R.styleable#TextView_marqueeRepeatLimit
         */
        SetMarqueeRepeatLimit(
            [in] Int32 marqueeLimit);

        /**
         * Returns where, if anywhere, words that are longer than the view
         * is wide should be ellipsized.
         */
        GetEllipsize(
            [out] TextUtilsTruncateAt* size);

        /**
         * Set the TextView so that when it takes focus, all the text is
         * selected.
         *
         * @attr ref android.R.styleable#TextView_selectAllOnFocus
         */
        SetSelectAllOnFocus(
            [in] Boolean selectAllOnFocus);

        /**
         * Set whether the cursor is visible.  The default is true.
         *
         * @attr ref android.R.styleable#TextView_cursorVisible
         */
        SetCursorVisible(
            [in] Boolean visible);

        /**
         * Adds a TextWatcher to the list of those whose methods are called
         * whenever this TextView's text changes.
         * <p>
         * In 1.0, the {@link TextWatcher#afterTextChanged} method was erroneously
         * not called after {@link #setText} calls.  Now, doing {@link #setText}
         * if there are any text changed listeners forces the buffer type to
         * Editable if it would not otherwise be and does call this method.
         */
        //AddTextChangedListener(
        //    [in] ITextWatcher* watcher);

        /**
         * Removes the specified TextWatcher from the list of those whose
         * methods are called
         * whenever this TextView's text changes.
         */
        //RemoveTextChangedListener(
        //    [in] ITextWatcher* watcher);

        /**
         * Use {@link BaseInputConnection#removeComposingSpans
         * BaseInputConnection.removeComposingSpans()} to remove any IME composing
         * state from this text view.
         */
        ClearComposingText();

        /**
         * Returns true, only while processing a touch gesture, if the initial
         * touch down event caused focus to move to the text view and as a result
         * its selection changed.  Only valid while processing the touch gesture
         * of interest.
         */
        DidTouchFocusSelect(
            [out] Boolean* result);

        //SetScroller(
        //    [in] IScroller* s);

        /**
         * Returns whether this text view is a current input method target.  The
         * default implementation just checks with {@link InputMethodManager}.
         */
        IsInputMethodTarget(
            [out] Boolean* result);

        /**
         * Called when a context menu option for the text view is selected.  Currently
         * this will be one of: {@link android.R.id#selectAll},
         * {@link android.R.id#startSelectingText},
         * {@link android.R.id#cut}, {@link android.R.id#copy},
         * {@link android.R.id#paste}, {@link android.R.id#copyUrl},
         * or {@link android.R.id#switchInputMethod}.
         */
        OnTextContextMenuItem(
            [in] Int32 id,
            [out] Boolean* result);

        /**
         * Get the offset character closest to the specified absolute position.
         *
         * @param x The horizontal absolute position of a point on screen
         * @param y The vertical absolute position of a point on screen
         * @return the character offset for the character whose position is closest to the specified
         *  position. Returns -1 if there is no layout.
         *
         * @hide
         */
        GetOffset(
            [in] Int32 x,
            [in] Int32 y,
            [out] Int32* offset);
    }
}

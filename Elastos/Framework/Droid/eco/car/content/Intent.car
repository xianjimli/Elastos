
module
{
    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Standard intent broadcast actions (see action variable).

    /**
     *  Activity Action: Start as a main entry point, does not expect to
     *  receive data.
     *  <p>Input: nothing
     *  <p>Output: nothing
     */
    const Intent_ACTION_MAIN = "elastos.intent.action.MAIN";

    /**
     * Broadcast Action: Sent after the screen turns off.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_SCREEN_OFF = "elastos.intent.action.SCREEN_OFF";

    /**
     * Broadcast Action: Sent after the screen turns on.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_SCREEN_ON = "elastos.intent.action.SCREEN_ON";

    /**
     * Broadcast Action: Sent when the user is present after device wakes up (e.g when the
     * keyguard is gone).
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_USER_PRESENT = "elastos.intent.action.USER_PRESENT";

    /**
     * Broadcast Action: The current time has changed.  Sent every
     * minute.  You can <em>not</em> receive this through components declared
     * in manifests, only by exlicitly registering for it with
     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
     * Context.registerReceiver()}.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_TIME_TICK = "elastos.intent.action.TIME_TICK";

    /**
     * Broadcast Action: The time was set.
     */
    const Intent_ACTION_TIME_CHANGED = "elastos.intent.action.TIME_SET";

    /**
     * Broadcast Action: The date has changed.
     */
    const Intent_ACTION_DATE_CHANGED = "elastos.intent.action.DATE_CHANGED";

    /**
     * Broadcast Action: The timezone has changed. The intent will have the following extra values:</p>
     * <ul>
     *   <li><em>time-zone</em> - The java.util.TimeZone.getID() value identifying the new time zone.</li>
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_TIMEZONE_CHANGED = "elastos.intent.action.TIMEZONE_CHANGED";

    /**
     * Alarm Changed Action: This is broadcast when the AlarmClock
     * application's alarm is set or unset.  It is used by the
     * AlarmClock application and the StatusBar service.
     * @hide
     */
    const Intent_ACTION_ALARM_CHANGED = "elastos.intent.action.ALARM_CHANGED";

    /**
     * Sync State Changed Action: This is broadcast when the sync starts or stops or when one has
     * been failing for a long time.  It is used by the SyncManager and the StatusBar service.
     * @hide
     */
    const Intent_ACTION_SYNC_STATE_CHANGED = "elastos.intent.action.SYNC_STATE_CHANGED";

    /**
     * Broadcast Action: This is broadcast once, after the system has finished
     * booting.  It can be used to perform application-specific initialization,
     * such as installing alarms.  You must hold the
     * {@link elastos.Manifest.permission#RECEIVE_BOOT_COMPLETED} permission
     * in order to receive this broadcast.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BOOT_COMPLETED = "elastos.intent.action.BOOT_COMPLETED";

    /**
     * Broadcast Action: This is broadcast when a user action should request a
     * temporary system dialog to dismiss.  Some examples of temporary system
     * dialogs are the notification window-shade and the recent tasks dialog.
     */
    const Intent_ACTION_CLOSE_SYSTEM_DIALOGS = "elastos.intent.action.CLOSE_SYSTEM_DIALOGS";

    /**
     * Broadcast Action: Trigger the download and eventual installation
     * of a package.
     * <p>Input: {@link #getData} is the URI of the package file to download.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_INSTALL = "elastos.intent.action.CAPSULE_INSTALL";

    /**
     * Broadcast Action: A new application package has been installed on the
     * device. The data contains the name of the package.  Note that the
     * newly installed package does <em>not</em> receive this broadcast.
     * <p>My include the following extras:
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
     * <li> {@link #EXTRA_REPLACING} is set to true if this is following
     * an {@link #Intent_ACTION_CAPSULE_REMOVED} broadcast for the same package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_ADDED = "elastos.intent.action.CAPSULE_ADDED";

    /**
     * Broadcast Action: A new version of an application package has been
     * installed, replacing an existing version that was previously installed.
     * The data contains the name of the package.
     * <p>My include the following extras:
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_REPLACED = "elastos.intent.action.CAPSULE_REPLACED";

    /**
     * Broadcast Action: An existing application package has been removed from
     * the device.  The data contains the name of the package.  The package
     * that is being installed does <em>not</em> receive this Intent.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
     * to the package.
     * <li> {@link #EXTRA_DATA_REMOVED} is set to true if the entire
     * application -- data and code -- is being removed.
     * <li> {@link #EXTRA_REPLACING} is set to true if this will be followed
     * by an {@link #Intent_ACTION_CAPSULE_ADDED} broadcast for the same package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_REMOVED = "elastos.intent.action.CAPSULE_REMOVED";

    /**
     * Broadcast Action: An existing application package has been changed (e.g.
     * a component has been enabled or disabled).  The data contains the name of
     * the package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * <li> {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST} containing the class name
     * of the changed components.
     * <li> {@link #EXTRA_DONT_KILL_APP} containing boolean field to override the
     * default action of restarting the application.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_CHANGED = "elastos.intent.action.CAPSULE_CHANGED";

    /**
     * @hide
     * Broadcast Action: Ask system services if there is any reason to
     * restart the given package.  The data contains the name of the
     * package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * <li> {@link #EXTRA_CAPSULES} String array of all packages to check.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_QUERY_CAPSULE_RESTART = "elastos.intent.action.QUERY_CAPSULE_RESTART";

    /**
     * Broadcast Action: The user has restarted a package, and all of its
     * processes have been killed.  All runtime state
     * associated with it (processes, alarms, notifications, etc) should
     * be removed.  Note that the restarted package does <em>not</em>
     * receive this broadcast.
     * The data contains the name of the package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_RESTARTED = "elastos.intent.action.CAPSULE_RESTARTED";

    /**
     * Broadcast Action: The user has cleared the data of a package.  This should
     * be preceded by {@link #Intent_ACTION_CAPSULE_RESTARTED}, after which all of
     * its persistent data is erased and this broadcast sent.
     * Note that the cleared package does <em>not</em>
     * receive this broadcast. The data contains the name of the package.
     * <ul>
     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_CAPSULE_DATA_CLEARED = "elastos.intent.action.CAPSULE_DATA_CLEARED";

    /**
     * Broadcast Action: A user ID has been removed from the system.  The user
     * ID number is stored in the extra data under {@link #EXTRA_UID}.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_UID_REMOVED = "elastos.intent.action.UID_REMOVED";

    /**
     * Broadcast Action: Resources for a set of packages (which were
     * previously unavailable) are currently
     * available since the media on which they exist is available.
     * The extra data {@link #EXTRA_CHANGED_CAPSULE_LIST} contains a
     * list of packages whose availability changed.
     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
     * list of uids of packages whose availability changed.
     * Note that the
     * packages in this list do <em>not</em> receive this broadcast.
     * The specified set of packages are now available on the system.
     * <p>Includes the following extras:
     * <ul>
     * <li> {@link #EXTRA_CHANGED_CAPSULE_LIST} is the set of packages
     * whose resources(were previously unavailable) are currently available.
     * {@link #EXTRA_CHANGED_UID_LIST} is the set of uids of the
     * packages whose resources(were previously unavailable)
     * are  currently available.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_EXTERNAL_APPLICATIONS_AVAILABLE = "elastos.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";

    /**
     * Broadcast Action: Resources for a set of packages are currently
     * unavailable since the media on which they exist is unavailable.
     * The extra data {@link #EXTRA_CHANGED_CAPSULE_LIST} contains a
     * list of packages whose availability changed.
     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
     * list of uids of packages whose availability changed.
     * The specified set of packages can no longer be
     * launched and are practically unavailable on the system.
     * <p>Inclues the following extras:
     * <ul>
     * <li> {@link #EXTRA_CHANGED_CAPSULE_LIST} is the set of packages
     * whose resources are no longer available.
     * {@link #EXTRA_CHANGED_UID_LIST} is the set of packages
     * whose resources are no longer available.
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE = "elastos.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";

    /**
     * Broadcast Action:  The current system wallpaper has changed.  See
     * {@link elastos.app.WallpaperManager} for retrieving the new wallpaper.
     */
    const Intent_ACTION_WALLPAPER_CHANGED = "elastos.intent.action.WALLPAPER_CHANGED";

    /**
     * Broadcast Action: The current device {@link elastos.content.res.Configuration}
     * (orientation, locale, etc) has changed.  When such a change happens, the
     * UIs (view hierarchy) will need to be rebuilt based on this new
     * information; for the most part, applications don't need to worry about
     * this, because the system will take care of stopping and restarting the
     * application to make sure it sees the new changes.  Some system code that
     * can not be restarted will need to watch for this action and handle it
     * appropriately.
     *
     * <p class="note">
     * You can <em>not</em> receive this through components declared
     * in manifests, only by explicitly registering for it with
     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
     * Context.registerReceiver()}.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * @see elastos.content.res.Configuration
     */
    const Intent_ACTION_CONFIGURATION_CHANGED = "elastos.intent.action.CONFIGURATION_CHANGED";

    /**
     * Broadcast Action: The current device's locale has changed.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_LOCALE_CHANGED = "elastos.intent.action.LOCALE_CHANGED";

    /**
     * Broadcast Action:  This is a <em>sticky broadcast</em> containing the
     * charging state, level, and other information about the battery.
     * See {@link elastos.os.BatteryManager} for documentation on the
     * contents of the Intent.
     *
     * <p class="note">
     * You can <em>not</em> receive this through components declared
     * in manifests, only by explicitly registering for it with
     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
     * Context.registerReceiver()}.  See {@link #Intent_ACTION_BATTERY_LOW},
     * {@link #Intent_ACTION_BATTERY_OKAY}, {@link #Intent_ACTION_POWER_CONNECTED},
     * and {@link #Intent_ACTION_POWER_DISCONNECTED} for distinct battery-related
     * broadcasts that are sent and can be received through manifest
     * receivers.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BATTERY_CHANGED = "elastos.intent.action.BATTERY_CHANGED";

    /**
     * Broadcast Action:  Indicates low battery condition on the device.
     * This broadcast corresponds to the "Low battery warning" system dialog.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BATTERY_LOW = "elastos.intent.action.BATTERY_LOW";

    /**
     * Broadcast Action:  Indicates the battery is now okay after being low.
     * This will be sent after {@link #Intent_ACTION_BATTERY_LOW} once the battery has
     * gone back up to an okay state.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_BATTERY_OKAY = "elastos.intent.action.BATTERY_OKAY";

    /**
     * Broadcast Action:  External power has been connected to the device.
     * This is intended for applications that wish to register specifically to this notification.
     * Unlike Intent_ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
     * stay active to receive this notification.  This action can be used to implement actions
     * that wait until power is available to trigger.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_POWER_CONNECTED = "elastos.intent.action.Intent_ACTION_POWER_CONNECTED";

    /**
     * Broadcast Action:  External power has been removed from the device.
     * This is intended for applications that wish to register specifically to this notification.
     * Unlike Intent_ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
     * stay active to receive this notification.  This action can be used to implement actions
     * that wait until power is available to trigger.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_POWER_DISCONNECTED = "elastos.intent.action.Intent_ACTION_POWER_DISCONNECTED";

    /**
     * Broadcast Action:  Device is shutting down.
     * This is broadcast when the device is being shut down (completely turned
     * off, not sleeping).  Once the broadcast is complete, the final shutdown
     * will proceed and all unsaved data lost.  Apps will not normally need
     * to handle this, since the foreground activity will be paused as well.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_SHUTDOWN = "elastos.intent.action.Intent_ACTION_SHUTDOWN";

    /**
     * Activity Action:  Start this activity to request system shutdown.
     * The optional boolean extra field {@link #EXTRA_KEY_CONFIRM} can be set to true
     * to request confirmation from the user before shutting down.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * {@hide}
     */
    const Intent_ACTION_REQUEST_SHUTDOWN = "elastos.intent.action.Intent_ACTION_REQUEST_SHUTDOWN";

    /**
     * Broadcast Action:  A sticky broadcast that indicates low memory
     * condition on the device
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_DEVICE_STORAGE_LOW = "elastos.intent.action.DEVICE_STORAGE_LOW";

    /**
     * Broadcast Action:  Indicates low memory condition on the device no longer exists
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_DEVICE_STORAGE_OK = "elastos.intent.action.DEVICE_STORAGE_OK";

    /**
     * Broadcast Action:  A sticky broadcast that indicates a memory full
     * condition on the device. This is intended for activities that want
     * to be able to fill the data partition completely, leaving only
     * enough free space to prevent system-wide SQLite failures.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * {@hide}
     */
    const Intent_ACTION_DEVICE_STORAGE_FULL = "elastos.intent.action.DEVICE_STORAGE_FULL";

    /**
     * Broadcast Action:  Indicates memory full condition on the device
     * no longer exists.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     *
     * {@hide}
     */
    const Intent_ACTION_DEVICE_STORAGE_NOT_FULL = "elastos.intent.action.DEVICE_STORAGE_NOT_FULL";

    /**
     * Broadcast Action:  Indicates low memory condition notification acknowledged by user
     * and package management should be started.
     * This is triggered by the user from the Intent_ACTION_DEVICE_STORAGE_LOW
     * notification.
     */
    const Intent_ACTION_MANAGE_CAPSULE_STORAGE = "elastos.intent.action.MANAGE_CAPSULE_STORAGE";

    /**
     * Broadcast Action:  The device has entered USB Mass Storage mode.
     * This is used mainly for the USB Settings panel.
     * Apps should listen for Intent_ACTION_MEDIA_MOUNTED and Intent_ACTION_MEDIA_UNMOUNTED broadcasts to be notified
     * when the SD card file system is mounted or unmounted
     */
    const Intent_ACTION_UMS_CONNECTED = "elastos.intent.action.UMS_CONNECTED";

    /**
     * Broadcast Action:  The device has exited USB Mass Storage mode.
     * This is used mainly for the USB Settings panel.
     * Apps should listen for Intent_ACTION_MEDIA_MOUNTED and Intent_ACTION_MEDIA_UNMOUNTED broadcasts to be notified
     * when the SD card file system is mounted or unmounted
     */
    const Intent_ACTION_UMS_DISCONNECTED = "elastos.intent.action.UMS_DISCONNECTED";

    /**
     * Broadcast Action:  External media has been removed.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_REMOVED = "elastos.intent.action.MEDIA_REMOVED";

    /**
     * Broadcast Action:  External media is present, but not mounted at its mount point.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_UNMOUNTED = "elastos.intent.action.MEDIA_UNMOUNTED";

    /**
     * Broadcast Action:  External media is present, and being disk-checked
     * The path to the mount point for the checking media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_CHECKING = "elastos.intent.action.MEDIA_CHECKING";

    /**
     * Broadcast Action:  External media is present, but is using an incompatible fs (or is blank)
     * The path to the mount point for the checking media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_NOFS = "elastos.intent.action.MEDIA_NOFS";

    /**
     * Broadcast Action:  External media is present and mounted at its mount point.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     * The Intent contains an extra with name "read-only" and Boolean value to indicate if the
     * media was mounted read only.
     */
    const Intent_ACTION_MEDIA_MOUNTED = "elastos.intent.action.MEDIA_MOUNTED";

    /**
     * Broadcast Action:  External media is unmounted because it is being shared via USB mass storage.
     * The path to the mount point for the shared media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SHARED = "elastos.intent.action.MEDIA_SHARED";

    /**
     * Broadcast Action:  External media is no longer being shared via USB mass storage.
     * The path to the mount point for the previously shared media is contained in the Intent.mData field.
     *
     * @hide
     */
    const Intent_ACTION_MEDIA_UNSHARED = "elastos.intent.action.MEDIA_UNSHARED";

    /**
     * Broadcast Action:  External media was removed from SD card slot, but mount point was not unmounted.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_BAD_REMOVAL = "elastos.intent.action.MEDIA_BAD_REMOVAL";

    /**
     * Broadcast Action:  External media is present but cannot be mounted.
     * The path to the mount point for the removed media is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_UNMOUNTABLE = "elastos.intent.action.MEDIA_UNMOUNTABLE";

   /**
     * Broadcast Action:  User has expressed the desire to remove the external storage media.
     * Applications should close all files they have open within the mount point when they receive this intent.
     * The path to the mount point for the media to be ejected is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_EJECT = "elastos.intent.action.MEDIA_EJECT";

    /**
     * Broadcast Action:  The media scanner has started scanning a directory.
     * The path to the directory being scanned is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SCANNER_STARTED = "elastos.intent.action.MEDIA_SCANNER_STARTED";

   /**
     * Broadcast Action:  The media scanner has finished scanning a directory.
     * The path to the scanned directory is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SCANNER_FINISHED = "elastos.intent.action.MEDIA_SCANNER_FINISHED";

   /**
     * Broadcast Action:  Request the media scanner to scan a file and add it to the media database.
     * The path to the file is contained in the Intent.mData field.
     */
    const Intent_ACTION_MEDIA_SCANNER_SCAN_FILE = "elastos.intent.action.MEDIA_SCANNER_SCAN_FILE";

   /**
     * Broadcast Action:  The "Media Button" was pressed.  Includes a single
     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
     * caused the broadcast.
     */
    const Intent_ACTION_MEDIA_BUTTON = "elastos.intent.action.MEDIA_BUTTON";

    /**
     * Broadcast Action:  The "Camera Button" was pressed.  Includes a single
     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
     * caused the broadcast.
     */
    const Intent_ACTION_CAMERA_BUTTON = "elastos.intent.action.CAMERA_BUTTON";

    // *** NOTE: @todo(*) The following really should go into a more domain-specific
    // location; they are not general-purpose actions.

    /**
     * Broadcast Action: An GTalk connection has been established.
     */
    const Intent_ACTION_GTALK_SERVICE_CONNECTED = "elastos.intent.action.GTALK_CONNECTED";

    /**
     * Broadcast Action: An GTalk connection has been disconnected.
     */
    const Intent_ACTION_GTALK_SERVICE_DISCONNECTED = "elastos.intent.action.GTALK_DISCONNECTED";

    /**
     * Broadcast Action: An input method has been changed.
     */
    const Intent_ACTION_INPUT_METHOD_CHANGED = "elastos.intent.action.INPUT_METHOD_CHANGED";

    /**
     * <p>Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or
     * more radios have been turned off or on. The intent will have the following extra value:</p>
     * <ul>
     *   <li><em>state</em> - A boolean value indicating whether Airplane Mode is on. If true,
     *   then cell radio and possibly other radios such as bluetooth or WiFi may have also been
     *   turned off</li>
     * </ul>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_AIRPLANE_MODE_CHANGED = "elastos.intent.action.AIRPLANE_MODE";

    /**
     * Broadcast Action: Some content providers have parts of their namespace
     * where they publish new events or items that the user may be especially
     * interested in. For these things, they may broadcast this action when the
     * set of interesting items change.
     *
     * For example, GmailProvider sends this notification when the set of unread
     * mail in the inbox changes.
     *
     * <p>The data of the intent identifies which part of which provider
     * changed. When queried through the content resolver, the data URI will
     * return the data set in question.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>count</em> - The number of items in the data set. This is the
     *       same as the number of items in the cursor returned by querying the
     *       data URI. </li>
     * </ul>
     *
     * This intent will be sent at boot (if the count is non-zero) and when the
     * data set changes. It is possible for the data set to change without the
     * count changing (for example, if a new unread message arrives in the same
     * sync operation in which a message is archived). The phone should still
     * ring/vibrate/etc as normal in this case.
     */
    const Intent_ACTION_PROVIDER_CHANGED = "elastos.intent.action.PROVIDER_CHANGED";

    /**
     * Broadcast Action: Wired Headset plugged in or unplugged.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
     *   <li><em>name</em> - Headset type, human readable string </li>
     *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>
     * </ul>
     * </ul>
     */
    const Intent_ACTION_HEADSET_PLUG = "elastos.intent.action.HEADSET_PLUG";

    /**
     * Broadcast Action: An outgoing call is about to be placed.
     *
     * <p>The Intent will have the following extra value:
     * <ul>
     *   <li><em>{@link elastos.content.Intent#EXTRA_PHONE_NUMBER}</em> -
     *       the phone number originally intended to be dialed.</li>
     * </ul>
     * <p>Once the broadcast is finished, the resultData is used as the actual
     * number to call.  If  <code>null</code>, no call will be placed.</p>
     * <p>It is perfectly acceptable for multiple receivers to process the
     * outgoing call in turn: for example, a parental control application
     * might verify that the user is authorized to place the call at that
     * time, then a number-rewriting application might add an area code if
     * one was not specified.</p>
     * <p>For consistency, any receiver whose purpose is to prohibit phone
     * calls should have a priority of 0, to ensure it will see the final
     * phone number to be dialed.
     * Any receiver whose purpose is to rewrite phone numbers to be called
     * should have a positive priority.
     * Negative priorities are reserved for the system for this broadcast;
     * using them may cause problems.</p>
     * <p>Any BroadcastReceiver receiving this Intent <em>must not</em>
     * abort the broadcast.</p>
     * <p>Emergency calls cannot be intercepted using this mechanism, and
     * other calls cannot be modified to call emergency numbers using this
     * mechanism.
     * <p>You must hold the
     * {@link elastos.Manifest.permission#PROCESS_OUTGOING_CALLS}
     * permission to receive this Intent.</p>
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_NEW_OUTGOING_CALL = "elastos.intent.action.NEW_OUTGOING_CALL";

    /**
     * Broadcast Action: Have the device reboot.  This is only for use by
     * system code.
     *
     * <p class="note">This is a protected intent that can only be sent
     * by the system.
     */
    const Intent_ACTION_REBOOT = "elastos.intent.action.REBOOT";

    /**
     * Broadcast Action:  A sticky broadcast for changes in the physical
     * docking state of the device.
     *
     * <p>The intent will have the following extra values:
     * <ul>
     *   <li><em>{@link #EXTRA_DOCK_STATE}</em> - the current dock
     *       state, indicating which dock the device is physically in.</li>
     * </ul>
     * <p>This is intended for monitoring the current physical dock state.
     * See {@link elastos.app.UiModeManager} for the normal API dealing with
     * dock mode changes.
     */
    const Intent_ACTION_DOCK_EVENT = "elastos.intent.action.DOCK_EVENT";

    /**
     * Broadcast Action: a remote intent is to be broadcasted.
     *
     * A remote intent is used for remote RPC between devices. The remote intent
     * is serialized and sent from one device to another device. The receiving
     * device parses the remote intent and broadcasts it. Note that anyone can
     * broadcast a remote intent. However, if the intent receiver of the remote intent
     * does not trust intent broadcasts from arbitrary intent senders, it should require
     * the sender to hold certain permissions so only trusted sender's broadcast will be
     * let through.
     * @hide
     */
    const Intent_ACTION_REMOTE_INTENT = "com.kortide.elastos.c2dm.intent.RECEIVE";

    /**
     * Broadcast Action: hook for permforming cleanup after a system update.
     *
     * The broadcast is sent when the system is booting, before the
     * BOOT_COMPLETED broadcast.  It is only sent to receivers in the system
     * image.  A receiver for this should do its work and then disable itself
     * so that it does not get run again at the next boot.
     * @hide
     */
    const Intent_ACTION_PRE_BOOT_COMPLETED = "elastos.intent.action.PRE_BOOT_COMPLETED";

    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Standard intent categories (see addCategory()).

    /**
     * Set if the activity should be an option for the default action
     * (center press) to perform on a piece of data.  Setting this will
     * hide from the user any activities without it set when performing an
     * action on some data.  Note that this is normal -not- set in the
     * Intent when initiating an action -- it is for use in intent filters
     * specified in packages.
     */
    const Intent_CATEGORY_DEFAULT = "elastos.intent.category.DEFAULT";

    /**
     * Activities that can be safely invoked from a browser must support this
     * category.  For example, if the user is viewing a web page or an e-mail
     * and clicks on a link in the text, the Intent generated execute that
     * link will require the BROWSABLE category, so that only activities
     * supporting this category will be considered as possible actions.  By
     * supporting this category, you are promising that there is nothing
     * damaging (without user intervention) that can happen by invoking any
     * matching Intent.
     */
    const Intent_CATEGORY_BROWSABLE = "elastos.intent.category.BROWSABLE";

    /**
     * Set if the activity should be considered as an alternative action to
     * the data the user is currently viewing.  See also
     * {@link #CATEGORY_SELECTED_ALTERNATIVE} for an alternative action that
     * applies to the selection in a list of items.
     *
     * <p>Supporting this category means that you would like your activity to be
     * displayed in the set of alternative things the user can do, usually as
     * part of the current activity's options menu.  You will usually want to
     * include a specific label in the &lt;intent-filter&gt; of this action
     * describing to the user what it does.
     *
     * <p>The action of IntentFilter with this category is important in that it
     * describes the specific action the target will perform.  This generally
     * should not be a generic action (such as {@link #Intent_ACTION_VIEW}, but rather
     * a specific name such as "com.elastos.camera.action.CROP.  Only one
     * alternative of any particular action will be shown to the user, so using
     * a specific action like this makes sure that your alternative will be
     * displayed while also allowing other applications to provide their own
     * overrides of that particular action.
     */
    const Intent_CATEGORY_ALTERNATIVE = "elastos.intent.category.ALTERNATIVE";

    /**
     * Set if the activity should be considered as an alternative selection
     * action to the data the user has currently selected.  This is like
     * {@link #CATEGORY_ALTERNATIVE}, but is used in activities showing a list
     * of items from which the user can select, giving them alternatives to the
     * default action that will be performed on it.
     */
    const Intent_CATEGORY_SELECTED_ALTERNATIVE = "elastos.intent.category.SELECTED_ALTERNATIVE";

    /**
     * Intended to be used as a tab inside of an containing TabActivity.
     */
    const Intent_CATEGORY_TAB = "elastos.intent.category.TAB";

    /**
     * Should be displayed in the top-level launcher.
     */
    const Intent_CATEGORY_LAUNCHER = "elastos.intent.category.LAUNCHER";

    /**
     * Provides information about the package it is in; typically used if
     * a package does not contain a {@link #CATEGORY_LAUNCHER} to provide
     * a front-door to the user without having to be shown in the all apps list.
     */
    const Intent_CATEGORY_INFO = "elastos.intent.category.INFO";

    /**
     * This is the home activity, that is the first activity that is displayed
     * when the device boots.
     */
    const Intent_CATEGORY_HOME = "elastos.intent.category.HOME";

    /**
     * This activity is a preference panel.
     */
    const Intent_CATEGORY_PREFERENCE = "elastos.intent.category.PREFERENCE";

    /**
     * This activity is a development preference panel.
     */
    const Intent_CATEGORY_DEVELOPMENT_PREFERENCE = "elastos.intent.category.DEVELOPMENT_PREFERENCE";

    /**
     * Capable of running inside a parent activity container.
     */
    const Intent_CATEGORY_EMBED = "elastos.intent.category.EMBED";

    /**
     * This activity may be exercised by the monkey or other automated test tools.
     */
    const Intent_CATEGORY_MONKEY = "elastos.intent.category.MONKEY";

    /**
     * To be used as a test (not part of the normal user experience).
     */
    const Intent_CATEGORY_TEST = "elastos.intent.category.TEST";

    /**
     * To be used as a unit test (run through the Test Harness).
     */
    const Intent_CATEGORY_UNIT_TEST = "elastos.intent.category.UNIT_TEST";

    /**
     * To be used as an sample code example (not part of the normal user
     * experience).
     */
    const Intent_CATEGORY_SAMPLE_CODE = "elastos.intent.category.SAMPLE_CODE";

    /**
     * Used to indicate that a GET_CONTENT intent only wants URIs that can be opened with
     * ContentResolver.openInputStream. Openable URIs must support the columns in OpenableColumns
     * when queried, though it is allowable for those columns to be blank.
     */
    const Intent_CATEGORY_OPENABLE = "elastos.intent.category.OPENABLE";

    /**
     * To be used as code under test for framework instrumentation tests.
     */
    const Intent_CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST =
            "elastos.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";

    /**
     * An activity to run when device is inserted into a car dock.
     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
     * information, see {@link android.app.UiModeManager}.
     */
    const Intent_CATEGORY_CAR_DOCK = "elastos.intent.category.CAR_DOCK";

    /**
     * An activity to run when device is inserted into a car dock.
     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
     * information, see {@link android.app.UiModeManager}.
     */
    const Intent_CATEGORY_DESK_DOCK = "elastos.intent.category.DESK_DOCK";

    /**
     * Used to indicate that the activity can be used in a car environment.
     */
    const Intent_CATEGORY_CAR_MODE = "elastos.intent.category.CAR_MODE";

    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Standard extra data keys.

    /**
     * The initial data to place in a newly created record.  Use with
     * {@link #ACTION_INSERT}.  The data here is a Map containing the same
     * fields as would be given to the underlying ContentProvider.insert()
     * call.
     */
    const Intent_EXTRA_TEMPLATE = "android.intent.extra.TEMPLATE";

    /**
     * A constant CharSequence that is associated with the Intent, used with
     * {@link #ACTION_SEND} to supply the literal data to be sent.  Note that
     * this may be a styled CharSequence, so you must use
     * {@link Bundle#getCharSequence(String) Bundle.getCharSequence()} to
     * retrieve it.
     */
    const Intent_EXTRA_TEXT = "android.intent.extra.TEXT";

    /**
     * A content: URI holding a stream of data associated with the Intent,
     * used with {@link #ACTION_SEND} to supply the data being sent.
     */
    const Intent_EXTRA_STREAM = "android.intent.extra.STREAM";

    /**
     * A String[] holding e-mail addresses that should be delivered to.
     */
    const Intent_EXTRA_EMAIL       = "android.intent.extra.EMAIL";

    /**
     * A String[] holding e-mail addresses that should be carbon copied.
     */
    const Intent_EXTRA_CC       = "android.intent.extra.CC";

    /**
     * A String[] holding e-mail addresses that should be blind carbon copied.
     */
    const Intent_EXTRA_BCC      = "android.intent.extra.BCC";

    /**
     * A constant string holding the desired subject line of a message.
     */
    const Intent_EXTRA_SUBJECT  = "android.intent.extra.SUBJECT";

    /**
     * An Intent describing the choices you would like shown with
     * {@link #ACTION_PICK_ACTIVITY}.
     */
    const Intent_EXTRA_INTENT = "android.intent.extra.INTENT";

    /**
     * A CharSequence dialog title to provide to the user when used with a
     * {@link #ACTION_CHOOSER}.
     */
    const Intent_EXTRA_TITLE = "android.intent.extra.TITLE";

    /**
     * A Parcelable[] of {@link Intent} or
     * {@link android.content.pm.LabeledIntent} objects as set with
     * {@link #putExtra(String, Parcelable[])} of additional activities to place
     * a the front of the list of choices, when shown to the user with a
     * {@link #ACTION_CHOOSER}.
     */
    const Intent_EXTRA_INITIAL_INTENTS = "android.intent.extra.INITIAL_INTENTS";

    /**
     * A {@link android.view.KeyEvent} object containing the event that
     * triggered the creation of the Intent it is in.
     */
    const Intent_EXTRA_KEY_EVENT = "android.intent.extra.KEY_EVENT";

    /**
     * Set to true in {@link #ACTION_REQUEST_SHUTDOWN} to request confirmation from the user
     * before shutting down.
     *
     * {@hide}
     */
    const Intent_EXTRA_KEY_CONFIRM = "android.intent.extra.KEY_CONFIRM";

    /**
     * Used as an boolean extra field in {@link android.content.Intent#ACTION_CAPSULE_REMOVED} or
     * {@link android.content.Intent#ACTION_CAPSULE_CHANGED} intents to override the default action
     * of restarting the application.
     */
    const Intent_EXTRA_DONT_KILL_APP = "android.intent.extra.DONT_KILL_APP";

    /**
     * A String holding the phone number originally entered in
     * {@link android.content.Intent#ACTION_NEW_OUTGOING_CALL}, or the actual
     * number to call in a {@link android.content.Intent#ACTION_CALL}.
     */
    const Intent_EXTRA_PHONE_NUMBER = "android.intent.extra.PHONE_NUMBER";

    /**
     * Used as an int extra field in {@link android.content.Intent#ACTION_UID_REMOVED}
     * intents to supply the uid the package had been assigned.  Also an optional
     * extra in {@link android.content.Intent#ACTION_CAPSULE_REMOVED} or
     * {@link android.content.Intent#ACTION_CAPSULE_CHANGED} for the same
     * purpose.
     */
    const Intent_EXTRA_UID = "android.intent.extra.UID";

    /**
     * @hide String array of package names.
     */
    const Intent_EXTRA_CAPSULES = "android.intent.extra.CAPSULES";

    /**
     * Used as a boolean extra field in {@link android.content.Intent#ACTION_CAPSULE_REMOVED}
     * intents to indicate whether this represents a full uninstall (removing
     * both the code and its data) or a partial uninstall (leaving its data,
     * implying that this is an update).
     */
    const Intent_EXTRA_DATA_REMOVED = "android.intent.extra.DATA_REMOVED";

    /**
     * Used as a boolean extra field in {@link android.content.Intent#ACTION_CAPSULE_REMOVED}
     * intents to indicate that this is a replacement of the package, so this
     * broadcast will immediately be followed by an add broadcast for a
     * different version of the same package.
     */
    const Intent_EXTRA_REPLACING = "android.intent.extra.REPLACING";

    /**
     * Used as an int extra field in {@link android.app.AlarmManager} intents
     * to tell the application being invoked how many pending alarms are being
     * delievered with the intent.  For one-shot alarms this will always be 1.
     * For recurring alarms, this might be greater than 1 if the device was
     * asleep or powered off at the time an earlier alarm would have been
     * delivered.
     */
    const Intent_EXTRA_ALARM_COUNT = "android.intent.extra.ALARM_COUNT";

    /**
     * Used as an int extra field in {@link android.content.Intent#ACTION_DOCK_EVENT}
     * intents to request the dock state.  Possible values are
     * {@link android.content.Intent#EXTRA_DOCK_STATE_UNDOCKED},
     * {@link android.content.Intent#EXTRA_DOCK_STATE_DESK}, or
     * {@link android.content.Intent#EXTRA_DOCK_STATE_CAR}.
     */
    const Intent_EXTRA_DOCK_STATE = "android.intent.extra.DOCK_STATE";

    /**
     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
     * to represent that the phone is not in any dock.
     */
    const Intent_EXTRA_DOCK_STATE_UNDOCKED = 0;

    /**
     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
     * to represent that the phone is in a desk dock.
     */
    const Intent_EXTRA_DOCK_STATE_DESK = 1;

    /**
     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
     * to represent that the phone is in a car dock.
     */
    const Intent_EXTRA_DOCK_STATE_CAR = 2;

    /**
     * Boolean that can be supplied as meta-data with a dock activity, to
     * indicate that the dock should take over the home key when it is active.
     */
    const METADATA_DOCK_HOME = "android.dock_home";

    /**
     * Used as a parcelable extra field in {@link #ACTION_APP_ERROR}, containing
     * the bug report.
     *
     * @hide
     */
    const Intent_EXTRA_BUG_REPORT = "android.intent.extra.BUG_REPORT";

    /**
     * Used as a string extra field when sending an intent to PackageInstaller to install a
     * package. Specifies the installer package name; this package will receive the
     * {@link #ACTION_APP_ERROR} intent.
     *
     * @hide
     */
    const Intent_EXTRA_INSTALLER_CAPSULE_NAME
            = "android.intent.extra.INSTALLER_CAPSULE_NAME";

    /**
     * Used in the extra field in the remote intent. It's astring token passed with the
     * remote intent.
     */
    const Intent_EXTRA_REMOTE_INTENT_TOKEN =
            "android.intent.extra.remote_intent_token";

    /**
     * @deprecated See {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST}; this field
     * will contain only the first name in the list.
     */
    const Intent_EXTRA_CHANGED_COMPONENT_NAME =
            "android.intent.extra.changed_component_name";

    /**
     * This field is part of {@link android.content.Intent#ACTION_CAPSULE_CHANGED},
     * and contains a string array of all of the components that have changed.
     */
    const Intent_EXTRA_CHANGED_COMPONENT_NAME_LIST =
            "android.intent.extra.changed_component_name_list";

    /**
     * This field is part of
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
     * and contains a string array of all of the components that have changed.
     */
    const Intent_EXTRA_CHANGED_CAPSULE_LIST =
            "android.intent.extra.changed_package_list";

    /**
     * This field is part of
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
     * and contains an integer array of uids of all of the components
     * that have changed.
     */
    const Intent_EXTRA_CHANGED_UID_LIST =
            "android.intent.extra.changed_uid_list";

    /**
     * @hide
     * Magic extra system code can use when binding, to give a label for
     * who it is that has bound to a service.  This is an integer giving
     * a framework string resource that can be displayed to the user.
     */
    const Intent_EXTRA_CLIENT_LABEL =
            "android.intent.extra.client_label";

    /**
     * @hide
     * Magic extra system code can use when binding, to give a PendingIntent object
     * that can be launched for the user to disable the system's use of this
     * service.
     */
    const Intent_EXTRA_CLIENT_INTENT =
            "android.intent.extra.client_intent";

    // ---------------------------------------------------------------------
    // ---------------------------------------------------------------------
    // Intent flags (see mFlags variable).

    /**
     * If set, the recipient of this Intent will be granted permission to
     * perform read operations on the Uri in the Intent's data.
     */
    const Intent_FLAG_GRANT_READ_URI_PERMISSION = 0x00000001;

    /**
     * If set, the recipient of this Intent will be granted permission to
     * perform write operations on the Uri in the Intent's data.
     */
    const Intent_FLAG_GRANT_WRITE_URI_PERMISSION = 0x00000002;

    /**
     * Can be set by the caller to indicate that this Intent is coming from
     * a background operation, not from direct user interaction.
     */
    const Intent_FLAG_FROM_BACKGROUND = 0x00000004;

    /**
     * A flag you can enable for debugging: when set, log messages will be
     * printed during the resolution of this intent to show you what has
     * been found to create the final resolved list.
     */
    const Intent_FLAG_DEBUG_LOG_RESOLUTION = 0x00000008;

    /**
     * If set, the new activity is not kept in the history stack.  As soon as
     * the user navigates away from it, the activity is finished.  This may also
     * be set with the {@link elastos.R.styleable#AndroidManifestActivity_noHistory
     * noHistory} attribute.
     */
    const Intent_FLAG_ACTIVITY_NO_HISTORY = 0x40000000;

    /**
     * If set, the activity will not be launched if it is already running
     * at the top of the history stack.
     */
    const Intent_FLAG_ACTIVITY_SINGLE_TOP = 0x20000000;

    /**
     * If set, this activity will become the start of a new task on this
     * history stack.  A task (from the activity that started it to the
     * next task activity) defines an atomic group of activities that the
     * user can move to.  Tasks can be moved to the foreground and background;
     * all of the activities inside of a particular task always remain in
     * the same order.  See
     * <a href="{@docRoot}guide/topics/fundamentals.html#acttask">Application Fundamentals:
     * Activities and Tasks</a> for more details on tasks.
     *
     * <p>This flag is generally used by activities that want
     * to present a "launcher" style behavior: they give the user a list of
     * separate things that can be done, which otherwise run completely
     * independently of the activity launching them.
     *
     * <p>When using this flag, if a task is already running for the activity
     * you are now starting, then a new activity will not be started; instead,
     * the current task will simply be brought to the front of the screen with
     * the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
     * to disable this behavior.
     *
     * <p>This flag can not be used when the caller is requesting a result from
     * the activity being launched.
     */
    const Intent_FLAG_ACTIVITY_NEW_TASK = 0x10000000;

    /**
     * <strong>Do not use this flag unless you are implementing your own
     * top-level application launcher.</strong>  Used in conjunction with
     * {@link #FLAG_ACTIVITY_NEW_TASK} to disable the
     * behavior of bringing an existing task to the foreground.  When set,
     * a new task is <em>always</em> started to host the Activity for the
     * Intent, regardless of whether there is already an existing task running
     * the same thing.
     *
     * <p><strong>Because the default system does not include graphical task management,
     * you should not use this flag unless you provide some way for a user to
     * return back to the tasks you have launched.</strong>
     *
     * <p>This flag is ignored if
     * {@link #FLAG_ACTIVITY_NEW_TASK} is not set.
     *
     * <p>See <a href="{@docRoot}guide/topics/fundamentals.html#acttask">Application Fundamentals:
     * Activities and Tasks</a> for more details on tasks.
     */
    const Intent_FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;

    /**
     * If set, and the activity being launched is already running in the
     * current task, then instead of launching a new instance of that activity,
     * all of the other activities on top of it will be closed and this Intent
     * will be delivered to the (now on top) old activity as a new Intent.
     *
     * <p>For example, consider a task consisting of the activities: A, B, C, D.
     * If D calls startActivity() with an Intent that resolves to the component
     * of activity B, then C and D will be finished and B receive the given
     * Intent, resulting in the stack now being: A, B.
     *
     * <p>The currently running instance of task B in the above example will
     * either receive the new intent you are starting here in its
     * onNewIntent() method, or be itself finished and restarted with the
     * new intent.  If it has declared its launch mode to be "multiple" (the
     * default) it will be finished and re-created; for all other launch modes
     * it will receive the Intent in the current instance.
     *
     * <p>This launch mode can also be used to good effect in conjunction with
     * {@link #FLAG_ACTIVITY_NEW_TASK}: if used to start the root activity
     * of a task, it will bring any currently running instance of that task
     * to the foreground, and then clear it to its root state.  This is
     * especially useful, for example, when launching an activity from the
     * notification manager.
     *
     * <p>See <a href="{@docRoot}guide/topics/fundamentals.html#acttask">Application Fundamentals:
     * Activities and Tasks</a> for more details on tasks.
     */
    const Intent_FLAG_ACTIVITY_CLEAR_TOP = 0x04000000;

    /**
     * If set and this intent is being used to launch a new activity from an
     * existing one, then the reply target of the existing activity will be
     * transfered to the new activity.  This way the new activity can call
     * {@link elastos.app.Activity#setResult} and have that result sent back to
     * the reply target of the original activity.
     */
    const Intent_FLAG_ACTIVITY_FORWARD_RESULT = 0x02000000;

    /**
     * If set and this intent is being used to launch a new activity from an
     * existing one, the current activity will not be counted as the top
     * activity for deciding whether the new intent should be delivered to
     * the top instead of starting a new one.  The previous activity will
     * be used as the top, with the assumption being that the current activity
     * will finish itself immediately.
     */
    const Intent_FLAG_ACTIVITY_PREVIOUS_IS_TOP = 0x01000000;

    /**
     * If set, the new activity is not kept in the list of recently launched
     * activities.
     */
    const Intent_FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS = 0x00800000;

    /**
     * This flag is not normally set by application code, but set for you by
     * the system as described in the
     * {@link elastos.R.styleable#AndroidManifestActivity_launchMode
     * launchMode} documentation for the singleTask mode.
     */
    const Intent_FLAG_ACTIVITY_BROUGHT_TO_FRONT = 0x00400000;

    /**
     * If set, and this activity is either being started in a new task or
     * bringing to the top an existing task, then it will be launched as
     * the front door of the task.  This will result in the application of
     * any affinities needed to have that task in the proper state (either
     * moving activities to or from it), or simply resetting that task to
     * its initial state if needed.
     */
    const Intent_FLAG_ACTIVITY_RESET_TASK_IF_NEEDED = 0x00200000;

    /**
     * This flag is not normally set by application code, but set for you by
     * the system if this activity is being launched from history
     * (longpress home key).
     */
    const Intent_FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY = 0x00100000;

    /**
     * If set, this marks a point in the task's activity stack that should
     * be cleared when the task is reset.  That is, the next time the task
     * is brought to the foreground with
     * {@link #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED} (typically as a result of
     * the user re-launching it from home), this activity and all on top of
     * it will be finished so that the user does not return to them, but
     * instead returns to whatever activity preceeded it.
     *
     * <p>This is useful for cases where you have a logical break in your
     * application.  For example, an e-mail application may have a command
     * to view an attachment, which launches an image view activity to
     * display it.  This activity should be part of the e-mail application's
     * task, since it is a part of the task the user is involved in.  However,
     * if the user leaves that task, and later selects the e-mail app from
     * home, we may like them to return to the conversation they were
     * viewing, not the picture attachment, since that is confusing.  By
     * setting this flag when launching the image viewer, that viewer and
     * any activities it starts will be removed the next time the user returns
     * to mail.
     */
    const Intent_FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET = 0x00080000;

    /**
     * If set, this flag will prevent the normal {@link elastos.app.Activity#onUserLeaveHint}
     * callback from occurring on the current frontmost activity before it is
     * paused as the newly-started activity is brought to the front.
     *
     * <p>Typically, an activity can rely on that callback to indicate that an
     * explicit user action has caused their activity to be moved out of the
     * foreground. The callback marks an appropriate point in the activity's
     * lifecycle for it to dismiss any notifications that it intends to display
     * "until the user has seen them," such as a blinking LED.
     *
     * <p>If an activity is ever started via any non-user-driven events such as
     * phone-call receipt or an alarm handler, this flag should be passed to {@link
     * Context#startActivity Context.startActivity}, ensuring that the pausing
     * activity does not think the user has acknowledged its notification.
     */
    const Intent_FLAG_ACTIVITY_NO_USER_ACTION = 0x00040000;

    /**
     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
     * this flag will cause the launched activity to be brought to the front of its
     * task's history stack if it is already running.
     *
     * <p>For example, consider a task consisting of four activities: A, B, C, D.
     * If D calls startActivity() with an Intent that resolves to the component
     * of activity B, then B will be brought to the front of the history stack,
     * with this resulting order:  A, C, D, B.
     *
     * This flag will be ignored if {@link #FLAG_ACTIVITY_CLEAR_TOP} is also
     * specified.
     */
    const Intent_FLAG_ACTIVITY_REORDER_TO_FRONT = 0X00020000;

    /**
     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
     * this flag will prevent the system from applying an activity transition
     * animation to go to the next activity state.  This doesn't mean an
     * animation will never run -- if another activity change happens that doesn't
     * specify this flag before the activity started here is displayed, then
     * that transition will be used.  This this flag can be put to good use
     * when you are going to do a series of activity operations but the
     * animation seen by the user shouldn't be driven by the first activity
     * change but rather a later one.
     */
    const Intent_FLAG_ACTIVITY_NO_ANIMATION = 0X00010000;

    /**
     * If set, when sending a broadcast only registered receivers will be
     * called -- no BroadcastReceiver components will be launched.
     */
    const Intent_FLAG_RECEIVER_REGISTERED_ONLY = 0x40000000;

    /**
     * If set, when sending a broadcast the new broadcast will replace
     * any existing pending broadcast that matches it.  Matching is defined
     * by {@link Intent#filterEquals(Intent) Intent.filterEquals} returning
     * true for the intents of the two broadcasts.  When a match is found,
     * the new broadcast (and receivers associated with it) will replace the
     * existing one in the pending broadcast list, remaining at the same
     * position in the list.
     *
     * <p>This flag is most typically used with sticky broadcasts, which
     * only care about delivering the most recent values of the broadcast
     * to their receivers.
     */
    const Intent_FLAG_RECEIVER_REPLACE_PENDING = 0x20000000;

    /**
     * If set, when sending a broadcast <i>before boot has completed</i> only
     * registered receivers will be called -- no BroadcastReceiver components
     * will be launched.  Sticky intent state will be recorded properly even
     * if no receivers wind up being called.  If {@link #FLAG_RECEIVER_REGISTERED_ONLY}
     * is specified in the broadcast intent, this flag is unnecessary.
     *
     * <p>This flag is only for use by system sevices as a convenience to
     * avoid having to implement a more complex mechanism around detection
     * of boot completion.
     *
     * @hide
     */
    const Intent_FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = 0x10000000;

    /**
     * Set when this broadcast is for a boot upgrade, a special mode that
     * allows the broadcast to be sent before the system is ready and launches
     * the app process with no providers running in it.
     * @hide
     */
    const Intent_FLAG_RECEIVER_BOOT_UPGRADE = 0x08000000;


    interface IDescribable;
    interface IComponentName;
    interface IUri;
    interface IBundle;
    interface ICapsuleManager;
    interface IActivityInfo;
    interface IContentResolver;

    interface IIntent extends IDescribable{
        CloneFilter(
            [out] IIntent** intent);

        SetComponent(
            [in] IComponentName* component);

        GetComponent(
            [out] IComponentName** component);

        SetCapsule(
            [in] String capsuleName);

        GetCapsule(
            [out] String* capsuleName);

        SetAction(
            [in] String action);

        GetAction(
            [out] String* action);

        SetData(
            [in] IUri* data);

        GetData(
            [out] IUri** data);

        SetFlags(
            [in] Int32 flags);

        AddFlags(
            [in] Int32 flags);

        GetFlags(
            [out] Int32* flags);

        SetClassName(
            [in] String capsuleName,
            [in] String className);

        GetScheme(
            [out] String* scheme);

        AddCategory(
            [in] String category);

        HasCategory(
            [in] String category,
            [out] Boolean* hasCategory);

        GetCategories(
            [out, callee] ArrayOf<String>* categories);

        HasFileDescriptors(
            [out] Boolean* hasFD);

        PutBooleanExtra(
            [in] String name,
            [in] Boolean value);

        GetBooleanExtra(
            [in] String name,
            [out] Boolean* value);

        PutByteExtra(
            [in] String name,
            [in] Byte value);

        GetByteExtra(
            [in] String name,
            [out] Byte* value);

        PutCharExtra(
            [in] String name,
            [in] Char16 value);

        GetCharExtra(
            [in] String name,
            [out] Char16* value);

        PutInt16Extra(
            [in] String name,
            [in] Int16 value);

        GetInt16Extra(
            [in] String name,
            [out] Int16* value);

        PutInt32Extra(
            [in] String name,
            [in] Int32 value);

        GetInt32Extra(
            [in] String name,
            [out] Int32* value);

        PutInt64Extra(
            [in] String name,
            [in] Int64 value);

        GetInt64Extra(
            [in] String name,
            [out] Int64* value);

        PutFloatExtra(
            [in] String name,
            [in] Float value);

        GetFloatExtra(
            [in] String name,
            [out] Float* value);

        PutDoubleExtra(
            [in] String name,
            [in] Double value);

        GetDoubleExtra(
            [in] String name,
            [out] Double* value);

        PutStringExtra(
            [in] String name,
            [in] String value);

        GetStringExtra(
            [in] String name,
            [out] String* value);

        PutExtras(
            [in] IBundle* extras);

        GetExtras(
            [out] IBundle** value);

        PutParcelableExtra(
            [in] String name,
            [in] IParcelable* value);

        GetParcelableExtra(
            [in] String name,
            [out] IParcelable** value);

        GetStringArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<String>* array);

        ResolveActivityInfo(
            [in] ICapsuleManager* pm,
            [in] Int32 flags,
            [out] IActivityInfo** info);

        ResolveType(
            [in] IContentResolver* resolver,
            [out] String* type);

        ResolveTypeIfNeeded(
            [in] IContentResolver* resolver,
            [out] String* type);

        FilterEquals(
            [in] IIntent* other,
            [out] Boolean* isEqual);

        GetFilterHashCode(
            [out] Int32* hashCode);
    }
}

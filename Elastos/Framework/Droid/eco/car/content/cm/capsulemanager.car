
module
{
    /**
     * {@link PackageInfo} flag: return information about
     * activities in the package in {@link PackageInfo#activities}.
     */
    const CapsuleManager_GET_ACTIVITIES             = 0x00000001;

    /**
     * {@link PackageInfo} flag: return information about
     * intent receivers in the package in
     * {@link PackageInfo#receivers}.
     */
    const CapsuleManager_GET_RECEIVERS              = 0x00000002;

    /**
     * {@link PackageInfo} flag: return information about
     * services in the package in {@link PackageInfo#services}.
     */
    const CapsuleManager_GET_SERVICES               = 0x00000004;

    /**
     * {@link PackageInfo} flag: return information about
     * content providers in the package in
     * {@link PackageInfo#providers}.
     */
    const CapsuleManager_GET_PROVIDERS              = 0x00000008;

    /**
     * {@link PackageInfo} flag: return information about
     * instrumentation in the package in
     * {@link PackageInfo#instrumentation}.
     */
    const CapsuleManager_GET_INSTRUMENTATION        = 0x00000010;

    /**
     * {@link PackageInfo} flag: return information about the
     * intent filters supported by the activity.
     */
    const CapsuleManager_GET_INTENT_FILTERS          = 0x00000020;

    /**
     * {@link PackageInfo} flag: return information about the
     * signatures included in the package.
     */
    const CapsuleManager_GET_SIGNATURES             = 0x00000040;

    /**
     * {@link ResolveInfo} flag: return the IntentFilter that
     * was matched for a particular ResolveInfo in
     * {@link ResolveInfo#filter}.
     */
    const CapsuleManager_GET_RESOLVED_FILTER         = 0x00000040;

    /**
     * {@link ComponentInfo} flag: return the {@link ComponentInfo#metaData}
     * data {@link android.os.Bundle}s that are associated with a component.
     * This applies for any API returning a ComponentInfo subclass.
     */
    const CapsuleManager_GET_META_DATA               = 0x00000080;

    /**
     * {@link PackageInfo} flag: return the
     * {@link PackageInfo#gids group ids} that are associated with an
     * application.
     * This applies for any API returning an PackageInfo class, either
     * directly or nested inside of another.
     */
    const CapsuleManager_GET_GIDS                   = 0x00000100;

    /**
     * {@link PackageInfo} flag: include disabled components in the returned info.
     */
    const CapsuleManager_GET_DISABLED_COMPONENTS     = 0x00000200;

    /**
     * {@link ApplicationInfo} flag: return the
     * {@link ApplicationInfo#sharedLibraryFiles paths to the shared libraries}
     * that are associated with an application.
     * This applies for any API returning an ApplicationInfo class, either
     * directly or nested inside of another.
     */
    const CapsuleManager_GET_SHARED_LIBRARY_FILES   = 0x00000400;

    /**
     * {@link ProviderInfo} flag: return the
     * {@link ProviderInfo#uriPermissionPatterns URI permission patterns}
     * that are associated with a content provider.
     * This applies for any API returning an ProviderInfo class, either
     * directly or nested inside of another.
     */
    const CapsuleManager_GET_URI_PERMISSION_PATTERNS   = 0x00000800;

    /**
     * {@link PackageInfo} flag: return information about
     * permissions in the package in
     * {@link PackageInfo#permissions}.
     */
    const CapsuleManager_GET_PERMISSIONS            = 0x00001000;

    /**
     * Flag parameter to retrieve all applications(even uninstalled ones) with data directories.
     * This state could have resulted if applications have been deleted with flag
     * DONT_DELETE_DATA
     * with a possibility of being replaced or reinstalled in future
     */
    const CapsuleManager_GET_UNINSTALLED_CAPSULES   = 0x00002000;

    /**
     * {@link PackageInfo} flag: return information about
     * hardware preferences
     * {@link PackageInfo#configPreferences}
     */
    const CapsuleManager_GET_CONFIGURATIONS         = 0x00004000;

    /**
     * Resolution and querying flag: if set, only filters that support the
     * {@link android.content.Intent#CATEGORY_DEFAULT} will be considered for
     * matching.  This is a synonym for including the CATEGORY_DEFAULT in your
     * supplied Intent.
     */
    const CapsuleManager_MATCH_DEFAULT_ONLY         = 0x00010000;

    /**
     * Permission check result: this is returned by {@link #checkPermission}
     * if the permission has been granted to the given package.
     */
    const CapsuleManager_PERMISSION_GRANTED         = 0;

    /**
     * Permission check result: this is returned by {@link #checkPermission}
     * if the permission has not been granted to the given package.
     */
    const CapsuleManager_PERMISSION_DENIED          = -1;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if all signatures on the two packages match.
     */
    const CapsuleManager_SIGNATURE_MATCH = 0;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if neither of the two packages is signed.
     */
    const CapsuleManager_SIGNATURE_NEITHER_SIGNED = 1;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if the first package is not signed but the second is.
     */
    const CapsuleManager_SIGNATURE_FIRST_NOT_SIGNED = -1;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if the second package is not signed but the first is.
     */
    const CapsuleManager_SIGNATURE_SECOND_NOT_SIGNED = -2;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if not all signatures on both packages match.
     */
    const CapsuleManager_SIGNATURE_NO_MATCH = -3;

    /**
     * Signature check result: this is returned by {@link #checkSignatures}
     * if either of the packages are not valid.
     */
    const CapsuleManager_SIGNATURE_UNKNOWN_CAPSULE = -4;

    const CapsuleManager_COMPONENT_ENABLED_STATE_DEFAULT = 0;
    const CapsuleManager_COMPONENT_ENABLED_STATE_ENABLED = 1;
    const CapsuleManager_COMPONENT_ENABLED_STATE_DISABLED = 2;

    /**
     * Flag parameter for {@link #deletePackage} to indicate that you don't want to delete the
     * package's data directory.
     *
     * @hide
     */
    const CapsuleManager_DONT_DELETE_DATA = 0x00000001;

    /**
     * Return code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * when the package has been successfully moved by the system.
     * @hide
     */
    const CapsuleManager_MOVE_SUCCEEDED = 1;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * when the package hasn't been successfully moved by the system
     * because of insufficient memory on specified media.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_INSUFFICIENT_STORAGE = -1;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package doesn't exist.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_DOESNT_EXIST = -2;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved since its a system package.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_SYSTEM_CAPSULE = -3;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved since its forward locked.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_FORWARD_LOCKED = -4;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved to the specified location.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_INVALID_LOCATION = -5;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
     * if the specified package cannot be moved to the specified location.
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_INTERNAL_ERROR = -6;

    /**
     * Error code that is passed to the {@link IPackageMoveObserver} by
     * {@link #movePackage(android.net.Uri, IPackageMoveObserver)} if the
     * specified package already has an operation pending in the
     * {@link PackageHandler} queue.
     *
     * @hide
     */
    const CapsuleManager_MOVE_FAILED_OPERATION_PENDING = -7;

    /**
     * Flag parameter for {@link #movePackage} to indicate that
     * the package should be moved to internal storage if its
     * been installed on external media.
     * @hide
     */
    const CapsuleManager_MOVE_INTERNAL = 0x00000001;

    /**
     * Flag parameter for {@link #movePackage} to indicate that
     * the package should be moved to external media.
     * @hide
     */
    const CapsuleManager_MOVE_EXTERNAL_MEDIA = 0x00000002;

    interface ICapsuleInfo;
    interface IPermissionInfo;
    interface IObjectContainer;
    interface IPermissionGroupInfo;
    interface IApplicationInfo;
    interface IComponentName;
    interface IActivityInfo;
    interface IServiceInfo;
    interface IContentProviderInfo;
    interface IIntent;
    interface IResolveInfo;
    interface IInstrumentationInfo;
    interface IParceledListSlice;
    interface IUri;
    interface ICapsuleInstallObserver;
    interface ICapsuleDeleteObserver;
    interface IIntentFilter;
    interface ICapsuleDataObserver;
    interface ICapsuleStatsObserver;
    interface IIntentSender;
    interface ICapsuleMoveObserver;

    [deprecated]
    interface ICapsuleManager {
        GetCapsuleInfo(
            [in] String capsuleName,
            [in] Int32 flags,
            [out] ICapsuleInfo** capInfo);

        GetCapsuleUid(
            [in] String capsuleName,
            [out] Int32* uid);

        GetCapsuleGids(
            [in] String capsuleName,
            [out, callee] ArrayOf<Int32>* gids);

        CurrentToCanonicalCapsuleNames(
            [in] ArrayOf<String> names,
            [out, callee] ArrayOf<String>* cnames);

        CanonicalToCurrentCapsuleNames(
            [in] ArrayOf<String> names,
            [out, callee] ArrayOf<String>* cnames);

        GetPermissionInfo(
            [in] String name,
            [in] Int32 flags,
            [out] IPermissionInfo** info);

        QueryPermissionsByGroup(
            [in] String group,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        GetPermissionGroupInfo(
            [in] String name,
            [in] Int32 flags,
            [out] IPermissionGroupInfo** info);

        GetAllPermissionGroups(
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        GetApplicationInfo(
            [in] String capsuleName,
            [in] Int32 flags,
            [out] IApplicationInfo** appInfo);

        GetActivityInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IActivityInfo** activityInfo);

        GetReceiverInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IActivityInfo** info);

        GetServiceInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IServiceInfo** info);

        GetContentProviderInfo(
            [in] IComponentName* className,
            [in] Int32 flags,
            [out] IContentProviderInfo** info);

        CheckPermission(
            [in] String permName,
            [in] String capName,
            [out] Int32* perm);

        CheckUidPermission(
            [in] String permName,
            [in] Int32 uid,
            [out] Int32* perm);

        AddPermission(
            [in] IPermissionInfo* info,
            [out] Boolean* isAdded);

        RemovePermission(
            [in] String name);

        IsProtectedBroadcast(
            [in] String actionName,
            [out] Boolean* result);

        CheckSignatures(
            [in] String cap1,
            [in] String cap2,
            [out] Int32* sig);

        CheckUidSignatures(
            [in] Int32 uid1,
            [in] Int32 uid2,
            [out] Int32* sig);

        GetCapsulesForUid(
            [in] Int32 uid,
            [out, callee] ArrayOf<String>* capsules);

        GetNameForUid(
            [in] Int32 uid,
            [out] String* name);

        GetUidForSharedUser(
            [in] String sharedUserName,
            [out] Int32* uid);

        ResolveIntent(
            [in] IIntent* intent,
            [in] String resolvedType,
            [in] Int32 flags,
            [out] IResolveInfo** resolveInfo);

        QueryIntentActivities(
            [in] IIntent* intent,
            [in] String resolvedType,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        QueryIntentActivityOptions(
            [in] IComponentName* caller,
            [in] ArrayOf<IIntent*>* specifics,
            [in] ArrayOf<String>* specificTypes,
            [in] IIntent* intent,
            [in] String resolvedType,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        QueryIntentReceivers(
            [in] IIntent* intent,
            [in] String resolvedType,
            [in] Int32 flags,
            [out] IObjectContainer** receivers);

        ResolveService(
            [in] IIntent* intent,
            [in] String resolvedType,
            [in] Int32 flags,
            [out] IResolveInfo** resolveInfo);

        QueryIntentServices(
            [in] IIntent* intent,
            [in] String resolvedType,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * This implements getInstalledPackages via a "last returned row"
         * mechanism that is not exposed in the API. This is to get around the IPC
         * limit that kicks in when flags are included that bloat up the data
         * returned.
         */
        GetInstalledCapsules(
            [in] Int32 flags,
            [in] String lastRead,
            [out] IParceledListSlice** slice);

        /**
         * This implements getInstalledApplications via a "last returned row"
         * mechanism that is not exposed in the API. This is to get around the IPC
         * limit that kicks in when flags are included that bloat up the data
         * returned.
         */
        GetInstalledApplications(
            [in] Int32 flags,
            [in] String lastRead,
            [out] IParceledListSlice** slice);

        /**
         * Retrieve all applications that are marked as persistent.
         *
         * @return A List&lt;applicationInfo> containing one entry for each persistent
         *         application.
         */
        GetPersistentApplications(
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        ResolveContentProvider(
            [in] String name,
            [in] Int32 flags,
            [out] IContentProviderInfo** info);

        /**
         * Retrieve sync information for all content providers.
         *
         * @param outNames Filled in with a list of the root names of the content
         *                 providers that can sync.
         * @param outInfo Filled in with a list of the ProviderInfo for each
         *                name in 'outNames'.
         */
        QuerySyncProviders(
            [in] IObjectContainer* outNames,
            [in] IObjectContainer* outInfo);

        QueryContentProviders(
            [in] String processName,
            [in] Int32 uid,
            [in] Int32 flags,
            [out] IObjectContainer** providers);

        GetInstrumentationInfo(
            [in] IComponentName* className,
            [in] Int32 flags,
            [out] IInstrumentationInfo** info);

        QueryInstrumentation(
            [in] String targetCapsule,
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        /**
         * Install a package.
         *
         * @param packageURI The location of the package file to install.
         * @param observer a callback to use to notify when the package installation in finished.
         * @param flags - possible values: {@link #FORWARD_LOCK_PACKAGE},
         * {@link #REPLACE_EXISITING_PACKAGE}
         * @param installerPackageName Optional package name of the application that is performing the
         * installation. This identifies which market the package came from.
         */
        InstallCapsule(
            [in] IUri* capsuleURI,
            [in] ICapsuleInstallObserver* observer,
            [in] Int32 flags,
            [in] String installerCapsuleName);

        //todo: should be removed
        InstallCapsuleEx2(
            [in] String path);

        FinishCapsuleInstall(
            [in] Int32 token);

        /**
         * Delete a package.
         *
         * @param packageName The fully qualified name of the package to delete.
         * @param observer a callback to use to notify when the package deletion in finished.
         * @param flags - possible values: {@link #DONT_DELETE_DATA}
         */
        DeleteCapsule(
            [in] String capsuleName,
            [in] ICapsuleDeleteObserver* observer,
            [in] Int32 flags);

        GetInstallerCapsuleName(
            [in] String capsuleName,
            [out] String* name);

        AddCapsuleToPreferred(
            [in] String capsuleName);

        RemoveCapsuleFromPreferred(
            [in] String capsuleName);

        GetPreferredCapsules(
            [in] Int32 flags,
            [out] IObjectContainer** infos);

        AddPreferredActivity(
            [in] IIntentFilter* filter,
            [in] Int32 match,
            [in] IObjectContainer* set, /*IComponentName*/
            [in] IComponentName* activity);

        ReplacePreferredActivity(
            [in] IIntentFilter* filter,
            [in] Int32 match,
            [in] IObjectContainer* set, /*IComponentName*/
            [in] IComponentName* activity);

        ClearCapsulePreferredActivities(
            [in] String capsuleName);

        GetPreferredActivities(
            [in] IObjectContainer* outFilters,
            [in] IObjectContainer* outActivities,
            [in] String capsuleName,
            [out] Int32* count);

        /**
         * As per {@link android.content.pm.PackageManager#setComponentEnabledSetting}.
         */
        SetComponentEnabledSetting(
            [in] IComponentName* componentName,
            [in] Int32 newState,
            [in] Int32 flags);

        /**
         * As per {@link android.content.pm.PackageManager#getComponentEnabledSetting}.
         */
        GetComponentEnabledSetting(
            [in] IComponentName* componentName,
            [out] Int32* setting);

        /**
         * As per {@link android.content.pm.PackageManager#setApplicationEnabledSetting}.
         */
        SetApplicationEnabledSetting(
            [in] String capsuleName,
            [in] Int32 newState,
            [in] Int32 flags);

        /**
         * As per {@link android.content.pm.PackageManager#getApplicationEnabledSetting}.
         */
        GetApplicationEnabledSetting(
            [in] String capsuleName,
            [out] Int32* setting);

        /**
         * Free storage by deleting LRU sorted list of cache files across
         * all applications. If the currently available free storage
         * on the device is greater than or equal to the requested
         * free storage, no cache files are cleared. If the currently
         * available storage on the device is less than the requested
         * free storage, some or all of the cache files across
         * all applications are deleted (based on last accessed time)
         * to increase the free storage space on the device to
         * the requested value. There is no guarantee that clearing all
         * the cache files from all applications will clear up
         * enough storage to achieve the desired value.
         * @param freeStorageSize The number of bytes of storage to be
         * freed by the system. Say if freeStorageSize is XX,
         * and the current free storage is YY,
         * if XX is less than YY, just return. if not free XX-YY number
         * of bytes if possible.
         * @param observer call back used to notify when
         * the operation is completed
         */
        FreeStorageAndNotify(
            [in] Int64 freeStorageSize,
            [in] ICapsuleDataObserver* observer);

        /**
         * Free storage by deleting LRU sorted list of cache files across
         * all applications. If the currently available free storage
         * on the device is greater than or equal to the requested
         * free storage, no cache files are cleared. If the currently
         * available storage on the device is less than the requested
         * free storage, some or all of the cache files across
         * all applications are deleted (based on last accessed time)
         * to increase the free storage space on the device to
         * the requested value. There is no guarantee that clearing all
         * the cache files from all applications will clear up
         * enough storage to achieve the desired value.
         * @param freeStorageSize The number of bytes of storage to be
         * freed by the system. Say if freeStorageSize is XX,
         * and the current free storage is YY,
         * if XX is less than YY, just return. if not free XX-YY number
         * of bytes if possible.
         * @param pi IntentSender call back used to
         * notify when the operation is completed.May be null
         * to indicate that no call back is desired.
         */
        FreeStorage(
            [in] Int64 freeStorageSize,
            [in] IIntentSender* pi);

        /**
         * Delete all the cache files in an applications cache directory
         * @param packageName The package name of the application whose cache
         * files need to be deleted
         * @param observer a callback used to notify when the deletion is finished.
         */
        DeleteApplicationCacheFiles(
            [in] String capsuleName,
            [in] ICapsuleDataObserver* observer);

        /**
         * Clear the user data directory of an application.
         * @param packageName The package name of the application whose cache
         * files need to be deleted
         * @param observer a callback used to notify when the operation is completed.
         */
        ClearApplicationUserData(
            [in] String capsuleName,
            [in] ICapsuleDataObserver* observer);

        /**
         * Get package statistics including the code, data and cache size for
         * an already installed package
         * @param packageName The package name of the application
         * @param observer a callback to use to notify when the asynchronous
         * retrieval of information is complete.
         */
        GetCapsuleSizeInfo(
            [in] String capsuleName,
            [in] ICapsuleStatsObserver* observer);

        /**
         * Get a list of shared libraries that are available on the
         * system.
         */
        GetSystemSharedLibraryNames(
            [out, callee] ArrayOf<String>* names);

        /**
         * Get a list of features that are available on the
         * system.
         */
        GetSystemAvailableFeatures(
            [out] IObjectContainer** infos);

        HasSystemFeature(
            [in] String name,
            [out] Boolean* result);

        EnterSafeMode();

        IsSafeMode(
            [out] Boolean* isSafeMode);

        SystemReady();

        HasSystemUidErrors(
            [out] Boolean* result);

        /**
         * Update status of external media on the package manager to scan and
         * install packages installed on the external media. Like say the
         * MountService uses this to call into the package manager to update
         * status of sdcard.
         */
        UpdateExternalMediaStatus(
            [in] Boolean mounted,
            [in] Boolean reportStatus);

        NextCapsuleToClean(
            [in] String lastCapsule,
            [out] String* nextCapsule);

        MoveCapsule(
            [in] String capsuleName,
            [in] ICapsuleMoveObserver* observer,
            [in] Int32 flags);

        AddPermissionAsync(
            [in] IPermissionInfo* info,
            [out] Boolean* isAdded);

        SetInstallLocation(
            [in] Int32 loc,
            [out] Boolean* isSetted);

        GetInstallLocation(
            [out] Int32* loc);
    }
}

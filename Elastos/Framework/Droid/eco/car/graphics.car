
module
{
    merge("graphics/point.car");
    merge("graphics/rect.car");
    merge("graphics/rectf.car");
    merge("graphics/region.car");
    merge("graphics/bitmap.car");
    merge("graphics/bitmapfactory.car");
    merge("graphics/shader.car");
    merge("graphics/xfermode.car");
    merge("graphics/patheffect.car");
    merge("graphics/DashPathEffect.car");
    merge("graphics/maskfilter.car");
    merge("graphics/typeface.car");
    merge("graphics/rasterizer.car");
    merge("graphics/paint.car");
    merge("graphics/matrix.car");
    merge("graphics/path.car");
    merge("graphics/drawfilter.car");
    merge("graphics/picture.car");
    merge("graphics/porterduff.car");
    merge("graphics/canvas.car");
    merge("graphics/colorfilter.car");
    merge("graphics/movie.car");
    merge("graphics/ninepatch.car");
    merge("graphics/drawable/drawable.car");
    merge("graphics/drawable/bitmapdrawable.car");
    merge("graphics/drawable/ninepatchdrawable.car");
    merge("graphics/drawable/colordrawable.car");
    merge("graphics/drawable/DrawableContainer.car");
    merge("graphics/drawable/StateListDrawable.car");
    merge("graphics/drawable/Animatable.car");
    merge("graphics/drawable/AnimatedRotateDrawable.car");
    merge("graphics/drawable/LayerDrawable.car");
    merge("graphics/drawable/GradientDrawable.car");
    merge("graphics/drawable/ClipDrawable.car");
    merge("graphics/drawable/AnimationDrawable.car");
    merge("graphics/drawable/ShapeDrawable.car");
    merge("graphics/drawable/RotateDrawable.car");
    merge("graphics/drawable/InsetDrawable.car");
    merge("graphics/drawable/ScaleDrawable.car");
    merge("graphics/drawable/TransitionDrawable.car");
    merge("graphics/drawable/shapes/Shape.car");

    class CPoint {
        constructor();

        constructor(
            [in] Int32 x,
            [in] Int32 y);

        constructor(
            [in] IPoint* p);

        interface IPoint;
    }

    class CRect {
        constructor();

        constructor(
            [in] Int32 left,
            [in] Int32 top,
            [in] Int32 right,
            [in] Int32 bottom);

        constructor(
            [in] IRect* r);

        interface IRect;
        interface IParcelable;
    }

    class CRegion {
        /** Create an empty region
        */
        constructor();

        /** Return a copy of the specified region
        */
        constructor(
            [in] IRegion* region);

        /** Return a region set to the specified rectangle
        */
        constructor(
            [in] IRect* r);

        /** Return a region set to the specified rectangle
        */
        constructor(
            [in] Int32 left,
            [in] Int32 top,
            [in] Int32 right,
            [in] Int32 bottom);

        /*private*/ constructor(
            [in] Int32 ni);

        interface IRegion;
        interface IParcelable;
    }

    class CRectF {
        /**
         * Create a new empty RectF. All coordinates are initialized to 0.
         */
        constructor();

        /**
         * Create a new rectangle with the specified coordinates. Note: no range
         * checking is performed, so the caller must ensure that left <= right and
         * top <= bottom.
         *
         * @param left   The X coordinate of the left side of the rectagle
         * @param top    The Y coordinate of the top of the rectangle
         * @param right  The X coordinate of the right side of the rectagle
         * @param bottom The Y coordinate of the bottom of the rectangle
         */
        constructor(
            [in] Float left,
            [in] Float top,
            [in] Float right,
            [in] Float bottom);

        /**
         * Create a new rectangle, initialized with the values in the specified
         * rectangle (which is left unmodified).
         *
         * @param r The rectangle whose coordinates are copied into the new
         *          rectangle.
         */
        constructor(
            [in] IRectF* rf);

        constructor(
            [in] IRect* r);

        interface IRectF;
        interface IParcelable;
    }

    class CPaintFontMetrics {
        interface IPaintFontMetrics;
    }

    class CPaintFontMetricsInt {
        interface IPaintFontMetricsInt;
    }

    class CPaint {
        /**
         * Create a new paint with default settings.
         */
        constructor();

        /**
         * Create a new paint with the specified flags. Use setFlags() to change
         * these after the paint is created.
         *
         * @param flags initial flag bits, as if they were passed via setFlags().
         */
        constructor(
            [in] Int32 flags);

        /**
         * Create a new paint, initialized with the attributes in the specified
         * paint parameter.
         *
         * @param paint Existing paint used to initialized the attributes of the
         *              new paint.
         */
        constructor(
            [in] IPaint * paint);

        interface IPaint;
    }

    class CMatrix {
        constructor();
        constructor(
            [in] IMatrix* src);

        interface IMatrix;
    }

    class CBitmap {
        /*private*/ constructor(
            [in] Int32 nativeBitmap,
            [in] Boolean isMutable,
            [in] ArrayOf<Byte> ninePatchChunk,
            [in] Int32 density);

        interface IBitmap;
        interface IParcelable;
    }

    class CBitmapFactoryOptions {
        interface IBitmapFactoryOptions;
    }

    singleton class CBitmapFactory {
        interface IBitmapFactory;
    }

    [deprecated]
    class CLinearGradient {
        /**	Create a shader that draws a linear gradient along a line.
            @param x0           The x-coordinate for the start of the gradient line
            @param y0           The y-coordinate for the start of the gradient line
            @param x1           The x-coordinate for the end of the gradient line
            @param y1           The y-coordinate for the end of the gradient line
            @param  colors      The colors to be distributed along the gradient line
            @param  positions   May be null. The relative positions [0..1] of
                                each corresponding color in the colors array. If this is null,
                                the the colors are distributed evenly along the gradient line.
            @param  tile        The Shader tiling mode
        */
        constructor(
            [in] Float x0,
            [in] Float y0,
            [in] Float x1,
            [in] Float y1,
            [in] ArrayOf<Int32> colors,
            [in] ArrayOf<Float>* positions,
            [in] ShaderTileMode tile);

        /**	Create a shader that draws a linear gradient along a line.
            @param x0       The x-coordinate for the start of the gradient line
            @param y0       The y-coordinate for the start of the gradient line
            @param x1       The x-coordinate for the end of the gradient line
            @param y1       The y-coordinate for the end of the gradient line
            @param  color0  The color at the start of the gradient line.
            @param  color1  The color at the end of the gradient line.
            @param  tile    The Shader tiling mode
        */
        constructor(
            [in] Float x0,
            [in] Float y0,
            [in] Float x1,
            [in] Float y1,
            [in] Int32 color0,
            [in] Int32 color1,
            [in] ShaderTileMode tile);

        interface IShader;
    }

    [deprecated]
    class CRadialGradient {
        /** Create a shader that draws a radial gradient given the center and radius.
            @param x        The x-coordinate of the center of the radius
            @param y        The y-coordinate of the center of the radius
            @param radius   Must be positive. The radius of the circle for this gradient
            @param colors   The colors to be distributed between the center and edge of the circle
            @param positions May be NULL. The relative position of
                            each corresponding color in the colors array. If this is NULL,
                            the the colors are distributed evenly between the center and edge of the circle.
            @param  tile    The Shader tiling mode
        */
        constructor(
            [in] Float x,
            [in] Float y,
            [in] Float radius,
            [in] ArrayOf<Int32> colors,
            [in] ArrayOf<Float>* positions,
            [in] ShaderTileMode tile);

        /** Create a shader that draws a radial gradient given the center and radius.
            @param x        The x-coordinate of the center of the radius
            @param y        The y-coordinate of the center of the radius
            @param radius   Must be positive. The radius of the circle for this gradient
            @param color0   The color at the center of the circle.
            @param color1   The color at the edge of the circle.
            @param tile     The Shader tiling mode
        */
        constructor(
            [in] Float x,
            [in] Float y,
            [in] Float radius,
            [in] Int32 color0,
            [in] Int32 color1,
            [in] ShaderTileMode tile);

        interface IShader;
    }

    [deprecated]
    class CSweepGradient {
        /**
         * A subclass of Shader that draws a sweep gradient around a center point.
         *
         * @param cx       The x-coordinate of the center
         * @param cy       The y-coordinate of the center
         * @param colors   The colors to be distributed between around the center.
         *                 There must be at least 2 colors in the array.
         * @param positions May be NULL. The relative position of
         *                 each corresponding color in the colors array, beginning
         *                 with 0 and ending with 1.0. If the values are not
         *                 monotonic, the drawing may produce unexpected results.
         *                 If positions is NULL, then the colors are automatically
         *                 spaced evenly.
         */
        constructor(
            [in] Float cx,
            [in] Float cy,
            [in] ArrayOf<Int32> colors,
            [in] ArrayOf<Float>* positions);

        /**
         * A subclass of Shader that draws a sweep gradient around a center point.
         *
         * @param cx       The x-coordinate of the center
         * @param cy       The y-coordinate of the center
         * @param color0   The color to use at the start of the sweep
         * @param color1   The color to use at the end of the sweep
         */
        constructor(
            [in] Float cx,
            [in] Float cy,
            [in] Int32 color0,
            [in] Int32 color1);

        interface IShader;
    }

    /**
     * The Canvas class holds the "draw" calls. To draw something, you need
     * 4 basic components: A Bitmap to hold the pixels, a Canvas to host
     * the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect,
     * Path, text, Bitmap), and a paint (to describe the colors and styles for the
     * drawing).
     */
    class CCanvas {
        /**
         * Construct an empty raster canvas. Use setBitmap() to specify a bitmap to
         * draw into.  The initial target density is {@link Bitmap#DENSITY_NONE};
         * this will typically be replaced when a target bitmap is set for the
         * canvas.
         */
        constructor();

        /**
         * Construct a canvas with the specified bitmap to draw into. The bitmap
         * must be mutable.
         *
         * <p>The initial target density of the canvas is the same as the given
         * bitmap's density.
         *
         * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
         */
        constructor(
            [in] IBitmap * bitmap);

        /*package*/ constructor(
            [in] Int32 nativeCanvas);

        /**
         * Construct a canvas with the specified gl context. All drawing through
         * this canvas will be redirected to OpenGL. Note: some features may not
         * be supported in this mode (e.g. some GL implementations may not support
         * antialiasing or certain effects like ColorMatrix or certain Xfermodes).
         * However, no exception will be thrown in those cases.
         *
         * <p>The initial target density of the canvas is the same as the initial
         * density of bitmaps as per {@link Bitmap#getDensity() Bitmap.getDensity()}.
         */
        constructor(
            [in] IGL * gl);

        interface ICanvas;
    }

    class CPorterDuffColorFilter {
        constructor(
            [in] Int32 srcColor,
            [in] PorterDuffMode mode);

        interface IColorFilter;
    }

    class CMovie {
        /*private*/ constructor(
            [in] Int32 nativeMovie);

        interface IMovie;
    }

    class CBitmapDrawable {
        /**
         * Create an empty drawable, not dealing with density.
         * @deprecated Use {@link #BitmapDrawable(Resources)} to ensure
         * that the drawable has correctly set its target density.
         */
        constructor();

        /**
         * Create an empty drawable, setting initial target density based on
         * the display metrics of the resources.
         */
        constructor(
            [in] IResources* res);

        /**
         * Create drawable from a bitmap, not dealing with density.
         * @deprecated Use {@link #BitmapDrawable(Resources, Bitmap)} to ensure
         * that the drawable has correctly set its target density.
         */
        constructor(
            [in] IBitmap* bitmap);

        /**
         * Create drawable from a bitmap, setting initial target density based on
         * the display metrics of the resources.
         */
        constructor(
            [in] IResources* res,
            [in] IBitmap* bitmap);

        /**
         * Create a drawable by opening a given file path and decoding the bitmap.
         * @deprecated Use {@link #BitmapDrawable(Resources, String)} to ensure
         * that the drawable has correctly set its target density.
         */
        constructor(
            [in] String filepath);

        /**
         * Create a drawable by opening a given file path and decoding the bitmap.
         */
        constructor(
            [in] IResources* res,
            [in] String filepath);

        /**
         * Create a drawable by decoding a bitmap from the given input stream.
         * @deprecated Use {@link #BitmapDrawable(Resources, java.io.InputStream)} to ensure
         * that the drawable has correctly set its target density.
         */
        constructor(
            [in] IInputStream* is);

        /**
         * Create a drawable by decoding a bitmap from the given input stream.
         */
        constructor(
            [in] IResources* res,
            [in] IInputStream* is);

        // private
        constructor(
            [in] IBitmapState* state,
            [in] IResources* res);

        interface IBitmapDrawable;
    }

    class CNinePatchDrawable {
        constructor();

        /**
         * Create drawable from raw nine-patch data, not dealing with density.
         * @deprecated Use {@link #NinePatchDrawable(Resources, Bitmap, byte[], Rect, String)}
         * to ensure that the drawable has correctly set its target density.
         */
        constructor(
            [in] IBitmap* bitmap,
            [in] ArrayOf<Byte> chunk,
            [in] IRect* padding,
            [in] String srcName);

        /**
         * Create drawable from raw nine-patch data, setting initial target density
         * based on the display metrics of the resources.
         */
        constructor(
            [in] IResources* res,
            [in] IBitmap* bitmap,
            [in] ArrayOf<Byte> chunk,
            [in] IRect* padding,
            [in] String srcName);

        /**
         * Create drawable from existing nine-patch, not dealing with density.
         * @deprecated Use {@link #NinePatchDrawable(Resources, NinePatch)}
         * to ensure that the drawable has correctly set its target density.
         */
        constructor(
            [in] INinePatch* patch);

        /**
         * Create drawable from existing nine-patch, setting initial target density
         * based on the display metrics of the resources.
         */
        constructor(
            [in] IResources* res,
            [in] INinePatch* patch);

        constructor(
            [in] Handle32 state,
            [in] IResources* res);

        interface INinePatchDrawable;
    }

    class CColorDrawable {
        /**
         * Creates a new black ColorDrawable.
         */
        constructor();

        /**
         * Creates a new ColorDrawable with the specified color.
         *
         * @param color The color to draw.
         */
        constructor(
            [in] Int32 color);

        /*private*/ constructor(
            [in] IColorState* state);

        interface IColorDrawable;
    }

    class CStateListDrawable {
        constructor();

        constructor(
            [in] Handle32 state,
            [in] IResources* res);

        interface IStateListDrawable;
    }

    class CAnimatedRotateDrawable {
        constructor();

        constructor(
            [in] IDrawableConstantState* state,
            [in] IResources* res);

        interface IAnimatedRotateDrawable;
        interface IDrawableCallback;
        interface IRunnable;
        interface IAnimatable;
    }

    class CLayerDrawable {
        constructor();

        /**
         * Create a new layer drawable with the list of specified layers.
         *
         * @param layers A list of drawables to use as layers in this new drawable.
         */
        constructor(
            [in] IObjectContainer* layers);

        /**
         * Create a new layer drawable with the specified list of layers and the specified
         * constant state.
         *
         * @param layers The list of layers to add to this drawable.
         * @param state The constant drawable state.
         */
        constructor(
            [in] IObjectContainer* layers,
            [in] IDrawableConstantState* state);

        constructor(
            [in] IDrawableConstantState* state,
            [in] IResources* res);

        interface ILayerDrawable;
        interface IDrawableCallback;
    }

    [deprecated]
    class CGradientDrawable {
        constructor();

        /**
         * Create a new gradient drawable given an orientation and an array
         * of colors for the gradient.
         */
        constructor(
            [in] GradientDrawableOrientation orientation,
            [in] ArrayOf<Int32>* colors);

        constructor(
            [in] IGradientState* state);

        interface IGradientDrawable;
    }

    class CClipDrawable {
        constructor();

        /**
         * @param orientation Bitwise-or of {@link #HORIZONTAL} and/or {@link #VERTICAL}
         */
        constructor(
            [in] IDrawable* drawable,
            [in] Int32 gravity,
            [in] Int32 orientation);

        constructor(
            [in] IClipState* state,
            [in] IResources* res);

        interface IClipDrawable;
        interface IDrawableCallback;
    }

    class CAnimationDrawable {
        constructor();

        constructor(
            [in] Handle32 state,
            [in] IResources* res);

        interface IAnimationDrawable;
        interface IRunnable;
        interface IAnimatable;
    }

    class CShapeDrawable {
        /**
         * ShapeDrawable constructor.
         */
        constructor();

        /**
         * Creates a ShapeDrawable with a specified Shape.
         *
         * @param s the Shape that this ShapeDrawable should be
         */
        constructor(
            [in] IShape* s);

        constructor(
            [in] Handle32 state);

        interface IShapeDrawable;
    }

    class CRotateDrawable {
        /**
         * <p>Create a new rotating drawable with an empty state.</p>
         */
        constructor();

        /**
         * <p>Create a new rotating drawable with the specified state. A copy of
         * this state is used as the internal state for the newly created
         * drawable.</p>
         *
         * @param rotateState the state for this drawable
         */
        constructor(
            [in] Handle32 state,
            [in] IResources* res);

        interface IRotateDrawable;
        interface IDrawableCallback;
    }

    class CInsetDrawable {
        /*package*/ constructor();

        constructor(
            [in] IDrawable* drawable,
            [in] Int32 inset);

        constructor(
            [in] IDrawable* drawable,
            [in] Int32 insetLeft,
            [in] Int32 insetTop,
            [in] Int32 insetRight,
            [in] Int32 insetBottom);

        constructor(
            [in] Handle32 state,
            [in] IResources* res);

        interface IInsetDrawable;
        interface IDrawableCallback;
    }

    class CScaleDrawable {
        constructor();

        constructor(
            [in] IDrawable* drawable,
            [in] Int32 gravity,
            [in] Float scaleWidth,
            [in] Float scaleHeight);

        constructor(
            [in] Handle32 state,
            [in] IResources* res);

        interface IScaleDrawable;
        interface IDrawableCallback;
    }

    class CTransitionDrawable {
        /**
         * Create a new transition drawable with the specified list of layers. At least
         * 2 layers are required for this drawable to work properly.
         */
        constructor(
            [in] IObjectContainer* layers);

        /**
         * Create a new transition drawable with no layer. To work correctly, at least 2
         * layers must be added to this drawable.
         *
         * @see #TransitionDrawable(Drawable[])
         */
        constructor();

        constructor(
            [in] Handle32 state,
            [in] IResources* res);

        constructor(
            [in] Handle32 state,
            [in] IObjectContainer* layers);

        interface ITransitionDrawable;
        interface IDrawableCallback;
    }

    class CNinePatch {
        /**
         * Create a drawable projection from a bitmap to nine patches.
         *
         * @param bitmap    The bitmap describing the patches.
         * @param chunk     The 9-patch data chunk describing how the underlying
         *                  bitmap is split apart and drawn.
         * @param srcName   The name of the source for the bitmap. Might be null.
         */
        constructor(
            [in] IBitmap* bitmap,
            [in] ArrayOf<Byte> chunk,
            [in] String srcName);

        /**
         * @hide
         */
        constructor(
            [in] INinePatch* patch);

        interface INinePatch;
    }

    class CPorterDuffXfermode {
        constructor(
            [in] PorterDuffMode mode);

        interface IXfermode;
    }

    class CPath {
        constructor();

        constructor(
            [in] IPath* path);

        interface IPath;
    }

    class CBitmapShader {
        constructor(
            [in] IBitmap* bitmap,
            [in] ShaderTileMode tileX,
            [in] ShaderTileMode tileY);

        interface IShader;
    }

    class CTypeface {
        interface ITypeface;
    }

    singleton class CTypefaceFactory {
        interface ITypefaceFactory;
    }

    class CDashPathEffect {
        constructor(
            [in] ArrayOf<Float> intervals,
            [in] Float phase);

        interface IDashPathEffect;
    }

    class CArcShape {
        constructor();

        /**
         * ArcShape constructor.
         *
         * @param startAngle the angle (in degrees) where the arc begins
         * @param sweepAngle the sweep angle (in degrees). Anything equal to or
         *                   greater than 360 results in a complete circle/oval.
         */
        constructor(
            [in] Float startAngle,
            [in] Float sweepAngle);

        interface IShape;
    }

    class COvalShape {
        constructor();

        interface IShape;
    }

    class CPathShape {
        constructor();

        /**
         * PathShape constructor.
         *
         * @param path       a Path that defines the geometric paths for this shape
         * @param stdWidth   the standard width for the shape. Any changes to the
         *                   width with resize() will result in a width scaled based
         *                   on the new width divided by this width.
         * @param stdHeight  the standard height for the shape. Any changes to the
         *                   height with resize() will result in a height scaled based
         *                   on the new height divided by this height.
         */
        constructor(
            [in] IPath* path,
            [in] Float stdWidth,
            [in] Float stdHeight);

        interface IShape;
    }

    class CRectShape {
        constructor();

        interface IShape;
    }

    [deprecated]
    class CRoundRectShape {
        constructor();

        /**
         * RoundRectShape constructor.
         * Specifies an outer (round)rect and an optional inner (round)rect.
         *
         * @param outerRadii An array of 8 radius values, for the outer roundrect.
         *                   The first two floats are for the
         *                   top-left corner (remaining pairs correspond clockwise).
         *                   For no rounded corners on the outer rectangle,
         *                   pass null.
         * @param inset      A RectF that specifies the distance from the inner
         *                   rect to each side of the outer rect.
         *                   For no inner, pass null.
         * @param innerRadii An array of 8 radius values, for the inner roundrect.
         *                   The first two floats are for the
         *                   top-left corner (remaining pairs correspond clockwise).
         *                   For no rounded corners on the inner rectangle,
         *                   pass null.
         *                   If inset parameter is null, this parameter is ignored.
         */
        constructor(
            [in] ArrayOf<Float>* outerRadii,
            [in] IRectF* inset,
            [in] ArrayOf<Float>* innerRadii);

        interface IShape;
    }
}


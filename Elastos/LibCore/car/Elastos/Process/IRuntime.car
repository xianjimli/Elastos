
module
{
    /**
     * Allows Java applications to interface with the environment in which they are
     * running. Applications can not create an instance of this class, but they can
     * get a singleton instance by invoking {@link #getRuntime()}.
     *
     * @see System
     */
    [deprecated]
    interface IRuntime {
        /**
         * Executes the specified command and its arguments in a separate native
         * process. The new process inherits the environment of the caller. Calling
         * this method is equivalent to calling {@code exec(progArray, null, null)}.
         *
         * @param progArray
         *            the array containing the program to execute as well as any
         *            arguments to the program.
         * @return the new {@code Process} object that represents the native
         *         process.
         * @throws IOException
         *             if the requested program can not be executed.
         * @throws SecurityException
         *             if the current {@code SecurityManager} disallows program
         *             execution.
         * @see SecurityManager#checkExec
         */
        Exec(
            [in] ArrayOf<String> progArray,
            [out] IProcess** proc);

        /**
         * Executes the specified command and its arguments in a separate native
         * process. The new process uses the environment provided in {@code envp}.
         * Calling this method is equivalent to calling
         * {@code exec(progArray, envp, null)}.
         *
         * @param progArray
         *            the array containing the program to execute as well as any
         *            arguments to the program.
         * @param envp
         *            the array containing the environment to start the new process
         *            in.
         * @return the new {@code Process} object that represents the native
         *         process.
         * @throws IOException
         *             if the requested program can not be executed.
         * @throws SecurityException
         *             if the current {@code SecurityManager} disallows program
         *             execution.
         * @see SecurityManager#checkExec
         */
        ExecEx(
            [in] ArrayOf<String> progArray,
            [in] ArrayOf<String> envp,
            [out] IProcess** proc);

        /**
         * Executes the specified command and its arguments in a separate native
         * process. The new process uses the environment provided in {@code envp}
         * and the working directory specified by {@code directory}.
         *
         * @param progArray
         *            the array containing the program to execute as well as any
         *            arguments to the program.
         * @param envp
         *            the array containing the environment to start the new process
         *            in.
         * @param directory
         *            the directory in which to execute the program. If {@code null},
         *            execute if in the same directory as the parent process.
         * @return the new {@code Process} object that represents the native
         *         process.
         * @throws IOException
         *             if the requested program can not be executed.
         * @throws SecurityException
         *             if the current {@code SecurityManager} disallows program
         *             execution.
         * @see SecurityManager#checkExec
         */
        ExecEx2(
            [in] ArrayOf<String> progArray,
            [in] ArrayOf<String>* envp,
            [in] IFile* directory,
            [out] IProcess** proc);

        /**
         * Executes the specified program in a separate native process. The new
         * process inherits the environment of the caller. Calling this method is
         * equivalent to calling {@code exec(prog, null, null)}.
         *
         * @param prog
         *            the name of the program to execute.
         * @return the new {@code Process} object that represents the native
         *         process.
         * @throws IOException
         *             if the requested program can not be executed.
         * @throws SecurityException
         *             if the current {@code SecurityManager} disallows program
         *             execution.
         * @see SecurityManager#checkExec
         */
        ExecEx3(
            [in] String prog,
            [out] IProcess** proc);

        /**
         * Executes the specified program in a separate native process. The new
         * process uses the environment provided in {@code envp}. Calling this
         * method is equivalent to calling {@code exec(prog, envp, null)}.
         *
         * @param prog
         *            the name of the program to execute.
         * @param envp
         *            the array containing the environment to start the new process
         *            in.
         * @return the new {@code Process} object that represents the native
         *         process.
         * @throws IOException
         *             if the requested program can not be executed.
         * @throws SecurityException
         *             if the current {@code SecurityManager} disallows program
         *             execution.
         * @see SecurityManager#checkExec
         */
        ExecEx4(
            [in] String prog,
            [in] ArrayOf<String> envp,
            [out] IProcess** proc);

        /**
         * Executes the specified program in a separate native process. The new
         * process uses the environment provided in {@code envp} and the working
         * directory specified by {@code directory}.
         *
         * @param prog
         *            the name of the program to execute.
         * @param envp
         *            the array containing the environment to start the new process
         *            in.
         * @param directory
         *            the directory in which to execute the program. If {@code null},
         *            execute if in the same directory as the parent process.
         * @return the new {@code Process} object that represents the native
         *         process.
         * @throws IOException
         *             if the requested program can not be executed.
         * @throws SecurityException
         *             if the current {@code SecurityManager} disallows program
         *             execution.
         * @see SecurityManager#checkExec
         */
        ExecEx5(
            [in] String prog,
            [in] ArrayOf<String> envp,
            [in] IFile* directory,
            [out] IProcess** proc);

        /**
         * Causes the virtual machine to stop running and the program to exit. If
         * {@link #runFinalizersOnExit(boolean)} has been previously invoked with a
         * {@code true} argument, then all objects will be properly
         * garbage-collected and finalized first.
         *
         * @param code
         *            the return code. By convention, non-zero return codes indicate
         *            abnormal terminations.
         * @throws SecurityException
         *             if the current {@code SecurityManager} does not allow the
         *             running thread to terminate the virtual machine.
         * @see SecurityManager#checkExit
         */
        Exit(
            [in] Int32 code);

        /**
         * Returns the amount of free memory resources which are available to the
         * running program.
         *
         * @return the approximate amount of free memory, measured in bytes.
         */
//        public native long freeMemory();

        /**
         * Indicates to the virtual machine that it would be a good time to run the
         * garbage collector. Note that this is a hint only. There is no guarantee
         * that the garbage collector will actually be run.
         */
//        public native void gc();

        /**
         * Loads and links the dynamic library that is identified through the
         * specified path. This method is similar to {@link #loadLibrary(String)},
         * but it accepts a full path specification whereas {@code loadLibrary} just
         * accepts the name of the library to load.
         *
         * @param pathName
         *            the absolute (platform dependent) path to the library to load.
         * @throws UnsatisfiedLinkError
         *             if the library can not be loaded.
         * @throws SecurityException
         *             if the current {@code SecurityManager} does not allow to load
         *             the library.
         * @see SecurityManager#checkLink
         */
        Load(
            [in] String pathName);

        /**
         * Loads and links the library with the specified name. The mapping of the
         * specified library name to the full path for loading the library is
         * implementation-dependent.
         *
         * @param libName
         *            the name of the library to load.
         * @throws UnsatisfiedLinkError
         *             if the library can not be loaded.
         * @throws SecurityException
         *             if the current {@code SecurityManager} does not allow to load
         *             the library.
         * @see SecurityManager#checkLink
         */
        LoadLibrary(
            [in] String libName);

        /**
         * Returns the total amount of memory which is available to the running
         * program.
         *
         * @return the total amount of memory, measured in bytes.
         */
//        public native long totalMemory();

        /**
         * Switches the output of debug information for instructions on or off.
         * On Android, this method does nothing.
         *
         * @param enable
         *            {@code true} to switch tracing on, {@code false} to switch it
         *            off.
         */
//        public void traceInstructions(boolean enable);

        /**
         * Switches the output of debug information for methods on or off.
         *
         * @param enable
         *            {@code true} to switch tracing on, {@code false} to switch it
         *            off.
         */
//        public void traceMethodCalls(boolean enable)

        /**
         * Returns the localized version of the specified input stream. The input
         * stream that is returned automatically converts all characters from the
         * local character set to Unicode after reading them from the underlying
         * stream.
         *
         * @param stream
         *            the input stream to localize.
         * @return the localized input stream.
         * @deprecated Use {@link InputStreamReader}.
         */
        //@Deprecated
//        public InputStream getLocalizedInputStream(InputStream stream)

        /**
         * Returns the localized version of the specified output stream. The output
         * stream that is returned automatically converts all characters from
         * Unicode to the local character set before writing them to the underlying
         * stream.
         *
         * @param stream
         *            the output stream to localize.
         * @return the localized output stream.
         * @deprecated Use {@link OutputStreamWriter}.
         */
        //@Deprecated
//        public OutputStream getLocalizedOutputStream(OutputStream stream)

        /**
         * Registers a virtual-machine shutdown hook. A shutdown hook is a
         * {@code Thread} that is ready to run, but has not yet been started. All
         * registered shutdown hooks will be executed once the virtual machine shuts
         * down properly. A proper shutdown happens when either the
         * {@link #exit(int)} method is called or the surrounding system decides to
         * terminate the application, for example in response to a {@code CTRL-C} or
         * a system-wide shutdown. A termination of the virtual machine due to the
         * {@link #halt(int)} method, an {@link Error} or a {@code SIGKILL}, in
         * contrast, is not considered a proper shutdown. In these cases the
         * shutdown hooks will not be run.
         * <p>
         * Shutdown hooks are run concurrently and in an unspecified order. Hooks
         * failing due to an unhandled exception are not a problem, but the stack
         * trace might be printed to the console. Once initiated, the whole shutdown
         * process can only be terminated by calling {@code halt()}.
         * <p>
         * If {@link #runFinalizersOnExit(boolean)} has been called with a {@code
         * true} argument, garbage collection and finalization will take place after
         * all hooks are either finished or have failed. Then the virtual machine
         * terminates.
         * <p>
         * It is recommended that shutdown hooks do not do any time-consuming
         * activities, in order to not hold up the shutdown process longer than
         * necessary.
         *
         * @param hook
         *            the shutdown hook to register.
         * @throws IllegalArgumentException
         *             if the hook has already been started or if it has already
         *             been registered.
         * @throws IllegalStateException
         *             if the virtual machine is already shutting down.
         * @throws SecurityException
         *             if a SecurityManager is registered and the calling code
         *             doesn't have the RuntimePermission("shutdownHooks").
         */
//        public void addShutdownHook(Thread hook)

        /**
         * Unregisters a previously registered virtual machine shutdown hook.
         *
         * @param hook
         *            the shutdown hook to remove.
         * @return {@code true} if the hook has been removed successfully; {@code
         *         false} otherwise.
         * @throws IllegalStateException
         *             if the virtual machine is already shutting down.
         * @throws SecurityException
         *             if a SecurityManager is registered and the calling code
         *             doesn't have the RuntimePermission("shutdownHooks").
         */
//        public boolean removeShutdownHook(Thread hook)

        /**
         * Causes the virtual machine to stop running, and the program to exit.
         * Neither shutdown hooks nor finalizers are run before.
         *
         * @param code
         *            the return code. By convention, non-zero return codes indicate
         *            abnormal terminations.
         * @throws SecurityException
         *             if the current {@code SecurityManager} does not allow the
         *             running thread to terminate the virtual machine.
         * @see SecurityManager#checkExit
         * @see #addShutdownHook(Thread)
         * @see #removeShutdownHook(Thread)
         * @see #runFinalizersOnExit(boolean)
         */
//        public void halt(int code)

        /**
         * Returns the number of processors available to the virtual machine.
         *
         * @return the number of available processors, at least 1.
         */
//        public native int availableProcessors();

        /**
         * Returns the maximum amount of memory that may be used by the virtual
         * machine, or {@code Long.MAX_VALUE} if there is no such limit.
         *
         * @return the maximum amount of memory that the virtual machine will try to
         *         allocate, measured in bytes.
         */
//        public native long maxMemory()
    }
}

module
{
    interface IFileChannel;

    /**
     * A {@code FileLock} represents a locked region of a file.
     * <p>
     * Locks have certain properties that enable collaborating processes to avoid
     * the lost update problem or reading inconsistent data. Logically, a file lock
     * can be <em>exclusive</em> or <em>shared</em>. Multiple processes can hold
     * shared locks on the same region of a file, but only a single process can hold
     * an exclusive lock on a given region of a file and no other process can
     * simultaneously hold a shared lock overlapping the exclusive lock. An
     * application can determine whether a {@code FileLock} is shared or exclusive
     * via the {@code isShared()} method.
     * <p>
     * Locks held by a particular process cannot overlap one another. Applications
     * can determine whether a proposed lock will overlap by using the {@code
     * overlaps(long, long)}) method. Locks held in other processes may overlap
     * locks held in this process. Locks are shared amongst all threads in the
     * acquiring process, and are therefore unsuitable for intra-process
     * synchronization.
     * <p>
     * Once a lock is acquired, it is immutable in all its state except {@code
     * isValid()}. The lock will initially be valid, but may be rendered invalid by
     * explicit removal of the lock, using {@code release()}, or implicitly by
     * closing the channel or exiting the process (terminating the virtual machine).
     * <h3>Platform dependencies</h3>
     * <p>
     * Locks are intended to be true platform operating system file locks, and
     * therefore locks held by the virtual machine process will be visible to other
     * operating system processes.
     * <p>
     * The characteristics of the underlying operating system locks will show
     * through in the Java implementation. For example, some platforms' locks are
     * 'mandatory' -- meaning the operating system enforces the locks on processes
     * that attempt to access locked regions of files; whereas other platforms'
     * locks are only 'advisory' -- meaning that processes are required to
     * collaborate to ensure locks are acquired and there is a potential for
     * processes to not play well. To be on the safe side, it is best to assume that
     * the platform is adopting advisory locks and always acquire shared locks when
     * reading a region of a file.
     * <p>
     * On some platforms, the presence of a lock will prevent the file from being
     * memory-mapped. On some platforms, closing a channel on a given file handle
     * will release all the locks held on that file -- even if there are other
     * channels open on the same file; their locks will also be released. The safe
     * option here is to ensure that you only acquire locks on a single channel for
     * a particular file and that becomes the synchronization point.
     * <p>
     * Further care should be exercised when locking files maintained on network
     * file systems, since they often have further limitations.
     */
    interface IFileLock {
        /**
         * Returns the lock's {@link FileChannel}.
         *
         * @return the channel.
         */
        Channel(
            [out] IFileChannel** channel);

        /**
         * Returns the lock's starting position in the file.
         *
         * @return the lock position.
         */
        Position(
            [out] Int64* position);

        /**
         * Returns the length of the file lock in bytes.
         *
         * @return the size of the file lock in bytes.
         */
        Size(
            [out] Int64* size);

        /**
         * Indicates if the file lock is shared with other processes or if it is
         * exclusive.
         *
         * @return {@code true} if the lock is a shared lock, {@code false} if it is
         *         exclusive.
         */
        IsShared(
            [out] Boolean* isShared);

        /**
         * Indicates if the receiver's lock region overlaps the region described
         * in the parameter list.
         *
         * @param start
         *            the starting position for the comparative lock.
         * @param length
         *            the length of the comparative lock.
         * @return {@code true} if there is an overlap, {@code false} otherwise.
         */
        Overlaps(
            [in] Int64 start,
            [in] Int64 length,
            [out] Boolean* overlap);

        /**
         * Indicates whether this lock is a valid file lock. The lock is
         * valid unless the underlying channel has been closed or it has been
         * explicitly released.
         *
         * @return {@code true} if the lock is valid, {@code false} otherwise.
         */
        IsValid(
            [out] Boolean* isValid);

        /**
         * Releases this particular lock on the file. If the lock is invalid then
         * this method has no effect. Once released, the lock becomes invalid.
         *
         * @throws ClosedChannelException
         *             if the channel is already closed when an attempt to release
         *             the lock is made.
         * @throws IOException
         *             if another I/O error occurs.
         */
        Release();
    }
}

module
{
    interface ILocale;
    interface ITimeZone;
    interface IDate;

    /**
     * Value of the {@code MONTH} field indicating the first month of the
     * year.
     */
    const Calendar_JANUARY = 0;

    /**
     * Value of the {@code MONTH} field indicating the second month of
     * the year.
     */
    const Calendar_FEBRUARY = 1;

    /**
     * Value of the {@code MONTH} field indicating the third month of the
     * year.
     */
    const Calendar_MARCH = 2;

    /**
     * Value of the {@code MONTH} field indicating the fourth month of
     * the year.
     */
    const Calendar_APRIL = 3;

    /**
     * Value of the {@code MONTH} field indicating the fifth month of the
     * year.
     */
    const Calendar_MAY = 4;

    /**
     * Value of the {@code MONTH} field indicating the sixth month of the
     * year.
     */
    const Calendar_JUNE = 5;

    /**
     * Value of the {@code MONTH} field indicating the seventh month of
     * the year.
     */
    const Calendar_JULY = 6;

    /**
     * Value of the {@code MONTH} field indicating the eighth month of
     * the year.
     */
    const Calendar_AUGUST = 7;

    /**
     * Value of the {@code MONTH} field indicating the ninth month of the
     * year.
     */
    const Calendar_SEPTEMBER = 8;

    /**
     * Value of the {@code MONTH} field indicating the tenth month of the
     * year.
     */
    const Calendar_OCTOBER = 9;

    /**
     * Value of the {@code MONTH} field indicating the eleventh month of
     * the year.
     */
    const Calendar_NOVEMBER = 10;

    /**
     * Value of the {@code MONTH} field indicating the twelfth month of
     * the year.
     */
    const Calendar_DECEMBER = 11;

    /**
     * Value of the {@code MONTH} field indicating the thirteenth month
     * of the year. Although {@code GregorianCalendar} does not use this
     * value, lunar calendars do.
     */
    const Calendar_UNDECIMBER = 12;

    /**
     * Value of the {@code DAY_OF_WEEK} field indicating Sunday.
     */
    const Calendar_SUNDAY = 1;

    /**
     * Value of the {@code DAY_OF_WEEK} field indicating Monday.
     */
    const Calendar_MONDAY = 2;

    /**
     * Value of the {@code DAY_OF_WEEK} field indicating Tuesday.
     */
    const Calendar_TUESDAY = 3;

    /**
     * Value of the {@code DAY_OF_WEEK} field indicating Wednesday.
     */
    const Calendar_WEDNESDAY = 4;

    /**
     * Value of the {@code DAY_OF_WEEK} field indicating Thursday.
     */
    const Calendar_THURSDAY = 5;

    /**
     * Value of the {@code DAY_OF_WEEK} field indicating Friday.
     */
    const Calendar_FRIDAY = 6;

    /**
     * Value of the {@code DAY_OF_WEEK} field indicating Saturday.
     */
    const Calendar_SATURDAY = 7;

	/**
     * Field number for {@code get} and {@code set} indicating the
     * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
     * value; see subclass documentation.
     *
     * @see GregorianCalendar#AD
     * @see GregorianCalendar#BC
     */
    const Calendar_ERA = 0;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * year. This is a calendar-specific value; see subclass documentation.
     */
    const Calendar_YEAR = 1;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * month. This is a calendar-specific value. The first month of the year is
     * {@code JANUARY}; the last depends on the number of months in a
     * year.
     *
     * @see #JANUARY
     * @see #FEBRUARY
     * @see #MARCH
     * @see #APRIL
     * @see #MAY
     * @see #JUNE
     * @see #JULY
     * @see #AUGUST
     * @see #SEPTEMBER
     * @see #OCTOBER
     * @see #NOVEMBER
     * @see #DECEMBER
     * @see #UNDECIMBER
     */
    const Calendar_MONTH = 2;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * week number within the current year. The first week of the year, as
     * defined by {@code getFirstDayOfWeek()} and
     * {@code getMinimalDaysInFirstWeek()}, has value 1. Subclasses
     * define the value of {@code WEEK_OF_YEAR} for days before the first
     * week of the year.
     *
     * @see #getFirstDayOfWeek
     * @see #getMinimalDaysInFirstWeek
     */
    const Calendar_WEEK_OF_YEAR = 3;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * week number within the current month. The first week of the month, as
     * defined by {@code getFirstDayOfWeek()} and
     * {@code getMinimalDaysInFirstWeek()}, has value 1. Subclasses
     * define the value of {@code WEEK_OF_MONTH} for days before the
     * first week of the month.
     *
     * @see #getFirstDayOfWeek
     * @see #getMinimalDaysInFirstWeek
     */
    const Calendar_WEEK_OF_MONTH = 4;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * day of the month. This is a synonym for {@code DAY_OF_MONTH}. The
     * first day of the month has value 1.
     *
     * @see #DAY_OF_MONTH
     */
    const Calendar_DATE = 5;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * day of the month. This is a synonym for {@code DATE}. The first
     * day of the month has value 1.
     *
     * @see #DATE
     */
    const Calendar_DAY_OF_MONTH = 5;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * day number within the current year. The first day of the year has value
     * 1.
     */
    const Calendar_DAY_OF_YEAR = 6;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * day of the week. This field takes values {@code SUNDAY},
     * {@code MONDAY}, {@code TUESDAY}, {@code WEDNESDAY},
     * {@code THURSDAY}, {@code FRIDAY}, and
     * {@code SATURDAY}.
     *
     * @see #SUNDAY
     * @see #MONDAY
     * @see #TUESDAY
     * @see #WEDNESDAY
     * @see #THURSDAY
     * @see #FRIDAY
     * @see #SATURDAY
     */
    const Calendar_DAY_OF_WEEK = 7;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * ordinal number of the day of the week within the current month. Together
     * with the {@code DAY_OF_WEEK} field, this uniquely specifies a day
     * within a month. Unlike {@code WEEK_OF_MONTH} and
     * {@code WEEK_OF_YEAR}, this field's value does <em>not</em>
     * depend on {@code getFirstDayOfWeek()} or
     * {@code getMinimalDaysInFirstWeek()}. {@code DAY_OF_MONTH 1}
     * through {@code 7} always correspond to <code>DAY_OF_WEEK_IN_MONTH
     * 1</code>;
     * {@code 8} through {@code 15} correspond to
     * {@code DAY_OF_WEEK_IN_MONTH 2}, and so on.
     * {@code DAY_OF_WEEK_IN_MONTH 0} indicates the week before
     * {@code DAY_OF_WEEK_IN_MONTH 1}. Negative values count back from
     * the end of the month, so the last Sunday of a month is specified as
     * {@code DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1}. Because
     * negative values count backward they will usually be aligned differently
     * within the month than positive values. For example, if a month has 31
     * days, {@code DAY_OF_WEEK_IN_MONTH -1} will overlap
     * {@code DAY_OF_WEEK_IN_MONTH 5} and the end of {@code 4}.
     *
     * @see #DAY_OF_WEEK
     * @see #WEEK_OF_MONTH
     */
    const Calendar_DAY_OF_WEEK_IN_MONTH = 8;

    /**
     * Field number for {@code get} and {@code set} indicating
     * whether the {@code HOUR} is before or after noon. E.g., at
     * 10:04:15.250 PM the {@code AM_PM} is {@code PM}.
     *
     * @see #AM
     * @see #PM
     * @see #HOUR
     */
    const Calendar_AM_PM = 9;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * hour of the morning or afternoon. {@code HOUR} is used for the
     * 12-hour clock. E.g., at 10:04:15.250 PM the {@code HOUR} is 10.
     *
     * @see #AM_PM
     * @see #HOUR_OF_DAY
     */
    const Calendar_HOUR = 10;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * hour of the day. {@code HOUR_OF_DAY} is used for the 24-hour
     * clock. E.g., at 10:04:15.250 PM the {@code HOUR_OF_DAY} is 22.
     *
     * @see #HOUR
     */
    const Calendar_HOUR_OF_DAY = 11;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * minute within the hour. E.g., at 10:04:15.250 PM the {@code MINUTE}
     * is 4.
     */
    const Calendar_MINUTE = 12;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * second within the minute. E.g., at 10:04:15.250 PM the
     * {@code SECOND} is 15.
     */
    const Calendar_SECOND = 13;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * millisecond within the second. E.g., at 10:04:15.250 PM the
     * {@code MILLISECOND} is 250.
     */
    const Calendar_MILLISECOND = 14;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * raw offset from GMT in milliseconds.
     */
    const Calendar_ZONE_OFFSET = 15;

    /**
     * Field number for {@code get} and {@code set} indicating the
     * daylight savings offset in milliseconds.
     */
    const Calendar_DST_OFFSET = 16;

    /**
     * This is the total number of fields in this calendar.
     */
    const Calendar_FIELD_COUNT = 17;

    /**
     * Value of the {@code AM_PM} field indicating the period of the day
     * from midnight to just before noon.
     */
    const Calendar_AM = 0;

    /**
     * Value of the {@code AM_PM} field indicating the period of the day
     * from noon to just before midnight.
     */
    const Calendar_PM = 1;

    /**
     * Requests both {@code SHORT} and {@code LONG} styles in the map returned by
     * {@link #getDisplayNames}.
     * @since 1.6
     */
    const Calendar_ALL_STYLES = 0;

    /**
     * Requests short names (such as "Jan") from
     * {@link #getDisplayName} or {@link #getDisplayNames}.
     * @since 1.6
     */
    const Calendar_SHORT = 1;

    /**
     * Requests long names (such as "January") from
     * {@link #getDisplayName} or {@link #getDisplayNames}.
     * @since 1.6
     */
    const Calendar_LONG = 2;

    interface ICalendar {
		/**
		 * Adds the specified amount to a {@code Calendar} field.
		 *
		 * @param field
		 *            the {@code Calendar} field to modify.
		 * @param value
		 *            the amount to add to the field.
		 * @throws IllegalArgumentException
		 *                if {@code field} is {@code DST_OFFSET} or {@code
		 *                ZONE_OFFSET}.
		 */
		Add(
            [in] Int32 field,
            [in] Int32 value);

		/**
		 * Returns whether the {@code Date} specified by this {@code Calendar} instance is after the {@code Date}
		 * specified by the parameter. The comparison is not dependent on the time
		 * zones of the {@code Calendar}.
		 *
		 * @param calendar
		 *            the {@code Calendar} instance to compare.
		 * @return {@code true} when this Calendar is after calendar, {@code false} otherwise.
		 * @throws IllegalArgumentException
		 *                if the time is not set and the time cannot be computed
		 *                from the current field values.
		 */
		IsAfter(
            [in] IInterface* calendar,
            [out] Boolean* result);

		/**
		 * Returns whether the {@code Date} specified by this {@code Calendar} instance is before the
		 * {@code Date} specified by the parameter. The comparison is not dependent on the
		 * time zones of the {@code Calendar}.
		 *
		 * @param calendar
		 *            the {@code Calendar} instance to compare.
		 * @return {@code true} when this Calendar is before calendar, {@code false} otherwise.
		 * @throws IllegalArgumentException
		 *                if the time is not set and the time cannot be computed
		 *                from the current field values.
		 */
		IsBefore(
            [in] IInterface* calendar,
            [out] Boolean* result);

		/**
		 * Clears all of the fields of this {@code Calendar}. All fields are initialized to
		 * zero.
		 */
		Clear();

		/**
		 * Clears the specified field to zero and sets the isSet flag to {@code false}.
		 *
		 * @param field
		 *            the field to clear.
		 */
		ClearEx(
            [in] Int32 field);

		/**
		 * Gets the value of the specified field after computing the field values by
		 * calling {@code complete()} first.
		 *
		 * @param field
		 *            the field to get.
		 * @return the value of the specified field.
		 *
		 * @throws IllegalArgumentException
		 *                if the fields are not set, the time is not set, and the
		 *                time cannot be computed from the current field values.
		 * @throws ArrayIndexOutOfBoundsException
		 *                if the field is not inside the range of possible fields.
		 *                The range is starting at 0 up to {@code FIELD_COUNT}.
		 */
		Get(
            [in] Int32 field,
            [out] Int32* value);

		/**
		 * Gets the maximum value of the specified field for the current date.
		 *
		 * @param field
		 *            the field.
		 * @return the maximum value of the specified field.
		 */
		GetActualMaximum(
            [in] Int32 field,
            [out] Int32* value);

		/**
		 * Gets the minimum value of the specified field for the current date.
		 *
		 * @param field
		 *            the field.
		 * @return the minimum value of the specified field.
		 */
		GetActualMinimum(
            [in] Int32 field,
            [out] Int32* value);

		/**
		 * Returns an array of locales for which custom {@code Calendar} instances
		 * are available.
		 * <p>Note that Android does not support user-supplied locale service providers.
		 */
//		public static synchronized Locale[] getAvailableLocales() {
//			return ICU.getAvailableCalendarLocales();
//		}

		/**
		 * Gets the first day of the week for this {@code Calendar}.
		 *
		 * @return the first day of the week.
		 */
		GetFirstDayOfWeek(
		    [out] Int32* firstDayOfWeek);

		/**
		 * Gets the greatest minimum value of the specified field. This is the
		 * biggest value that {@code getActualMinimum} can return for any possible
		 * time.
		 *
		 * @param field
		 *            the field.
		 * @return the greatest minimum value of the specified field.
		 */
		GetGreatestMinimum(
            [in] Int32 field,
            [out] Int32* minimum);

		/**
		 * Constructs a new instance of the {@code Calendar} subclass appropriate for the
		 * default {@code Locale}.
		 *
		 * @return a {@code Calendar} subclass instance set to the current date and time in
		 *         the default {@code Timezone}.
		 */
//		public static synchronized Calendar getInstance() {
//            return new GregorianCalendar();
//        }

		/**
		 * Constructs a new instance of the {@code Calendar} subclass appropriate for the
		 * specified {@code Locale}.
		 *
		 * @param locale
		 *            the locale to use.
		 * @return a {@code Calendar} subclass instance set to the current date and time.
		 */
//		public static synchronized Calendar getInstance(Locale locale) {
//			return new GregorianCalendar(locale);
//		}

		/**
		 * Constructs a new instance of the {@code Calendar} subclass appropriate for the
		 * default {@code Locale}, using the specified {@code TimeZone}.
		 *
		 * @param timezone
		 *            the {@code TimeZone} to use.
		 * @return a {@code Calendar} subclass instance set to the current date and time in
		 *         the specified timezone.
		 */
//		public static synchronized Calendar getInstance(TimeZone timezone) {
//			return new GregorianCalendar(timezone);
//		}

		/**
		 * Constructs a new instance of the {@code Calendar} subclass appropriate for the
		 * specified {@code Locale}.
		 *
		 * @param timezone
		 *            the {@code TimeZone} to use.
		 * @param locale
		 *            the {@code Locale} to use.
		 * @return a {@code Calendar} subclass instance set to the current date and time in
		 *         the specified timezone.
		 */
//		public static synchronized Calendar getInstance(TimeZone timezone,
//				Locale locale) {
//			return new GregorianCalendar(timezone, locale);
//		}

		/**
		 * Gets the smallest maximum value of the specified field. This is the
		 * smallest value that {@code getActualMaximum()} can return for any
		 * possible time.
		 *
		 * @param field
		 *            the field number.
		 * @return the smallest maximum value of the specified field.
		 */
		GetLeastMaximum(
            [in] Int32 field,
            [out] Int32* maximum);

		/**
		 * Gets the greatest maximum value of the specified field. This returns the
		 * biggest value that {@code get} can return for the specified field.
		 *
		 * @param field
		 *            the field.
		 * @return the greatest maximum value of the specified field.
		 */
		GetMaximum(
            [in] Int32 field,
            [out] Int32* maximum);

		/**
		 * Gets the minimal days in the first week of the year.
		 *
		 * @return the minimal days in the first week of the year.
		 */
		GetMinimalDaysInFirstWeek(
            [out] Int32* minimalDaysInFirstWeek);

		/**
		 * Gets the smallest minimum value of the specified field. this returns the
		 * smallest value thet {@code get} can return for the specified field.
		 *
		 * @param field
		 *            the field number.
		 * @return the smallest minimum value of the specified field.
		 */
		GetMinimum(
            [in] Int32 field,
            [out] Int32* minimum);

		/**
		 * Gets the time of this {@code Calendar} as a {@code Date} object.
		 *
		 * @return a new {@code Date} initialized to the time of this {@code Calendar}.
		 *
		 * @throws IllegalArgumentException
		 *                if the time is not set and the time cannot be computed
		 *                from the current field values.
		 */
		GetTime(
		    [out] IDate** newObj);

		/**
		 * Computes the time from the fields if required and returns the time.
		 *
		 * @return the time of this {@code Calendar}.
		 *
		 * @throws IllegalArgumentException
		 *                if the time is not set and the time cannot be computed
		 *                from the current field values.
		 */
		GetTimeInMillis(
            [out] Int64* time);

		/**
		 * Gets the timezone of this {@code Calendar}.
		 *
		 * @return the {@code TimeZone} used by this {@code Calendar}.
		 */
//		public TimeZone getTimeZone() {
//			return zone;
//		}

		/**
		 * Returns if this {@code Calendar} accepts field values which are outside the valid
		 * range for the field.
		 *
		 * @return {@code true} if this {@code Calendar} is lenient, {@code false} otherwise.
		 */
		IsLenient(
            [out] Boolean* lenient);

		/**
		 * Returns whether the specified field is set. Note that the interpretation of "is set" is
		 * somewhat technical. In particular, it does <i>not</i> mean that the field's value is up
		 * to date. If you want to know whether a field contains an up-to-date value, you must also
		 * check {@code areFieldsSet}, making this method somewhat useless unless you're a subclass,
		 * in which case you can access the {@code isSet} array directly.
		 * <p>
		 * A field remains "set" from the first time its value is computed until it's cleared by one
		 * of the {@code clear} methods. Thus "set" does not mean "valid". You probably want to call
		 * {@code get} -- which will update fields as necessary -- rather than try to make use of
		 * this method.
		 *
		 * @param field
		 *            a {@code Calendar} field number.
		 * @return {@code true} if the specified field is set, {@code false} otherwise.
		 */
		IsSet(
            [in] Int32 field,
            [out] Boolean* set);

		/**
		 * Adds the specified amount to the specified field and wraps the value of
		 * the field when it goes beyond the maximum or minimum value for the
		 * current date. Other fields will be adjusted as required to maintain a
		 * consistent date.
		 *
		 * @param field
		 *            the field to roll.
		 * @param value
		 *            the amount to add.
		 */
		Roll(
            [in] Int32 field,
            [in] Int32 value);

		/**
		 * Increment or decrement the specified field and wrap the value of the
		 * field when it goes beyond the maximum or minimum value for the current
		 * date. Other fields will be adjusted as required to maintain a consistent
		 * date.
		 *
		 * @param field
		 *            the number indicating the field to roll.
		 * @param increment
		 *            {@code true} to increment the field, {@code false} to decrement.
		 */
		RollEx(
            [in] Int32 field,
            [in] Boolean increment);

		/**
		 * Sets a field to the specified value.
		 *
		 * @param field
		 *            the code indicating the {@code Calendar} field to modify.
		 * @param value
		 *            the value.
		 */
		Set(
            [in] Int32 field,
            [in] Int32 value);

		/**
		 * Sets the year, month and day of the month fields. Other fields are not
		 * changed.
		 *
		 * @param year
		 *            the year.
		 * @param month
		 *            the month.
		 * @param day
		 *            the day of the month.
		 */
		SetEx(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day);

		/**
		 * Sets the year, month, day of the month, hour of day and minute fields.
		 * Other fields are not changed.
		 *
		 * @param year
		 *            the year.
		 * @param month
		 *            the month.
		 * @param day
		 *            the day of the month.
		 * @param hourOfDay
		 *            the hour of day.
		 * @param minute
		 *            the minute.
		 */
		SetEx2(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day,
            [in] Int32 hourOfDay,
            [in] Int32 minute);

		/**
		 * Sets the year, month, day of the month, hour of day, minute and second
		 * fields. Other fields are not changed.
		 *
		 * @param year
		 *            the year.
		 * @param month
		 *            the month.
		 * @param day
		 *            the day of the month.
		 * @param hourOfDay
		 *            the hour of day.
		 * @param minute
		 *            the minute.
		 * @param second
		 *            the second.
		 */
		SetEx3(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day,
            [in] Int32 hourOfDay,
            [in] Int32 minute,
            [in] Int32 second);

		/**
		 * Sets the first day of the week for this {@code Calendar}.
		 *
		 * @param value
		 *            a {@code Calendar} day of the week.
		 */
		SetFirstDayOfWeek(
            [in] Int32 value);

		/**
		 * Sets this {@code Calendar} to accept field values which are outside the valid
		 * range for the field.
		 *
		 * @param value
		 *            a boolean value.
		 */
		SetLenient(
            [in] Boolean value);

		/**
		 * Sets the minimal days in the first week of the year.
		 *
		 * @param value
		 *            the minimal days in the first week of the year.
		 */
		SetMinimalDaysInFirstWeek(
            [in] Int32 value);

		/**
		 * Sets the time of this {@code Calendar}.
		 *
		 * @param date
		 *            a {@code Date} object.
		 */
		SetTime(
            [in] IDate* date);

		/**
		 * Sets the time of this {@code Calendar}.
		 *
		 * @param milliseconds
		 *            the time as the number of milliseconds since Jan. 1, 1970.
		 */
		SetTimeInMillis(
            [in] Int64 milliseconds);

		/**
		 * Sets the {@code TimeZone} used by this Calendar.
		 *
		 * @param timezone
		 *            a {@code TimeZone}.
		 */
//		public void setTimeZone(TimeZone timezone) {
//			zone = timezone;
//			areFieldsSet = false;
//		}

		/**
		 * Compares the times of the two {@code Calendar}, which represent the milliseconds
		 * from the January 1, 1970 00:00:00.000 GMT (Gregorian).
		 *
		 * @param anotherCalendar
		 *            another calendar that this one is compared with.
		 * @return 0 if the times of the two {@code Calendar}s are equal, -1 if the time of
		 *         this {@code Calendar} is before the other one, 1 if the time of this
		 *         {@code Calendar} is after the other one.
		 * @throws NullPointerException
		 *             if the argument is null.
		 * @throws IllegalArgumentException
		 *             if the argument does not include a valid time
		 *             value.
		 */
		CompareTo(
            [in] ICalendar* anotherCalendar,
            [out] Int32* result);

		/**
		 * Returns a human-readable string for the value of {@code field}
		 * using the given style and locale. If no string is available, returns null.
		 * The value is retrieved by invoking {@code get(field)}.
		 *
		 * <p>For example, {@code getDisplayName(MONTH, SHORT, Locale.US)} will return "Jan"
		 * while {@code getDisplayName(MONTH, LONG, Locale.US)} will return "January".
		 *
		 * @param field the field
		 * @param style {@code SHORT} or {@code LONG}
		 * @param locale the locale
		 * @return the display name, or null
		 * @throws NullPointerException if {@code locale == null}
		 * @throws IllegalArgumentException if {@code field} or {@code style} is invalid
		 * @since 1.6
		 */
//		public String getDisplayName(int field, int style, Locale locale) {
//			// TODO: the RI's documentation says ALL_STYLES is invalid, but actually treats it as SHORT.
//			if (style == ALL_STYLES) {
//				style = SHORT;
//			}
//			String[] array = getDisplayNameArray(field, style, locale);
//			int value = get(field);
//			return (array != null) ? array[value] : null;
//		}

		/**
		 * Returns a map of human-readable strings to corresponding values,
		 * for the given field, style, and locale.
		 * Returns null if no strings are available.
		 *
		 * <p>For example, {@code getDisplayNames(MONTH, ALL_STYLES, Locale.US)} would
		 * contain mappings from "Jan" and "January" to {@link #JANUARY}, and so on.
		 *
		 * @param field the field
		 * @param style {@code SHORT}, {@code LONG}, or {@code ALL_STYLES}
		 * @param locale the locale
		 * @return the display name, or null
		 * @throws NullPointerException if {@code locale == null}
		 * @throws IllegalArgumentException if {@code field} or {@code style} is invalid
		 * @since 1.6
		 */
//		public Map<String, Integer> getDisplayNames(int field, int style, Locale locale) {
//			checkStyle(style);
//			complete();
//			Map<String, Integer> result = new HashMap<String, Integer>();
//			if (style == SHORT || style == ALL_STYLES) {
//				insertValuesInMap(result, getDisplayNameArray(field, SHORT, locale));
//			}
//			if (style == LONG || style == ALL_STYLES) {
//				insertValuesInMap(result, getDisplayNameArray(field, LONG, locale));
//			}
//			return result.isEmpty() ? null : result;
//		}
	}

	interface ICalendarHelper {
	    GetInstance(
	        [out] ICalendar** calenar);

        GetInstanceEx(
            [in] ILocale* locale,
            [out] ICalendar** calenar);

        GetInstanceEx1(
            [in] ITimeZone* timezone,
            [out] ICalendar** calenar);

        GetInstanceEx2(
            [in] ITimeZone* timezone,
            [in] ILocale* locale,
            [out] ICalendar** calenar);
	}
}
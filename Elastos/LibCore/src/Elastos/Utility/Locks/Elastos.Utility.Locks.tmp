module Elastos.Utility.Locks.eco
{

    interface ICondition;
    interface ITimeUnit;
    interface ILock;
    interface IThread;
    interface IReentrantLock;
    interface IDate;
    interface IConditionObject;
    interface IAbstractQueuedSynchronizer;
    interface ICountDownLatch;
    interface IThreadGroup;
    interface IThreadUncaughtExceptionHandler;

    enum ThreadState {
        ThreadState_NEW = 0,
        ThreadState_RUNNABLE = 1,
        ThreadState_BLOCKED = 2,
        ThreadState_WAITING = 3,
        ThreadState_TIMED_WAITING = 4,
        ThreadState_TERMINATED = 5,
    }

    const E_INTERRUPTED = 0xa4120000;

    const Thread_MAX_PRIORITY = 10;

    const Thread_MIN_PRIORITY = 1;

    const Thread_NORM_PRIORITY = 5;

    interface ICondition {
        AWait();

        AWaitUninterruptibly();

        AWaitNanos(
            [in] Int64 nanosTimeout, 
            [out] Int64 * value);

        AWaitEx(
            [in] Int64 time, 
            [in] ITimeUnit * unit, 
            [out] Boolean * value);

        AWaitUntil(
            [in] IDate * deadline, 
            [out] Boolean * value);

        Signal();

        SignalAll();
    }

    interface ITimeUnit {
        TimeUnit();
    }

    interface ILock {
        Lock();

        LockInterruptibly();

        TryLock(
            [out] Boolean * value);

        TryLockEx(
            [in] Int64 time, 
            [in] ITimeUnit * unit);

        Unlock();

        NewCondition(
            [out] ICondition ** condition);
    }

    interface IThread {
        CheckAccess();

        CountStackFrames(
            [out] Int32 * number);

        Destroy();

        GetId(
            [out] Int64 * id);

        GetName(
            [out] String * name);

        GetPriority(
            [out] Int32 * priority);

        GetState(
            [out] ThreadState * state);

        GetThreadGroup(
            [out] IThreadGroup ** group);

        Interrupt();

        IsAlive(
            [out] Boolean * isAlive);

        IsDaemon(
            [out] Boolean * isDaemon);

        IsInterrupted(
            [out] Boolean * isInterrupted);

        Join();

        JoinEx(
            [in] Int64 millis);

        JoinEx2(
            [in] Int64 millis, 
            [in] Int32 nanos);

        Resume();

        SetDaemon(
            [in] Boolean isDaemon);

        SetName(
            [in] const String& threadName);

        SetPriority(
            [in] Int32 priority);

        Start();

        Stop();

        Suspend();

        Wait(
            [in] Int64 time, 
            [in] Int32 frac);
    }

    interface IReentrantLock : ILock {
        GetHoldCount(
            [out] Int32 * value);

        IsHeldByCurrentThread(
            [out] Boolean * value);

        IsLocked(
            [out] Boolean * isLocked);

        IsFair(
            [out] Boolean * isFair);

        GetOwner(
            [out] IThread ** thread);

        HasQueuedThreads(
            [out] Boolean * value);

        HasQueuedThread(
            [in] IThread * thread, 
            [out] Boolean * value);

        GetQueueLength(
            [out] Int32 * value);

        HasWaiters(
            [in] ICondition * condition, 
            [out] Boolean * value);

        GetWaitQueueLength(
            [in] ICondition * condition, 
            [out] Int32 * value);

        ToString();
    }

    interface IDate {
        IsAfter(
            [in] IDate * date, 
            [out] Boolean * isAfter);

        IsBefore(
            [in] IDate * date, 
            [out] Boolean * isBefore);

        CompareTo(
            [in] IDate * date, 
            [out] Int32 * result);

        GetDate(
            [out] Int32 * date);

        GetDay(
            [out] Int32 * day);

        GetHours(
            [out] Int32 * hours);

        GetMinutes(
            [out] Int32 * minutes);

        GetMonth(
            [out] Int32 * month);

        GetSeconds(
            [out] Int32 * seconds);

        GetTime(
            [out] Int64 * time);

        GetTimezoneOffset(
            [out] Int32 * timezoneOffset);

        GetYear(
            [out] Int32 * year);

        SetDate(
            [in] Int32 day);

        SetHours(
            [in] Int32 hour);

        SetMinutes(
            [in] Int32 minute);

        SetMonth(
            [in] Int32 month);

        SetSeconds(
            [in] Int32 second);

        SetTime(
            [in] Int64 milliseconds);

        SetYear(
            [in] Int32 year);

        ToGMTString(
            [out] String * gmtStr);

        ToLocaleString(
            [out] String * localeStr);

        ToString(
            [out] String * str);
    }

    interface IConditionObject : ICondition {
        ConditionInit();
    }

    interface IAbstractQueuedSynchronizer {
        Acquire(
            [in] Int32 arg);

        AcquireInterruptibly(
            [in] Int32 arg);

        TryAcquireNanos(
            [in] Int32 arg, 
            [in] Int64 nanosTimeout, 
            [out] Boolean * isAcquire);

        ReleaseArg(
            [in] Int32 arg, 
            [out] Boolean * isRelease);

        AcquireShared(
            [in] Int32 arg);

        AcquireSharedInterruptibly(
            [in] Int32 arg);

        TryAcquireSharedNanos(
            [in] Int32 arg, 
            [in] Int64 nanosTimeout, 
            [out] Boolean * isAcquireShared);

        ReleaseShared(
            [in] Int32 arg, 
            [out] Boolean * isReleaseShared);

        HasQueuedThreads(
            [out] Boolean * hasQueueThreads);

        HasContended(
            [out] Boolean * hasContended);

        GetFirstQueuedThread(
            [out] IThread ** thread);

        IsQueued(
            [in] IThread * thread, 
            [out] Boolean * isQueue);

        ApparentlyFirstQueuedIsExclusive(
            [out] Boolean * isApparent);

        HasQueuedPredecessors(
            [out] Boolean * hasQueuePredecessors);

        GetQueueLength(
            [out] Int32 * len);

        GetQueuedThreads(
            [out] IObjectEnumerator ** emu);

        GetExclusiveQueuedThreads(
            [out] IObjectEnumerator ** emu);

        GetSharedQueuedThreads(
            [out] IObjectEnumerator ** emu);

        ToString();

        Owns(
            [in] IConditionObject * condition, 
            [out] Boolean * isOwn);

        HasWaiters(
            [in] IConditionObject * condition, 
            [out] Boolean * hasWaiters);

        GetWaitQueueLength(
            [in] IConditionObject * condition, 
            [out] Int32 * len);

        GetWaitingThreads(
            [in] IConditionObject * condition, 
            [out] IObjectEnumerator ** emu);
    }

    interface ICountDownLatch {
        AWait();

        AWaitEx(
            [in] Int64 timeout, 
            [in] ITimeUnit * unit, 
            [out] Boolean * isWait);

        CountDown();

        GetCount(
            [out] Int64 * count);

        ToString();
    }

    interface IThreadGroup {
        ActiveCount(
            [out] Int32 * number);

        ActiveGroupCount(
            [out] Int32 * number);

        AllowThreadSuspension(
            [in] Boolean b, 
            [out] Boolean * result);

        CheckAccess();

        Destroy();

        EnumerateThread(
            [out] ArrayOf<IThread *> threads, 
            [out] Int32 * number);

        EnumerateThreadEx(
            [in] Boolean recurse, 
            [out] ArrayOf<IThread *> threads, 
            [out] Int32 * number);

        EnumerateThreadGroup(
            [out] ArrayOf<IThreadGroup *> groups, 
            [out] Int32 * number);

        EnumerateThreadGroupEx(
            [in] Boolean recurse, 
            [out] ArrayOf<IThreadGroup *> groups, 
            [out] Int32 * number);

        GetMaxPriority(
            [out] Int32 * maxPriority);

        GetName(
            [out] String * name);

        GetParent(
            [out] IThreadGroup ** parent);

        Interrupt();

        IsDaemon(
            [out] Boolean * isDaemon);

        IsDestroyed(
            [out] Boolean * isDestroyed);

        List();

        IsParentOf(
            [in] IThreadGroup * g, 
            [out] Boolean * result);

        Resume();

        SetDaemon(
            [in] Boolean isDaemon);

        SetMaxPriority(
            [in] Int32 newMax);

        Stop();

        Suspend();
    }

    interface IThreadUncaughtExceptionHandler {
        UncaughtException(
            [in] IThread * thread, 
            [in] ECode ec);
    }

    [

    ]
    class CReentrantLock {
        interface IReentrantLock;
    }

    [

    ]
    class CAbstractQueuedSynchronizer {
        interface IAbstractQueuedSynchronizer;
    }

    [

    ]
    class CCountDownLatch {
        interface ICountDownLatch;
    }
}

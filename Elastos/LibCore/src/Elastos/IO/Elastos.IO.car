/** @file Elastos.IO.car
 *  @brief CAR file for Elastos IO library.
 *
 *  This contains the prototypes for the Elastos IO library.
 *  Java: 
 *
 *  @author cao.jing
 *  @bug No known bugs.
 */

module
{
    importlib("Elastos.Core.eco");
    importlib("Elastos.Utility.eco");

    merge("../../../car/Elastos/IO/Errors.car");
    merge("../../../car/Elastos/IO/Exceptions.car");
    merge("../../../car/Elastos/IO/IInputStream.car");
    merge("../../../car/Elastos/IO/IFilterInputStream.car"); 
    merge("../../../car/Elastos/IO/IBufferedInputStream.car");
    merge("../../../car/Elastos/IO/IOutputStream.car");
    merge("../../../car/Elastos/IO/IFilterOutputStream.car");
    merge("../../../car/Elastos/IO/IBufferedOutputStream.car");
    merge("../../../car/Elastos/IO/IByteArrayInputStream.car");
    merge("../../../car/Elastos/IO/IByteArrayOutputStream.car");
    merge("../../../car/Elastos/IO/IFileFilter.car");
    merge("../../../car/Elastos/IO/IFilenameFilter.car");
    merge("../../../car/Elastos/IO/IFile.car");
    merge("../../../car/Elastos/IO/IFileDescriptor.car");
    merge("../../../car/Elastos/IO/IFileInputStream.car");
    merge("../../../car/Elastos/IO/IFileOutputStream.car");
    merge("../../../car/Elastos/IO/IDataInput.car");
    merge("../../../car/Elastos/IO/IDataInputStream.car");
    merge("../../../car/Elastos/IO/IDataOutput.car");
    merge("../../../car/Elastos/IO/IDataOutputStream.car");
    merge("../../../car/Elastos/IO/IObjectInput.car");
    merge("../../../car/Elastos/IO/IObjectOutput.car");
    merge("../../../car/Elastos/IO/IObjectInputValidation.car");
    merge("../../../car/Elastos/IO/IReader.car");
    merge("../../../car/Elastos/IO/IWriter.car");
    merge("../../../car/Elastos/IO/ICharArrayReader.car");
    merge("../../../car/Elastos/IO/ICharArrayWriter.car");
    merge("../../../car/Elastos/IO/IBufferedReader.car");
    merge("../../../car/Elastos/IO/IBufferedWriter.car");
    merge("../../../car/Elastos/IO/IStringBufferInputStream.car");
    merge("../../../car/Elastos/IO/ILineNumberInputStream.car");
    merge("../../../car/Elastos/IO/ILineNumberReader.car");
    merge("../../../car/Elastos/IO/IPushbackInputStream.car");
    merge("../../../car/Elastos/IO/IPushbackReader.car");
    merge("../../../car/Elastos/IO/IFilePermission.car");
    merge("../../../car/Elastos/IO/IFilePermissionCollection.car");
    merge("../../../car/Elastos/IO/IInputStreamReader.car");
    merge("../../../car/Elastos/IO/IOutputStreamWriter.car");
    merge("../../../car/Elastos/IO/IPrintWriter.car");
    merge("../../../car/Elastos/IO/IPrintStream.car");
    merge("../../../car/Elastos/IO/IStringReader.car");
    merge("../../../car/Elastos/IO/IStringWriter.car");
    merge("../../../car/Elastos/IO/ICloseable.car");
    merge("../../../car/Elastos/IO/IRandomAccessFile.car");
    /************************************NIO**********************************/
    merge("../../../car/Elastos/IO/ByteOrder.car");
    merge("../../../car/Elastos/IO/IBuffer.car");
    merge("../../../car/Elastos/IO/IByteBuffer.car");
    merge("../../../car/Elastos/IO/ICharBuffer.car");
    merge("../../../car/Elastos/IO/IDoubleBuffer.car");
    merge("../../../car/Elastos/IO/IFloatBuffer.car");
    merge("../../../car/Elastos/IO/IInt16Buffer.car");
    merge("../../../car/Elastos/IO/IInt32Buffer.car");
    merge("../../../car/Elastos/IO/IInt64Buffer.car");
    merge("../../../car/Elastos/IO/IMappedByteBuffer.car");
    merge("../../../car/Elastos/IO/Channels/IChannel.car");
    merge("../../../car/Elastos/IO/charset/ICharset.car");
    merge("../../../car/Elastos/IO/charset/ICharsets.car");
    merge("../../../car/Elastos/IO/charset/ICharsetDecoder.car");
    merge("../../../car/Elastos/IO/charset/ICharsetEncoder.car");
    merge("../../../car/Elastos/IO/charset/ICoderResult.car");
    merge("../../../car/Elastos/IO/charset/ICodingErrorAction.car");
    merge("../../../car/Elastos/IO/charset/IModifiedUtf8.car");
    merge("../../../car/Elastos/IO/charset/INativeConverter.car");
    merge("../../../car/Elastos/IO/charset/spi/ICharsetProvider.car");
    merge("../../../car/Elastos/IO/Channels/IChannels.car");
    merge("../../../car/Elastos/IO/Channels/IReadableByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IWritableByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IInterruptibleChannel.car");
    merge("../../../car/Elastos/IO/Channels/ISelectableChannel.car");
//    merge("../../../car/Elastos/IO/Channels/IDatagramChannel.car");
    merge("../../../car/Elastos/IO/Channels/IFileChannel.car");
    merge("../../../car/Elastos/IO/Channels/IFileLock.car");
    merge("../../../car/Elastos/IO/Channels/IGatheringByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IPipe.car");
    merge("../../../car/Elastos/IO/Channels/IScatteringByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/ISelectionKey.car");
    merge("../../../car/Elastos/IO/Channels/ISelector.car");
//    merge("../../../car/Elastos/IO/Channels/IServerSocketChannel.car");
    merge("../../../car/Elastos/IO/Channels/Spi/ISelectorProvider.car");



   /**
    * A CFilterInputStream contains some other input stream, which it uses as its basic source of data, possibly transforming the data 
    * along the way or providing additional functionality. The class FilterInputStream itself simply overrides all methods of 
    * InputStream with versions that pass all requests to the contained input stream. Subclasses of FilterInputStream may further
    * override some of these methods and may also provide additional methods and fields.
    * 
    * @implements com::elastos::IInputStream
    *
    * <strong>Direct Known Subclasses:</strong>
    * - @ref com::elastos::CBufferedInputStream
    * - @ref com::elastos::CCheckedInputStream
    * - @ref com::elastos::CCipherInputStream
    * - @ref com::elastos::CDataInputStream
    * - @ref com::elastos::CDeflaterInputStream
    * - @ref com::elastos::CDigestInputStream
    * - @ref com::elastos::CInflaterInputStream
    * - @ref com::elastos::CLineNumberInputStream,
    * - @ref com::elastos::CProgressMonitorInputStream
    * - @ref com::elastos::CPushbackInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/FilterInputStream.html
    */
    class CFilterInputStream {
       /**
        * Constructs a new with the specified input stream as source.
        *
        * <p><strong>Warning:</strong> passing a null source creates an invalid,
        * that fails on every method that is not overridden.
        * Subclasses should check for null in their constructors.
        *
        * @param is    the input stream to filter reads on.
        * @return ECode    NOERROR(0)
        */
        constructor(
            [in] IInputStream* is);

        interface IFilterInputStream;
    }

   /**
    * Instances of this class support both reading and writing to a random access file. A random access file behaves like a large array of bytes stored in the file system.
    * There is a kind of cursor, or index into the implied array, called the file pointer; input operations read bytes starting at the file pointer and advance the file pointer     
    * past the bytes read. If the random access file is created in read/write mode, then output operations are also available; output operations write bytes starting at the file pointer and advance the file pointer past the bytes written. Output operations that write past the current end of the implied array cause the array to be extended. The file pointer can be read by the getFilePointer method and set by the seek method.
    * It is generally true of all the reading routines in this class that if end-of-file is reached before the desired number of bytes has been read, an EOFException (which is a kind of IOException) is thrown. If any byte cannot be read for any reason other than end-of-file, an IOException other than EOFException is thrown. In particular, an IOException may be thrown if the stream has been closed.
    * 
    * @implements com::elastos::IRandomAccessFile
    * @implements com::elastos::IDataInput
    * @implements com::elastos::IDataOutput
    *
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/RandomAccessFile.html
    */
    class CRandomAccessFile {
       /**
        * @brief Constructs a new with the specified input stream as source.
        * 
        * Creates a random access file stream to read from, and optionally to write to, a file with the specified name. 
        * A new FileDescriptor object is created to represent the connection to the file.
        * The mode argument specifies the access mode with which the file is to be opened. The permitted values and their
        * meanings are as specified for the RandomAccessFile(File,String) constructor.
        * 
        * If there is a security manager, its checkRead method is called with the name argument as its argument to see
        * if read access to the file is allowed. If the mode allows writing, the security manager's checkWrite method is
        * also called with the name argument as its argument to see if write access to the file is allowed.
        *
        * @sa com::elastos::ISecurityManager::CheckRead()
        * 
        * @param file    the file object.
        * @param mode    the access mode, as described @ref mode
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if the mode argument is not equal to one of "r", "rw", "rws", or "rwd"
        * FileNotFoundException | if the mode is "r" but the given file object does not denote an existing regular file, or if the mode begins with "rw" but the given file object does not denote an existing, writable regular file and a new regular file of that name cannot be created, or if some other error occurs while opening or creating the file
        * SecurityException | if a security manager exists and its checkRead method denies read access to the file or the mode is "rw" and the security manager's checkWrite method denies write access to the file
        */
        constructor(
            [in] IFile* pFile,
            [in] CString mode);

       /**
        * @brief Creates a random access file stream to read from, and optionally to write to, the file specified by the File argument.
        *
        * Creates a random access file stream to read from, and optionally to write to, the file specified by the File argument. A new FileDescriptor
        * object is created to represent this file connection. The mode argument specifies the access mode in which the file is to be opened. The
        * permitted values and their meanings are:
        *
        * @section mode
        *
        * Value | Meaning |
        * :-|:------------|
        * "r"| Open for reading only. Invoking any of the write methods of the resulting object will cause an IOException to be thrown.
        * "rw"| Open for reading and writing. If the file does not already exist then an attempt will be made to create it.
        * "rws" | Open for reading and writing, as with "rw", and also require that every update to the file's content or metadata be written synchronously to the underlying storage device.
        * "rwd" | Open for reading and writing, as with "rw", and also require that every update to the file's content be written synchronously to the underlying storage device.
        * 
        * The "rws" and "rwd" modes work much like the force(boolean) method of the FileChannel class, passing arguments of true and false, 
        * respectively, except that they always apply to every I/O operation and are therefore often more efficient. If the file resides on
        * a local storage device then when an invocation of a method of this class returns it is guaranteed that all changes made to the file
        * by that invocation will have been written to that device. This is useful for ensuring that critical information is not lost in the
        * event of a system crash. If the file does not reside on a local device then no such guarantee is made.
        * 
        * The "rwd" mode can be used to reduce the number of I/O operations performed. Using "rwd" only requires updates to the file's content
        * to be written to storage; using "rws" requires updates to both the file's content and its metadata to be written, which generally
        * requires at least one more low-level I/O operation.
        * 
        * If there is a security manager, its checkRead method is called with the pathname of the file argument as its argument to see if read
        * access to the file is allowed. If the mode allows writing, the security manager's checkWrite method is also called with the path argument to see if write access to the file is allowed.
        * 
        * @sa com::elastos::ISecurityManager::CheckRead()
        * 
        * @param fileName     the system-dependent filename.
        * @param mode    the access mode, as described above.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if the mode argument is not equal to one of "r", "rw", "rws", or "rwd"
        * FileNotFoundException | if the mode is "r" but the given string does not denote an existing regular file, or if the mode begins with "rw" but the given string does not denote an existing, writable regular file and a new regular file of that name cannot be created, or if some other error occurs while opening or creating the file.
        * SecurityException | if a security manager exists and its checkRead method denies read access to the file or the mode is "rw" and the security manager's checkWrite method denies write access to the file.
        */
        constructor(
            [in] String fileName,
            [in] CString mode);

        interface IRandomAccessFile;
        interface IDataInput;
        interface IDataOutput;
    }

   /**
    * A CBufferedInputStream adds functionality to another input stream-namely, the ability to buffer the input and to support the mark and reset methods. 
    * When the CBufferedInputStream is created, an internal buffer array is created. As bytes from the stream are read or skipped, the internal buffer
    * is refilled as necessary from the contained input stream, many bytes at a time. The mark operation remembers a point in the input stream and the
    * reset operation causes all the bytes read since the most recent mark operation to be reread before new bytes are taken from the contained input stream.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IBufferedInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedInputStream.html
    */
    class CBufferedInputStream {
       /**
        * @brief Creates a BufferedInputStream and saves its argument, the input stream in, for later use.
        *
        * Creates a BufferedInputStream and saves its argument, the input stream in, for later use. An internal buffer array is created and stored in buf.
        *
        * @param is the buffer reads from
        */
        constructor(
            [in] IInputStream* is);

       /**
        * @brief Creates a BufferedInputStream with the specified buffer size, and saves its argument, the input stream in, for later use.
        *
        * Creates a BufferedInputStream with the specified buffer size, and saves its argument, the input stream in, for later use.
        * An internal buffer array of length size is created and stored in buf.
        *
        * @param is    the buffer reads from
        * @param size  the buffer size.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if size <= 0.
        */
        constructor(
            [in] IInputStream* is,
            [in] Int32 size);

        interface IBufferedInputStream;
    }

   /**
    * This class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream
    * (the underlying output stream) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality.
    * 
    * The class FilterOutputStream itself simply overrides all methods of OutputStream with versions that pass all requests to the underlying
    * output stream. Subclasses of FilterOutputStream may further override some of these methods as well as provide additional methods and fields.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IFilterOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/FilterOutputStream.html
    */
    class CFilterOutputStream {
       /**
        * @brief  Creates an output stream filter built on top of the specified underlying output stream.
        *
        * @param os  the underlying output stream to be assigned to the field this.out for later use, or null if this instance is to be created without an underlying stream.
        */
        constructor(
            [in] IOutputStream* os);

        interface IFilterOutputStream;
    }

   /**
    * The class implements a buffered output stream. By setting up such an output stream, an application can write bytes to the underlying output stream without
    * necessarily causing a call to the underlying system for each byte written.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IBufferedOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedOutputStream.html
    */
    class CBufferedOutputStream {
       /**
        * @brief  Constructs a new IBufferedOutputStream, providing with a buffer
        *
        * @param os IOutputStream the buffer writes to.
        */
        constructor(
            [in] IOutputStream* os);

       /**
        * @brief  Constructs a new IBufferedOutputStream, providing os with size bytes of buffer.
        *
        * @param out the IOutputStream the buffer writes to.
        * @param size the size of buffer in bytes.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if size <= 0
        */
        constructor(
            [in] IOutputStream* os,
            [in] Int32 size);

        interface IBufferedOutputStream;
    }

   /**
    * A ByteArrayInputStream contains an internal buffer that contains bytes that may be read from the stream. An internal counter keeps track of the next byte to be supplied by the read method.
    * Closing a ByteArrayInputStream has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IByteArrayInputStream
    * 
    * @sa com::elastos::StringBufferInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/ByteArrayInputStream.html
    */
    class CByteArrayInputStream {
        /**
         * @brief Constructs a new ByteArrayInputStream on the byte array
         *
         * @param buffer   the byte array to stream over.
         */
        constructor(
            [in] BufferOf<Byte> buffer);

        /**
         * @brief Constructs a new IByteArrayInputStream on the byte array with the initial position set to offset and the
         * number of bytes available set to offset + length.
         *
         * @param buf
         *            the byte array to stream over.
         * @param offset
         *            the initial position in  buf} to start streaming from.
         * @param length
         *            the number of bytes available for streaming.
         */
        constructor(
            [in] BufferOf<Byte> buffer,
            [in] Int32 offset,
            [in] Int32 length);

        interface IByteArrayInputStream;
    }

   /**
    * This class implements an output stream in which the data is written into a byte array. The buffer automatically grows as data is written to it. 
    * The data can be retrieved using toByteArray() and toString().
    * Closing a ByteArrayOutputStream has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IByteArrayOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/ByteArrayOutputStream.html
    */
    class CByteArrayOutputStream {
        /**
         * Constructs a new ByteArrayOutputStream with a default size of 32 bytes.
         * If more than 32 bytes are written to this instance, the underlying byte
         * array will expand.
         */
        constructor();

        /**
         * Constructs a new  ByteArrayOutputStream with a default size of
         * size bytes. If more than size bytes are written to this
         * instance, the underlying byte array will expand.
         *
         * @param size
         *            initial size for the underlying byte array, must be
         *            non-negative.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if size < 0.
         */
        constructor(
            [in] Int32 size);

        interface IByteArrayOutputStream;
    }

   /**
    * An abstract representation of file and directory pathnames.
    * 
    * User interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames. An abstract pathname has two components:
    * 
    * An optional system-dependent prefix string, such as a disk-drive specifier, "/" for the UNIX root directory, or "\\\\" for a Microsoft Windows UNC pathname, and
    * A sequence of zero or more string names.
    * The first name in an abstract pathname may be a directory name or, in the case of Microsoft Windows UNC pathnames, a hostname. Each subsequent name in an abstract pathname denotes a directory; the last name may denote either a directory or a file. The empty abstract pathname has no prefix and an empty name sequence.
    * The conversion of a pathname string to or from an abstract pathname is inherently system-dependent. When an abstract pathname is converted into a pathname string, each name is separated from the next by a single copy of the default separator character. The default name-separator character is defined by the system property file.separator, and is made available in the public static fields separator and separatorChar of this class. When a pathname string is converted into an abstract pathname, the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system.
    * 
    * A pathname, whether abstract or in string form, may be either absolute or relative. An absolute pathname is complete in that no other information is required in order to locate the file that it denotes. A relative pathname, in contrast, must be interpreted in terms of information taken from some other pathname. By default the classes in the java.io package always resolve relative pathnames against the current user directory. This directory is named by the system property user.dir, and is typically the directory in which the Java virtual machine was invoked.
    * 
    * The parent of an abstract pathname may be obtained by invoking the getParent() method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any File object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname "/usr" is an ancestor of the directory denoted by the pathname "/usr/local/bin".
    * 
    * The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows:
    * 
    * - For UNIX platforms, the prefix of an absolute pathname is always "/". Relative pathnames have no prefix. The abstract pathname denoting the root directory has the prefix "/" and an empty name sequence.
    * - For Microsoft Windows platforms, the prefix of a pathname that contains a drive specifier consists of the drive letter followed by ":" and possibly followed by "\\" if the pathname is absolute. The prefix of a UNC pathname is "\\\\"; the hostname and the share name are the first two names in the name sequence. A relative pathname that does not specify a drive has no prefix.
    * Instances of this class may or may not denote an actual file-system object such as a file or a directory. If it does denote such an object then that object resides in a partition. A partition is an operating system-specific portion of storage for a file system. A single storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may contain multiple partitions. The object, if any, will reside on the partition named by some ancestor of the absolute form of this pathname.
    * 
    * A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing. These restrictions are collectively known as access permissions. The file system may have multiple sets of access permissions on a single object. For example, one set may apply to the object's owner, and another may apply to all other users. The access permissions on an object may cause some methods in this class to fail.
    * Instances of the File class are immutable; that is, once created, the abstract pathname represented by a File object will never change.
    * 
    * An "abstract" representation of a file system entity identified by a pathname. The pathname may be absolute (relative to the root directory
    * of the file system) or relative to the current directory in which the program is running.
    * 
    * The actual file referenced by a CFile may or may not exist. It may also, despite the name CFile, be a directory or other non-regular file.
    * 
    * This class provides limited functionality for getting/setting file permissions, file type, and last modified time.
    * 
    * On Elastos strings are converted to UTF-8 byte sequences when sending filenames to the operating system, and byte sequences returned by
    * the operating system are converted to strings by decoding them as UTF-8 byte sequences.
    * 
    * @implements com::elastos::ISerializable
    * @implements com::elastos::IComparable
    * @implements com::elastos::IFile
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/File.html
    * @todo  http://developer.android.com/reference/java/io/File.html
    */
    class CFile {
      /**
        * @brief Constructs a new file using the specified directory and name.
        *
        * @param dir   the directory where the file is stored.
        * @param name  the file's name.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * NullPointerException | if  name is  null.
        */
        constructor(
            [in] IFile* dir,
            [in] String name);

        /**
         * @brief Constructs a new file using the specified path.
         *
         * @param path     the path to be used for the file.
         */
        constructor(
            [in] String path);

       /**
         * @brief Constructs a new File using the specified directory path and file name, placing a path separator between the two.
         *
         * @param dirPath      the path to the directory where the file is stored.
         * @param name         the file's name.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if  name is  null.
         */
        constructor(
            [in] String dirPath,
            [in] String name);

        /**
         * @brief Constructs a new File using the path of the specified URI.  uri needs to be an absolute and hierarchical Unified Resource Identifier with
         * file scheme and non-empty path component, but with undefined authority, query or fragment components.
         *
         * @param uri   the Unified Resource Identifier that is used to construct this file.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if uri does not comply with the conditions above.
         * 
         * @sa com::elastos::CtoURI
         * @sa com::elastos::CURI
         */
//        constructor(
//            [in] IURI* uri);

        interface IFile;
    }

   /**
    * Utilities for File manipulation.
    * 
    * @implements com::elastos::IFileHelper
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/cd/E18150_01/javadocs/DevelopmentKit/com/stc/connector/framework/util/FileHelper.html
    */
    singleton class CFileHelper {
        interface IFileHelper;
    }

   /**
    * Instances of the file descriptor class serve as an opaque handle to the underlying machine-specific structure representing an open file, 
    * an open socket, or another source or sink of bytes. The main practical use for a file descriptor is to create a FileInputStream or FileOutputStream to contain it.
    * Applications should not create their own file descriptors.
    * 
    * @implements com::elastos::IFileDescriptor
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/FileDescriptor.html
    */
    class CFileDescriptor {
        interface IFileDescriptor;
    }

   /**
    * A FileInputStream obtains input bytes from a file in a file system. What files are available depends on the host environment.
    * FileInputStream is meant for reading streams of raw bytes such as image data. For reading streams of characters, consider using FileReader.
    * 
    * @implements com::elastos::IFileInputStream
    * @implements com::elastos::ICloseable
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/index.html?java/io/FileInputStream.html
    */
    class CFileInputStream {
        /**
         * Constructs a new  FileInputStream based on  file
         *
         * @param file
         *            the file from which this stream reads.
         * @throws FileNotFoundException
         *             if  file does not exist.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             read request.
         */
        constructor(
            [in] IFile* file);
        /**
         * Constructs a new IFileInputStream on the IFile
         *  fd The file must already be open, therefore no
         *  FileNotFoundException will be thrown.
         *
         * @param fd
         *            the FileDescriptor from which this stream reads.
         * @throws NullPointerException
         *             if  fd is  null
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             read request.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Constructs a new  FileInputStream on the file named
         *  fileName. The path of  fileName may be absolute or
         * relative to the system property  "user.dir".
         *
         * @param fileName
         *            the path and name of the file from which this stream reads.
         * @throws FileNotFoundException
         *             if there is no file named  fileName.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             read request.
         */
        constructor(
            [in] String fileName);

        interface IFileInputStream;
    }


   /**
    * A file output stream is an output stream for writing data to a File or to a FileDescriptor. Whether or not a file is available or may
    * be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one
    * IFileOutputStream (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.
    * IFileOutputStream is meant for writing streams of raw bytes such as image data. For writing streams of characters, consider using FileWriter.
    * 
    * @implements com::elastos::IFileOutputStream
    * @implements com::elastos::ICloseable
    *
    * @sa com::elastos::IFile
    * @sa com::elastos::IFileDescriptor
    * @sa com::elastos::IFileInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/1.4.2/docs/api/java/io/FileOutputStream.html
    */
    class CFileOutputStream {
        /**
         * Constructs a new FileOutputStream on the File  file. If the file
         * exists, it is overwritten.
         *
         * @param file
         *            the file to which this stream writes.
         * @throws FileNotFoundException
         *             if  file cannot be opened for writing.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a new FileOutputStream on the File  file. The
         * parameter  append} determines whether or not the file is opened and
         * appended to or just opened and overwritten.
         *
         * @param file
         *            the file to which this stream writes.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws FileNotFoundException
         *             if the  file cannot be opened for writing.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         * @see java.lang.SecurityManager#checkWrite(String)
         */
        constructor(
            [in] IFile* file,
            [in] Boolean append);

        /**
         * Constructs a new FileOutputStream on the FileDescriptor fd The
         * file must already be open, therefore no FileNotFoundException}
         * will be thrown.
         *
         * @param fd
         *            the FileDescriptor to which this stream writes.
         * @throws NullPointerException
         *             if fd} is null
         * @throws SecurityException
         *             if a SecurityManager} is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Constructs a new FileOutputStream on the file named filename If
         * the file exists, it is overwritten. The filename} may be absolute
         * or relative to the system property "user.dir"
         *
         * @param filename
         *            the name of the file to which this stream writes.
         * @throws FileNotFoundException
         *             if the file cannot be opened for writing.
         * @throws SecurityException
         *             if a SecurityManager} is installed and it denies the
         *             write request.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a new FileOutputStream on the file named filename
         * The parameter append} determines whether or not the file is opened
         * and appended to or just opened and overwritten. The filename} may
         * be absolute or relative to the system property "user.dir"
         *
         * @param filename
         *            the name of the file to which this stream writes.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws FileNotFoundException
         *             if the file cannot be opened for writing.
         * @throws SecurityException
         *             if a SecurityManager} is installed and it denies the
         *             write request.
         */
        constructor(
            [in] String fileName,
            [in] Boolean append);

        interface IFileOutputStream;
    }

   /**
    * A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way.
    * An application uses a data output stream to write data that can later be read by a data input stream.
    * IDataInputStream is not necessarily safe for multithreaded access. Thread safety is optional and is the responsibility of users of methods in this class.
    * 
    * @implements com::elastos::IDataInput
    * @implements com::elastos::IDataInputStream
    *
    * @sa com::elastos::IDataOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/DataInputStream.html
    */
    class CDataInputStream {
        /**
         * Constructs a new DataInputStream on the InputStream in All
         * reads are then filtered through this stream. Note that data read by this
         * stream is not in a human readable format and was most likely created by a
         * DataOutputStream.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * DataInputStream All operations on such a stream will fail.
         *
         * @param in
         *            the source InputStream the filter reads from.
         * @see DataOutputStream
         * @see RandomAccessFile
         */
        constructor(
            [in] IInputStream* is);

        interface IDataInput;
        interface IDataInputStream;
    }

   /**
    * A data output stream lets an application write primitive Java data types to an output stream in a portable way.
    * An application can then use a data input stream to read the data back in.
    * 
    * @implements com::elastos::IDataOutput
    * @implements com::elastos::IDataOutputStream
    *
    * @sa com::elastos::IDataInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/DataOutputStream.html
    */
    class CDataOutputStream {
        /**
         * Constructs a new DataOutputStream on the OutputStream
         * out Note that data written by this stream is not in a human
         * readable form but can be reconstructed by using a {@link DataInputStream}
         * on the resulting output.
         *
         * @param out
         *            the target stream for writing.
         */
        constructor(
            [in] IOutputStream* os);

        interface IDataOutput;
        interface IDataOutputStream;
    }

    [deprecated]
    class CCharArrayReader {
        /**
         * Constructs a CharArrayReader on the char array buf The size of
         * the reader is set to the length of the buffer and the object to to read
         * from is set to buf
         *
         * @param buf
         *            the char array from which to read.
         */
        constructor(
            [in] ArrayOf<Char8> buf);

        /**
         * Constructs a CharArrayReader on the char array buf The size of
         * the reader is set to length} and the start position from which to
         * read the buffer is set to offset
         *
         * @param buf
         *            the char array from which to read.
         * @param offset
         *            the index of the first character in buf} to read.
         * @param length
         *            the number of characters that can be read from buf
         * @throws IllegalArgumentException
         *             if offset < 0} or length < 0 or if
         *             offset} is greater than the size of buf} .
         */
        constructor(
            [in] ArrayOf<Char8> buf,
            [in] Int32 offset,
            [in] Int32 length);

        interface ICharArrayReader;
    }

   /**
    * This class implements a character buffer that can be used as an Writer. The buffer automatically grows when data is written to the stream.
    * The data can be retrieved using toCharArray() and toString().
    * Note: Invoking close() on this class has no effect, and methods of this class can be called after the stream has closed without generating an IOException.

    * @implements com::elastos::ICharArrayWriter
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IAppendable
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/CharArrayWriter.html
    */
    class CCharArrayWriter {
        /**
         * Constructs a new CharArrayWriter} which has a buffer allocated
         * with the default size of 32 characters. This buffer is also used as the
         * lock} to synchronize access to this writer.
         */
        constructor();
        /**
         * Constructs a new CharArrayWriter} which has a buffer allocated
         * with the size of initialSize} characters. The buffer is also used
         * as the lock} to synchronize access to this writer.
         *
         * @param initialSize
         *            the initial size of this CharArrayWriters buffer.
         * @throws IllegalArgumentException
         *             if initialSize < 0
         */
        constructor(
            [in] Int32 initialSize);

        interface ICharArrayWriter;
    }

   /**
    * Wraps an existing Reader and buffers the input. Expensive interaction with the underlying reader is minimized, since most (smaller)
    * requests can be satisfied by accessing the buffer alone. The drawback is that some extra space is required to hold the buffer
    * and that copying takes place when filling that buffer, but this is usually outweighed by the performance benefits.
    *
    * A typical application pattern for the class looks like this:
    * @code{.cpp}
    * BufferedReader buf = new BufferedReader(new FileReader("file.car"));
    * @endcode
    *
    * @implements com::elastos::IBufferedReader
    *
    * @sa com::elastos::CBufferedWriter
    *
    * <strong>Direct Known Subclasses:</strong>
    * - @ref com::elastos::CLineNumberReader
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedReader.html
    */
    class CBufferedReader {
        /**
        * Constructs a new BufferedReader, providing in with a buffer of 8192 characters.
        *
        * @param rin the IReader the buffer reads from.
        */
        constructor(
            [in] IReader* rin);

        /**
        * Constructs a new BufferedReader providing in} with size} characters of buffer.
        *
        * @param rin the IReader the buffer reads from.
        * @param size the size of buffer in characters.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if size <= 0
        */
        constructor(
            [in] IReader* rin,
            [in] Int32 size);

        interface IBufferedReader;
    }

   /**
    * Wraps an existing Writer and buffers the output. Expensive interaction with the underlying reader is minimized,
    * since most (smaller) requests can be satisfied by accessing the buffer alone. The drawback is that some extra space is required
    * to hold the buffer and that copying takes place when filling that buffer, but this is usually outweighed by the performance benefits.
    *
    * A typical application pattern for the class looks like this:
    * @code{.cpp}
    * BufferedWriter buf = new BufferedWriter(new FileWriter("file.car"));
    * @endcode
    *
    *
    * @implements com::elastos::IBufferedWriter
    *
    * @sa com::elastos::CBufferedReader
    *
    * <strong>Direct Known Subclasses:</strong>
    * - @ref com::elastos::CLineNumberWriter
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedWriter.html
    */
    class CBufferedWriter {
        /**
         * Constructs a new BufferedWriter providing out} with a buffer of 8192 bytes.
         *
         * @param wout the IWriter the buffer writes to.
         */
        constructor(
            [in] IWriter* wout);

        /**
         * Constructs a new BufferedWriter providing out} with size} bytes
         * of buffer.
         *
         * @param out the IWriter the buffer writes to.
         * @param size the size of buffer in bytes.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if size <= 0
         */
        constructor(
            [in] IWriter* wout,
            [in] Int32 size);

        interface IBufferedWriter;
    }

   /**
    * A specialized InputStream that reads bytes from a String in a sequential manner.
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/StringBufferInputStream.html
    */
    class CStringBufferInputStream {
        /**
         * Construct a new StringBufferInputStream with str as source. The size of the stream is set to the length of the string.
         *
         * @param str  the source string for this stream.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if str is null
         *
         * @todo Fields
         *   -  String buffer The source string containing the data to read.
         *   -  int count The total number of characters in the source string.
         *   -  int pos The current position within the source string.
         */
        constructor(
            [in] String str);

        interface IStringBufferInputStream;
    }

    class CLineNumberInputStream {
        /**
         * Constructs a new LineNumberInputStream on the InputStream
         * in Line numbers are counted for all data read from this stream.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * LineNumberInputStream All operations on such a stream will fail.
         *
         * @param in
         *            The non-null input stream to count line numbers.
         */
        constructor(
            [in] IInputStream* is);

        interface ILineNumberInputStream;
    }

    class CLineNumberReader {
        /**
         * Constructs a new LineNumberReader on the Reader in The internal
         * buffer gets the default size (8 KB).
         *
         * @param in
         *            the Reader that is buffered.
         */
        constructor(
            [in] IReader* ir);
        /**
         * Constructs a new LineNumberReader on the Reader in The size of
         * the internal buffer is specified by the parameter size
         *
         * @param in
         *            the Reader that is buffered.
         * @param size
         *            the size of the buffer to allocate.
         * @throws IllegalArgumentException
         *             if size <= 0
         */
        constructor(
            [in] IReader* ir,
            [in] Int32 size);

        interface ILineNumberReader;
    }

    class CPushbackInputStream {
        /**
         * Constructs a new PushbackInputStream} with the specified input
         * stream as source. The size of the pushback buffer is set to the default
         * value of 1 byte.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * PushbackInputStream All read operations on such a stream will
         * fail.
         *
         * @param in
         *            the source input stream.
         */
        constructor(
            [in] IInputStream* is);
        /**
         * Constructs a new PushbackInputStream} with in} as source
         * input stream. The size of the pushback buffer is set to size
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * PushbackInputStream All read operations on such a stream will
         * fail.
         *
         * @param in
         *            the source input stream.
         * @param size
         *            the size of the pushback buffer.
         * @throws IllegalArgumentException
         *             if size} is negative.
         */
        constructor(
            [in] IInputStream* is,
            [in] Int32 size);

        interface IPushbackInputStream;
    }

    class CPushbackReader {
        /**
         * Constructs a new PushbackReader} with the specified reader as
         * source. The size of the pushback buffer is set to the default value of 1
         * character.
         *
         * @param in
         *            the source reader.
         */
        constructor(
            [in] IReader* ir);
        /**
         * Constructs a new PushbackReader} with in} as source reader.
         * The size of the pushback buffer is set to size
         *
         * @param in
         *            the source reader.
         * @param size
         *            the size of the pushback buffer.
         * @throws IllegalArgumentException
         *             if size} is negative.
         */
        constructor(
            [in] IReader* ir,
            [in] Int32 size);

        interface IPushbackReader;
    }

    class CFilePermission {
        /**
         * Constructs a new FilePermission with the path and actions specified.
         *
         * @param path
         *            the pathname of the file or directory to apply the actions to.
         * @param actions
         *            the actions for the path May be any combination of
         *            "read", "write", "execute" and "delete".
         * @throws IllegalArgumentException
         *             if actions} is null} or an empty string, or if
         *             it contains a string other than "read", "write", "execute"
         *             and "delete".
         * @throws NullPointerException
         *             if path} is null
         */
        constructor(
            [in] String path,
            [in] String actions);

        interface IFilePermission;
    }

    class CFilePermissionCollection {
        interface IFilePermissionCollection;
    }

    class CSequenceInputStream {
        /**
         * Constructs a new SequenceInputStream} using the two streams
         * s1} and s2} as the sequence of streams to read from.
         *
         * @param s1
         *            the first stream to get bytes from.
         * @param s2
         *            the second stream to get bytes from.
         * @throws NullPointerException
         *             if s1} is null
         */
        constructor(
            [in] IInputStream *s1,
            [in] IInputStream *s2);

        /**
         * Constructs a new SequenceInputStream using the elements returned from
         * Enumeration e} as the stream sequence. The instances returned by
         * e.nextElement()} must be of type {@link InputStream
         *
         * @param e
         *            the enumeration of InputStreams} to get bytes from.
         * @throws NullPointerException
         *             if any of the elements in e} is null
         */
        constructor(
            [in] IObjectEnumerator* e);

        interface IInputStream;
    }

    singleton class CCharsetHelper {
        interface ICharsetHelper;
    }

    singleton class CCharsets {
        interface ICharsets;
    }

    class CCoderResult {
        interface ICoderResult;
    }

    singleton class CCoderResultHelper {
        interface ICoderResultHelper;
    }

    class CCodingErrorAction {
        interface ICodingErrorAction;
    }

    singleton class CModifiedUtf8 {
        interface IModifiedUtf8;
    }

    singleton class CNativeConverter {
        interface INativeConverter;
    }

    class CCharsetICU {
        constructor(
            [in] String canonicalName,
            [in] String icuCanonName,
            [in] ArrayOf<String> aliases);

        interface ICharset;
    }

    class CCharsetEncoderICU {
        interface ICharsetEncoder;
    }

    class CInputStreamReader {
        /**
         * Constructs a new InputStreamReader} on the {@link InputStream}
         * in This constructor sets the character converter to the encoding
         * specified in the "file.encoding" property and falls back to ISO 8859_1
         * (ISO-Latin-1) if the property doesn't exist.
         *
         * @param in
         *            the input stream from which to read characters.
         */
        constructor(
            [in] IInputStream* is);

        /**
         * Constructs a new InputStreamReader on the InputStream in The
         * character converter that is used to decode bytes into characters is
         * identified by name by enc If the encoding cannot be found, an
         * UnsupportedEncodingException error is thrown.
         *
         * @param in
         *            the InputStream from which to read characters.
         * @param enc
         *            identifies the character converter to use.
         * @throws NullPointerException
         *             if enc} is null
         * @throws UnsupportedEncodingException
         *             if the encoding specified by enc} cannot be found.
         */
        constructor(
            [in] IInputStream* is,
            [in] String enc);

//        /**
//         * Constructs a new InputStreamReader on the InputStream in} and
//         * CharsetDecoder dec
//         *
//         * @param in
//         *            the source InputStream from which to read characters.
//         * @param dec
//         *            the CharsetDecoder used by the character conversion.
//         */
//        constructor(
//            [in] IInputStream* in,
//            [in] CharsetDecoder dec);
//
        /**
         * Constructs a new InputStreamReader on the InputStream in} and
         * Charset charset
         *
         * @param in
         *            the source InputStream from which to read characters.
         * @param charset
         *            the Charset that defines the character converter
         */
        constructor(
            [in] IInputStream* ins,
            [in] ICharset* charset);


        interface IInputStreamReader;
    }

    class COutputStreamWriter {
        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to. The default character encoding
         * is used.
         *
         * @param out
         *            the non-null target stream to write converted bytes to.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to and enc} as the character
         * encoding. If the encoding cannot be found, an
         * UnsupportedEncodingException error is thrown.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param enc
         *            the string describing the desired character encoding.
         * @throws NullPointerException
         *             if enc} is null
         * @throws UnsupportedEncodingException
         *             if the encoding specified by enc} cannot be found.
         */
        constructor(
            [in] IOutputStream* os,
            [in] String enc);

        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to and cs} as the character
         * encoding.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param cs
         *            the Charset} that specifies the character encoding.
         */
//        constructor(
//            [in] IOutputStream* os,
//            [in] Charset cs);

        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to and enc} as the character
         * encoder.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param enc
         *            the character encoder used for character conversion.
         */
//        constructor(
//            [in] IOutputStream* os,
//            [in] CharsetEncoder enc);

        interface IOutputStreamWriter;
    }

    class CFileReader {
        /**
         * Constructs a new FileReader on the given file
         *
         * @param file
         *            a File to be opened for reading characters from.
         * @throws FileNotFoundException
         *             if file} does not exist.
         */
        constructor(
            [in] IFile* file);

        /**
         * Construct a new FileReader on the given FileDescriptor fd Since
         * a previously opened FileDescriptor is passed as an argument, no
         * FileNotFoundException can be thrown.
         *
         * @param fd
         *            the previously opened file descriptor.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Construct a new FileReader on the given file named filename
         *
         * @param filename
         *            an absolute or relative path specifying the file to open.
         * @throws FileNotFoundException
         *             if there is no file named filename
         */
        constructor(
            [in] String filename);

        interface IInputStreamReader;
    }

    class CFileWriter {
        /**
         * Creates a FileWriter using the File file
         *
         * @param file
         *            the non-null File to write bytes to.
         * @throws IOException
         *             if file} cannot be opened for writing.
         */
        constructor(
            [in] IFile* file);

        /**
         * Creates a FileWriter using the File file The parameter
         * append} determines whether or not the file is opened and appended
         * to or just opened and overwritten.
         *
         * @param file
         *            the non-null File to write bytes to.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws IOException
         *             if the file} cannot be opened for writing.
         */
        constructor(
            [in] IFile* file,
            [in] Boolean append);

        /**
         * Creates a FileWriter using the existing FileDescriptor fd
         *
         * @param fd
         *            the non-null FileDescriptor to write bytes to.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Creates a FileWriter using the platform dependent filename
         *
         * @param filename
         *            the non-null name of the file to write bytes to.
         * @throws IOException
         *             if the file cannot be opened for writing.
         */
        constructor(
            [in] String filename);

        /**
         * Creates a FileWriter using the platform dependent filename The
         * parameter append} determines whether or not the file is opened and
         * appended to or just opened and overwritten.
         *
         * @param filename
         *            the non-null name of the file to write bytes to.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws IOException
         *             if the file} cannot be opened for writing.
         */
        constructor(
            [in] String filename,
            [in] Boolean append);

        interface IOutputStreamWriter;
    }

    class CStringReader {
        /**
         * Construct a new StringReader} with str} as source. The size
         * of the reader is set to the length()} of the string and the Object
         * to synchronize access through is set to str
         *
         * @param str
         *            the source string for this reader.
         */
        constructor(
            [in] String str);

        interface IStringReader;
    }

    class CStringWriter {
        /**
         * Constructs a new StringWriter} which has a {@link StringBuffer}
         * allocated with the default size of 16 characters. The {@code
         * StringBuffer} is also the lock} used to synchronize access to this
         * writer.
         */
        constructor();

        /**
         * Constructs a new StringWriter} which has a {@link StringBuffer}
         * allocated with a size of initialSize} characters. The {@code
         * StringBuffer} is also the lock} used to synchronize access to this
         * writer.
         *
         * @param initialSize
         *            the intial size of the target string buffer.
         */
        constructor(
            [in] Int32 initialSize);

        interface IStringWriter;
    }

    singleton class CByteBufferHelper {
        interface IByteBufferHelper;
    }
    
    singleton class CCharBufferHelper {
        constructor();
        
        interface ICharBufferHelper;
    }
	
	singleton class CChannels {
		constructor();
		
		interface IChannels;
	}

    class CPrintWriter {
        /**
         * Constructs a new PrintWriter} with out} as its target
         * stream. By default, the new print writer does not automatically flush its
         * contents to the target stream when a newline is encountered.
         *
         * @param out
         *            the target output stream.
         * @throws NullPointerException
         *             if out} is null
         */
        constructor(
            [in] IOutputStream* outs);

        /**
         * Constructs a new PrintWriter} with out} as its target
         * stream. The parameter autoflush} determines if the print writer
         * automatically flushes its contents to the target stream when a newline is
         * encountered.
         *
         * @param out
         *            the target output stream.
         * @param autoflush
         *            indicates whether contents are flushed upon encountering a
         *            newline sequence.
         * @throws NullPointerException
         *             if out} is null
         */
        constructor(
            [in] IOutputStream* outs, 
            [in] Boolean autoflush);

        /**
         * Constructs a new PrintWriter} with wr} as its target
         * writer. By default, the new print writer does not automatically flush its
         * contents to the target writer when a newline is encountered.
         *
         * @param wr
         *            the target writer.
         * @throws NullPointerException
         *             if wr} is null
         */
        constructor(
            [in] IWriter* wr);

        /**
         * Constructs a new PrintWriter} with out} as its target
         * writer. The parameter autoflush} determines if the print writer
         * automatically flushes its contents to the target writer when a newline is
         * encountered.
         *
         * @param wr
         *            the target writer.
         * @param autoflush
         *            indicates whether to flush contents upon encountering a
         *            newline sequence.
         * @throws NullPointerException
         *             if out} is null
         */
        constructor(
            [in] IWriter* wr, 
            [in] Boolean autoflush);

        /**
         * Constructs a new PrintWriter} with file} as its target. The
         * virtual machine's default character set is used for character encoding.
         * The print writer does not automatically flush its contents to the target
         * file when a newline is encountered. The output to the file is buffered.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a new PrintWriter} with file} as its target. The
         * character set named csn} is used for character encoding.
         * The print writer does not automatically flush its contents to the target
         * file when a newline is encountered. The output to the file is buffered.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] IFile* file, 
            [in] String csn);
        /**
         * Constructs a new PrintWriter} with the file identified by {@code
         * fileName} as its target. The virtual machine's default character set is
         * used for character encoding. The print writer does not automatically
         * flush its contents to the target file when a newline is encountered. The
         * output to the file is buffered.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a new PrintWriter} with the file identified by {@code
         * fileName} as its target. The character set named csn} is used for
         * character encoding. The print writer does not automatically flush its
         * contents to the target file when a newline is encountered. The output to
         * the file is buffered.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] String fileName, 
            [in] String csn);

        interface IPrintWriter;
    }

    class CPrintStream {
        /**
         * Constructs a new PrintStream} with out} as its target
         * stream. By default, the new print stream does not automatically flush its
         * contents to the target stream when a newline is encountered.
         *
         * @param out
         *            the target output stream.
         * @throws NullPointerException
         *             if out} is null
         */
        constructor(
            [in] IOutputStream* outs);

        /**
         * Constructs a new PrintStream} with out} as its target
         * stream. The parameter autoflush} determines if the print stream
         * automatically flushes its contents to the target stream when a newline is
         * encountered.
         *
         * @param out
         *            the target output stream.
         * @param autoflush
         *            indicates whether to flush contents upon encountering a
         *            newline sequence.
         * @throws NullPointerException
         *             if out} is null
         */
        constructor(
            [in] IOutputStream* outs, 
            [in] Boolean autoflush);

        /**
         * Constructs a new PrintStream} with out} as its target
         * stream and using the character encoding enc} while writing. The
         * parameter autoflush} determines if the print stream automatically
         * flushes its contents to the target stream when a newline is encountered.
         *
         * @param out
         *            the target output stream.
         * @param autoflush
         *            indicates whether or not to flush contents upon encountering a
         *            newline sequence.
         * @param enc
         *            the non-null string describing the desired character encoding.
         * @throws NullPointerException
         *             if out} or enc} are null
         * @throws UnsupportedEncodingException
         *             if the encoding specified by enc} is not supported.
         */
        constructor(
            [in] IOutputStream* outs, 
            [in] Boolean autoflush, 
            [in] String enc);

        /**
         * Constructs a new PrintStream} with file} as its target. The
         * virtual machine's default character set is used for character encoding.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a new PrintStream} with file} as its target. The
         * character set named csn} is used for character encoding.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] IFile* file, 
            [in] String csn);

        /**
         * Constructs a new PrintStream} with the file identified by
         * fileName} as its target. The virtual machine's default character
         * set is used for character encoding.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a new PrintStream} with the file identified by
         * fileName} as its target. The character set named csn} is
         * used for character encoding.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] String fileName, 
            [in] String csn);

        interface IPrintStream;
    }
}

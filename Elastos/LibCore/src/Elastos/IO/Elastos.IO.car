/** @file Elastos.IO.car
 *  @brief CAR file for Elastos IO library.
 *
 *  This contains the prototypes for the Elastos IO library.
 *  Java: 
 *
 *  @author cao.jing
 *  @bug No known bugs.
 */

module
{
    importlib("Elastos.Core.eco");
    importlib("Elastos.Utility.eco");

    merge("../../../car/Elastos/IO/Errors.car");
    merge("../../../car/Elastos/IO/Exceptions.car");
    merge("../../../car/Elastos/IO/IInputStream.car");
    merge("../../../car/Elastos/IO/IFilterInputStream.car"); 
    merge("../../../car/Elastos/IO/IBufferedInputStream.car");
    merge("../../../car/Elastos/IO/IOutputStream.car");
    merge("../../../car/Elastos/IO/IFilterOutputStream.car");
    merge("../../../car/Elastos/IO/IBufferedOutputStream.car");
    merge("../../../car/Elastos/IO/IByteArrayInputStream.car");
    merge("../../../car/Elastos/IO/IByteArrayOutputStream.car");
    merge("../../../car/Elastos/IO/IFileFilter.car");
    merge("../../../car/Elastos/IO/IFilenameFilter.car");
    merge("../../../car/Elastos/IO/IFile.car");
    merge("../../../car/Elastos/IO/IFileDescriptor.car");
    merge("../../../car/Elastos/IO/IFileInputStream.car");
    merge("../../../car/Elastos/IO/IFileOutputStream.car");
    merge("../../../car/Elastos/IO/IDataInput.car");
    merge("../../../car/Elastos/IO/IDataInputStream.car");
    merge("../../../car/Elastos/IO/IDataOutput.car");
    merge("../../../car/Elastos/IO/IDataOutputStream.car");
    merge("../../../car/Elastos/IO/IObjectInput.car");
    merge("../../../car/Elastos/IO/IObjectOutput.car");
    merge("../../../car/Elastos/IO/IObjectInputValidation.car");
    merge("../../../car/Elastos/IO/IReader.car");
    merge("../../../car/Elastos/IO/IWriter.car");
    merge("../../../car/Elastos/IO/ICharArrayReader.car");
    merge("../../../car/Elastos/IO/ICharArrayWriter.car");
    merge("../../../car/Elastos/IO/IBufferedReader.car");
    merge("../../../car/Elastos/IO/IBufferedWriter.car");
    merge("../../../car/Elastos/IO/IStringBufferInputStream.car");
    merge("../../../car/Elastos/IO/ILineNumberInputStream.car");
    merge("../../../car/Elastos/IO/ILineNumberReader.car");
    merge("../../../car/Elastos/IO/IPushbackInputStream.car");
    merge("../../../car/Elastos/IO/IPushbackReader.car");
    merge("../../../car/Elastos/IO/IFilePermission.car");
    merge("../../../car/Elastos/IO/IFilePermissionCollection.car");
    merge("../../../car/Elastos/IO/IInputStreamReader.car");
    merge("../../../car/Elastos/IO/IOutputStreamWriter.car");
    merge("../../../car/Elastos/IO/IPrintWriter.car");
    merge("../../../car/Elastos/IO/IPrintStream.car");
    merge("../../../car/Elastos/IO/IStringReader.car");
    merge("../../../car/Elastos/IO/IStringWriter.car");
    merge("../../../car/Elastos/IO/ICloseable.car");
    merge("../../../car/Elastos/IO/IRandomAccessFile.car");
    /************************************NIO**********************************/
    merge("../../../car/Elastos/IO/ByteOrder.car");
    merge("../../../car/Elastos/IO/IBuffer.car");
    merge("../../../car/Elastos/IO/IByteBuffer.car");
    merge("../../../car/Elastos/IO/ICharBuffer.car");
    merge("../../../car/Elastos/IO/IDoubleBuffer.car");
    merge("../../../car/Elastos/IO/IFloatBuffer.car");
    merge("../../../car/Elastos/IO/IInt16Buffer.car");
    merge("../../../car/Elastos/IO/IInt32Buffer.car");
    merge("../../../car/Elastos/IO/IInt64Buffer.car");
    merge("../../../car/Elastos/IO/IMappedByteBuffer.car");
    merge("../../../car/Elastos/IO/Channels/IChannel.car");
    merge("../../../car/Elastos/IO/charset/ICharset.car");
    merge("../../../car/Elastos/IO/charset/ICharsets.car");
    merge("../../../car/Elastos/IO/charset/ICharsetDecoder.car");
    merge("../../../car/Elastos/IO/charset/ICharsetEncoder.car");
    merge("../../../car/Elastos/IO/charset/ICoderResult.car");
    merge("../../../car/Elastos/IO/charset/ICodingErrorAction.car");
    merge("../../../car/Elastos/IO/charset/IModifiedUtf8.car");
    merge("../../../car/Elastos/IO/charset/INativeConverter.car");
    merge("../../../car/Elastos/IO/charset/spi/ICharsetProvider.car");
    merge("../../../car/Elastos/IO/Channels/IChannels.car");
    merge("../../../car/Elastos/IO/Channels/IReadableByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IWritableByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IInterruptibleChannel.car");
    merge("../../../car/Elastos/IO/Channels/ISelectableChannel.car");
//    merge("../../../car/Elastos/IO/Channels/IDatagramChannel.car");
    merge("../../../car/Elastos/IO/Channels/IFileChannel.car");
    merge("../../../car/Elastos/IO/Channels/IFileLock.car");
    merge("../../../car/Elastos/IO/Channels/IGatheringByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IPipe.car");
    merge("../../../car/Elastos/IO/Channels/IScatteringByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/ISelectionKey.car");
    merge("../../../car/Elastos/IO/Channels/ISelector.car");
//    merge("../../../car/Elastos/IO/Channels/IServerSocketChannel.car");
    merge("../../../car/Elastos/IO/Channels/Spi/ISelectorProvider.car");



   /**
    * A CFilterInputStream contains some other input stream, which it uses as its basic source of data, possibly transforming the data 
    * along the way or providing additional functionality. The class FilterInputStream itself simply overrides all methods of 
    * InputStream with versions that pass all requests to the contained input stream. Subclasses of FilterInputStream may further
    * override some of these methods and may also provide additional methods and fields.
    * 
    * @implements com::elastos::IInputStream
    *
    * <strong>Direct Known Subclasses:</strong>
    * - @ref com::elastos::CBufferedInputStream
    * - @ref com::elastos::CCheckedInputStream
    * - @ref com::elastos::CCipherInputStream
    * - @ref com::elastos::CDataInputStream
    * - @ref com::elastos::CDeflaterInputStream
    * - @ref com::elastos::CDigestInputStream
    * - @ref com::elastos::CInflaterInputStream
    * - @ref com::elastos::CLineNumberInputStream,
    * - @ref com::elastos::CProgressMonitorInputStream
    * - @ref com::elastos::CPushbackInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/FilterInputStream.html
    */
    class CFilterInputStream {
       /**
        * Constructs a new with the specified input stream as source.
        *
        * <p><strong>Warning:</strong> passing a null source creates an invalid,
        * that fails on every method that is not overridden.
        * Subclasses should check for null in their constructors.
        *
        * @param is    the input stream to filter reads on.
        * @return ECode    NOERROR(0)
        */
        constructor(
            [in] IInputStream* is);

        interface IFilterInputStream;
    }

   /**
    * Instances of this class support both reading and writing to a random access file. A random access file behaves like a large array of bytes stored in the file system.
    * There is a kind of cursor, or index into the implied array, called the file pointer; input operations read bytes starting at the file pointer and advance the file pointer     
    * past the bytes read. If the random access file is created in read/write mode, then output operations are also available; output operations write bytes starting at the file pointer and advance the file pointer past the bytes written. Output operations that write past the current end of the implied array cause the array to be extended. The file pointer can be read by the getFilePointer method and set by the seek method.
    * It is generally true of all the reading routines in this class that if end-of-file is reached before the desired number of bytes has been read, an EOFException (which is a kind of IOException) is thrown. If any byte cannot be read for any reason other than end-of-file, an IOException other than EOFException is thrown. In particular, an IOException may be thrown if the stream has been closed.
    * 
    * @implements com::elastos::IRandomAccessFile
    * @implements com::elastos::IDataInput
    * @implements com::elastos::IDataOutput
    *
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/RandomAccessFile.html
    */
    class CRandomAccessFile {
       /**
        * @brief Constructs a new with the specified input stream as source.
        * 
        * Creates a random access file stream to read from, and optionally to write to, a file with the specified name. 
        * A new FileDescriptor object is created to represent the connection to the file.
        * The mode argument specifies the access mode with which the file is to be opened. The permitted values and their
        * meanings are as specified for the RandomAccessFile(File,String) constructor.
        * 
        * If there is a security manager, its checkRead method is called with the name argument as its argument to see
        * if read access to the file is allowed. If the mode allows writing, the security manager's checkWrite method is
        * also called with the name argument as its argument to see if write access to the file is allowed.
        *
        * @sa com::elastos::ISecurityManager::CheckRead()
        * 
        * @param file    the file object.
        * @param mode    the access mode, as described @ref mode
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if the mode argument is not equal to one of "r", "rw", "rws", or "rwd"
        * FileNotFoundException | if the mode is "r" but the given file object does not denote an existing regular file, or if the mode begins with "rw" but the given file object does not denote an existing, writable regular file and a new regular file of that name cannot be created, or if some other error occurs while opening or creating the file
        * SecurityException | if a security manager exists and its checkRead method denies read access to the file or the mode is "rw" and the security manager's checkWrite method denies write access to the file
        */
        constructor(
            [in] IFile* pFile,
            [in] CString mode);

       /**
        * @brief Creates a random access file stream to read from, and optionally to write to, the file specified by the File argument.
        *
        * Creates a random access file stream to read from, and optionally to write to, the file specified by the File argument. A new FileDescriptor
        * object is created to represent this file connection. The mode argument specifies the access mode in which the file is to be opened. The
        * permitted values and their meanings are:
        *
        * @section mode
        *
        * Value | Meaning |
        * :-|:------------|
        * "r"| Open for reading only. Invoking any of the write methods of the resulting object will cause an IOException to be thrown.
        * "rw"| Open for reading and writing. If the file does not already exist then an attempt will be made to create it.
        * "rws" | Open for reading and writing, as with "rw", and also require that every update to the file's content or metadata be written synchronously to the underlying storage device.
        * "rwd" | Open for reading and writing, as with "rw", and also require that every update to the file's content be written synchronously to the underlying storage device.
        * 
        * The "rws" and "rwd" modes work much like the force(boolean) method of the FileChannel class, passing arguments of true and false, 
        * respectively, except that they always apply to every I/O operation and are therefore often more efficient. If the file resides on
        * a local storage device then when an invocation of a method of this class returns it is guaranteed that all changes made to the file
        * by that invocation will have been written to that device. This is useful for ensuring that critical information is not lost in the
        * event of a system crash. If the file does not reside on a local device then no such guarantee is made.
        * 
        * The "rwd" mode can be used to reduce the number of I/O operations performed. Using "rwd" only requires updates to the file's content
        * to be written to storage; using "rws" requires updates to both the file's content and its metadata to be written, which generally
        * requires at least one more low-level I/O operation.
        * 
        * If there is a security manager, its checkRead method is called with the pathname of the file argument as its argument to see if read
        * access to the file is allowed. If the mode allows writing, the security manager's checkWrite method is also called with the path argument to see if write access to the file is allowed.
        * 
        * @sa com::elastos::ISecurityManager::CheckRead()
        * 
        * @param fileName     the system-dependent filename.
        * @param mode    the access mode, as described above.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if the mode argument is not equal to one of "r", "rw", "rws", or "rwd"
        * FileNotFoundException | if the mode is "r" but the given string does not denote an existing regular file, or if the mode begins with "rw" but the given string does not denote an existing, writable regular file and a new regular file of that name cannot be created, or if some other error occurs while opening or creating the file.
        * SecurityException | if a security manager exists and its checkRead method denies read access to the file or the mode is "rw" and the security manager's checkWrite method denies write access to the file.
        */
        constructor(
            [in] String fileName,
            [in] CString mode);

        interface IRandomAccessFile;
        interface IDataInput;
        interface IDataOutput;
    }

   /**
    * A CBufferedInputStream adds functionality to another input stream-namely, the ability to buffer the input and to support the mark and reset methods. 
    * When the CBufferedInputStream is created, an internal buffer array is created. As bytes from the stream are read or skipped, the internal buffer
    * is refilled as necessary from the contained input stream, many bytes at a time. The mark operation remembers a point in the input stream and the
    * reset operation causes all the bytes read since the most recent mark operation to be reread before new bytes are taken from the contained input stream.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IBufferedInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedInputStream.html
    */
    class CBufferedInputStream {
       /**
        * @brief Creates a BufferedInputStream and saves its argument, the input stream in, for later use.
        *
        * Creates a BufferedInputStream and saves its argument, the input stream in, for later use. An internal buffer array is created and stored in buf.
        *
        * @param is the buffer reads from
        */
        constructor(
            [in] IInputStream* is);

       /**
        * @brief Creates a BufferedInputStream with the specified buffer size, and saves its argument, the input stream in, for later use.
        *
        * Creates a BufferedInputStream with the specified buffer size, and saves its argument, the input stream in, for later use.
        * An internal buffer array of length size is created and stored in buf.
        *
        * @param is    the buffer reads from
        * @param size  the buffer size.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if size <= 0.
        */
        constructor(
            [in] IInputStream* is,
            [in] Int32 size);

        interface IBufferedInputStream;
    }

   /**
    * This class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream
    * (the underlying output stream) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality.
    * 
    * The class FilterOutputStream itself simply overrides all methods of OutputStream with versions that pass all requests to the underlying
    * output stream. Subclasses of FilterOutputStream may further override some of these methods as well as provide additional methods and fields.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IFilterOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/FilterOutputStream.html
    */
    class CFilterOutputStream {
       /**
        * @brief  Creates an output stream filter built on top of the specified underlying output stream.
        *
        * @param os  the underlying output stream to be assigned to the field this.out for later use, or null if this instance is to be created without an underlying stream.
        */
        constructor(
            [in] IOutputStream* os);

        interface IFilterOutputStream;
    }

   /**
    * The class implements a buffered output stream. By setting up such an output stream, an application can write bytes to the underlying output stream without
    * necessarily causing a call to the underlying system for each byte written.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IBufferedOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedOutputStream.html
    */
    class CBufferedOutputStream {
       /**
        * @brief  Constructs a new IBufferedOutputStream, providing with a buffer
        *
        * @param os IOutputStream the buffer writes to.
        */
        constructor(
            [in] IOutputStream* os);

       /**
        * @brief  Constructs a new IBufferedOutputStream, providing os with size bytes of buffer.
        *
        * @param out the IOutputStream the buffer writes to.
        * @param size the size of buffer in bytes.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if size <= 0
        */
        constructor(
            [in] IOutputStream* os,
            [in] Int32 size);

        interface IBufferedOutputStream;
    }

   /**
    * A ByteArrayInputStream contains an internal buffer that contains bytes that may be read from the stream. An internal counter keeps track of the next byte to be supplied by the read method.
    * Closing a ByteArrayInputStream has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IByteArrayInputStream
    * 
    * @sa com::elastos::StringBufferInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/ByteArrayInputStream.html
    */
    class CByteArrayInputStream {
        /**
         * @brief Constructs a new ByteArrayInputStream on the byte array
         *
         * @param buffer   the byte array to stream over.
         */
        constructor(
            [in] BufferOf<Byte> buffer);

        /**
         * @brief Constructs a new IByteArrayInputStream on the byte array with the initial position set to offset and the
         * number of bytes available set to offset + length.
         *
         * @param buf
         *            the byte array to stream over.
         * @param offset
         *            the initial position in  buf} to start streaming from.
         * @param length
         *            the number of bytes available for streaming.
         */
        constructor(
            [in] BufferOf<Byte> buffer,
            [in] Int32 offset,
            [in] Int32 length);

        interface IByteArrayInputStream;
    }

   /**
    * This class implements an output stream in which the data is written into a byte array. The buffer automatically grows as data is written to it. 
    * The data can be retrieved using toByteArray() and toString().
    * Closing a ByteArrayOutputStream has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.
    * 
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IByteArrayOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/ByteArrayOutputStream.html
    */
    class CByteArrayOutputStream {
        /**
         * Constructs a new ByteArrayOutputStream with a default size of 32 bytes.
         * If more than 32 bytes are written to this instance, the underlying byte
         * array will expand.
         */
        constructor();

        /**
         * Constructs a new  ByteArrayOutputStream with a default size of
         * size bytes. If more than size bytes are written to this
         * instance, the underlying byte array will expand.
         *
         * @param size
         *            initial size for the underlying byte array, must be
         *            non-negative.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if size < 0.
         */
        constructor(
            [in] Int32 size);

        interface IByteArrayOutputStream;
    }

   /**
    * An abstract representation of file and directory pathnames.
    * 
    * User interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames. An abstract pathname has two components:
    * 
    * An optional system-dependent prefix string, such as a disk-drive specifier, "/" for the UNIX root directory, or "\\\\" for a Microsoft Windows UNC pathname, and
    * A sequence of zero or more string names.
    * The first name in an abstract pathname may be a directory name or, in the case of Microsoft Windows UNC pathnames, a hostname. Each subsequent name in an abstract pathname denotes a directory; the last name may denote either a directory or a file. The empty abstract pathname has no prefix and an empty name sequence.
    * The conversion of a pathname string to or from an abstract pathname is inherently system-dependent. When an abstract pathname is converted into a pathname string, each name is separated from the next by a single copy of the default separator character. The default name-separator character is defined by the system property file.separator, and is made available in the public static fields separator and separatorChar of this class. When a pathname string is converted into an abstract pathname, the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system.
    * 
    * A pathname, whether abstract or in string form, may be either absolute or relative. An absolute pathname is complete in that no other information is required in order to locate the file that it denotes. A relative pathname, in contrast, must be interpreted in terms of information taken from some other pathname. By default the classes in the java.io package always resolve relative pathnames against the current user directory. This directory is named by the system property user.dir, and is typically the directory in which the Java virtual machine was invoked.
    * 
    * The parent of an abstract pathname may be obtained by invoking the getParent() method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any File object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname "/usr" is an ancestor of the directory denoted by the pathname "/usr/local/bin".
    * 
    * The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows:
    * 
    * - For UNIX platforms, the prefix of an absolute pathname is always "/". Relative pathnames have no prefix. The abstract pathname denoting the root directory has the prefix "/" and an empty name sequence.
    * - For Microsoft Windows platforms, the prefix of a pathname that contains a drive specifier consists of the drive letter followed by ":" and possibly followed by "\\" if the pathname is absolute. The prefix of a UNC pathname is "\\\\"; the hostname and the share name are the first two names in the name sequence. A relative pathname that does not specify a drive has no prefix.
    * Instances of this class may or may not denote an actual file-system object such as a file or a directory. If it does denote such an object then that object resides in a partition. A partition is an operating system-specific portion of storage for a file system. A single storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may contain multiple partitions. The object, if any, will reside on the partition named by some ancestor of the absolute form of this pathname.
    * 
    * A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing. These restrictions are collectively known as access permissions. The file system may have multiple sets of access permissions on a single object. For example, one set may apply to the object's owner, and another may apply to all other users. The access permissions on an object may cause some methods in this class to fail.
    * Instances of the File class are immutable; that is, once created, the abstract pathname represented by a File object will never change.
    * 
    * An "abstract" representation of a file system entity identified by a pathname. The pathname may be absolute (relative to the root directory
    * of the file system) or relative to the current directory in which the program is running.
    * 
    * The actual file referenced by a CFile may or may not exist. It may also, despite the name CFile, be a directory or other non-regular file.
    * 
    * This class provides limited functionality for getting/setting file permissions, file type, and last modified time.
    * 
    * On Elastos strings are converted to UTF-8 byte sequences when sending filenames to the operating system, and byte sequences returned by
    * the operating system are converted to strings by decoding them as UTF-8 byte sequences.
    * 
    * @implements com::elastos::ISerializable
    * @implements com::elastos::IComparable
    * @implements com::elastos::IFile
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/File.html
    * @todo  http://developer.android.com/reference/java/io/File.html
    */
    class CFile {
      /**
        * @brief Constructs a new file using the specified directory and name.
        *
        * @param dir   the directory where the file is stored.
        * @param name  the file's name.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * NullPointerException | if  name is  null.
        */
        constructor(
            [in] IFile* dir,
            [in] String name);

        /**
         * @brief Constructs a new file using the specified path.
         *
         * @param path     the path to be used for the file.
         */
        constructor(
            [in] String path);

       /**
         * @brief Constructs a new File using the specified directory path and file name, placing a path separator between the two.
         *
         * @param dirPath      the path to the directory where the file is stored.
         * @param name         the file's name.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if  name is  null.
         */
        constructor(
            [in] String dirPath,
            [in] String name);

        /**
         * @brief Constructs a new File using the path of the specified URI.  uri needs to be an absolute and hierarchical Unified Resource Identifier with
         * file scheme and non-empty path component, but with undefined authority, query or fragment components.
         *
         * @param uri   the Unified Resource Identifier that is used to construct this file.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if uri does not comply with the conditions above.
         * 
         * @sa com::elastos::CtoURI
         * @sa com::elastos::CURI
         */
//        constructor(
//            [in] IURI* uri);

        interface IFile;
    }

   /**
    * Utilities for File manipulation.
    * 
    * @implements com::elastos::IFileHelper
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/cd/E18150_01/javadocs/DevelopmentKit/com/stc/connector/framework/util/FileHelper.html
    */
    singleton class CFileHelper {
        interface IFileHelper;
    }

   /**
    * Instances of the file descriptor class serve as an opaque handle to the underlying machine-specific structure representing an open file, 
    * an open socket, or another source or sink of bytes. The main practical use for a file descriptor is to create a FileInputStream or FileOutputStream to contain it.
    * Applications should not create their own file descriptors.
    * 
    * @implements com::elastos::IFileDescriptor
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/FileDescriptor.html
    */
    class CFileDescriptor {
        interface IFileDescriptor;
    }

   /**
    * A FileInputStream obtains input bytes from a file in a file system. What files are available depends on the host environment.
    * FileInputStream is meant for reading streams of raw bytes such as image data. For reading streams of characters, consider using FileReader.
    * 
    * @implements com::elastos::IFileInputStream
    * @implements com::elastos::ICloseable
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/index.html?java/io/FileInputStream.html
    */
    class CFileInputStream {
        /**
         * Constructs a new  FileInputStream based on  file
         *
         * @param file
         *            the file from which this stream reads.
         * @throws FileNotFoundException
         *             if  file does not exist.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             read request.
         */
        constructor(
            [in] IFile* file);
        /**
         * Constructs a new IFileInputStream on the IFile
         *  fd The file must already be open, therefore no
         *  FileNotFoundException will be thrown.
         *
         * @param fd
         *            the FileDescriptor from which this stream reads.
         * @throws NullPointerException
         *             if  fd is  null
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             read request.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Constructs a new  FileInputStream on the file named
         *  fileName. The path of  fileName may be absolute or
         * relative to the system property  "user.dir".
         *
         * @param fileName
         *            the path and name of the file from which this stream reads.
         * @throws FileNotFoundException
         *             if there is no file named  fileName.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             read request.
         */
        constructor(
            [in] String fileName);

        interface IFileInputStream;
    }


   /**
    * A file output stream is an output stream for writing data to a File or to a FileDescriptor. Whether or not a file is available or may
    * be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one
    * IFileOutputStream (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.
    * IFileOutputStream is meant for writing streams of raw bytes such as image data. For writing streams of characters, consider using FileWriter.
    * 
    * @implements com::elastos::IFileOutputStream
    * @implements com::elastos::ICloseable
    *
    * @sa com::elastos::IFile
    * @sa com::elastos::IFileDescriptor
    * @sa com::elastos::IFileInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/1.4.2/docs/api/java/io/FileOutputStream.html
    */
    class CFileOutputStream {
        /**
         * Constructs a new FileOutputStream on the File  file. If the file
         * exists, it is overwritten.
         *
         * @param file
         *            the file to which this stream writes.
         * @throws FileNotFoundException
         *             if  file cannot be opened for writing.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a new FileOutputStream on the File  file. The
         * parameter  append} determines whether or not the file is opened and
         * appended to or just opened and overwritten.
         *
         * @param file
         *            the file to which this stream writes.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws FileNotFoundException
         *             if the  file cannot be opened for writing.
         * @throws SecurityException
         *             if a  SecurityManager is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         * @see java.lang.SecurityManager#checkWrite(String)
         */
        constructor(
            [in] IFile* file,
            [in] Boolean append);

        /**
         * Constructs a new FileOutputStream on the FileDescriptor fd The
         * file must already be open, therefore no FileNotFoundException}
         * will be thrown.
         *
         * @param fd
         *            the FileDescriptor to which this stream writes.
         * @throws NullPointerException
         *             if fd} is null
         * @throws SecurityException
         *             if a SecurityManager} is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Constructs a new FileOutputStream on the file named filename If
         * the file exists, it is overwritten. The filename} may be absolute
         * or relative to the system property "user.dir"
         *
         * @param filename
         *            the name of the file to which this stream writes.
         * @throws FileNotFoundException
         *             if the file cannot be opened for writing.
         * @throws SecurityException
         *             if a SecurityManager} is installed and it denies the
         *             write request.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a new FileOutputStream on the file named filename
         * The parameter append} determines whether or not the file is opened
         * and appended to or just opened and overwritten. The filename} may
         * be absolute or relative to the system property "user.dir"
         *
         * @param filename
         *            the name of the file to which this stream writes.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws FileNotFoundException
         *             if the file cannot be opened for writing.
         * @throws SecurityException
         *             if a SecurityManager} is installed and it denies the
         *             write request.
         */
        constructor(
            [in] String fileName,
            [in] Boolean append);

        interface IFileOutputStream;
    }

   /**
    * A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way.
    * An application uses a data output stream to write data that can later be read by a data input stream.
    * IDataInputStream is not necessarily safe for multithreaded access. Thread safety is optional and is the responsibility of users of methods in this class.
    * 
    * @implements com::elastos::IDataInput
    * @implements com::elastos::IDataInputStream
    *
    * @sa com::elastos::IDataOutputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/DataInputStream.html
    */
    class CDataInputStream {
        /**
         * Constructs a new DataInputStream on the InputStream in All
         * reads are then filtered through this stream. Note that data read by this
         * stream is not in a human readable format and was most likely created by a
         * DataOutputStream.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * DataInputStream All operations on such a stream will fail.
         *
         * @param in
         *            the source InputStream the filter reads from.
         * @see DataOutputStream
         * @see RandomAccessFile
         */
        constructor(
            [in] IInputStream* is);

        interface IDataInput;
        interface IDataInputStream;
    }

   /**
    * A data output stream lets an application write primitive Java data types to an output stream in a portable way.
    * An application can then use a data input stream to read the data back in.
    * 
    * @implements com::elastos::IDataOutput
    * @implements com::elastos::IDataOutputStream
    *
    * @sa com::elastos::IDataInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/DataOutputStream.html
    */
    class CDataOutputStream {
        /**
         * Constructs a new DataOutputStream on the OutputStream
         * out Note that data written by this stream is not in a human
         * readable form but can be reconstructed by using a {@link DataInputStream}
         * on the resulting output.
         *
         * @param out
         *            the target stream for writing.
         */
        constructor(
            [in] IOutputStream* os);

        interface IDataOutput;
        interface IDataOutputStream;
    }

    [deprecated]
    class CCharArrayReader {
        /**
         * Constructs a CharArrayReader on the char array buf The size of
         * the reader is set to the length of the buffer and the object to to read
         * from is set to buf
         *
         * @param buf
         *            the char array from which to read.
         */
        constructor(
            [in] ArrayOf<Char8> buf);

        /**
         * Constructs a CharArrayReader on the char array buf The size of
         * the reader is set to length} and the start position from which to
         * read the buffer is set to offset
         *
         * @param buf
         *            the char array from which to read.
         * @param offset
         *            the index of the first character in buf} to read.
         * @param length
         *            the number of characters that can be read from buf
         * @throws IllegalArgumentException
         *             if offset < 0} or length < 0 or if
         *             offset} is greater than the size of buf} .
         */
        constructor(
            [in] ArrayOf<Char8> buf,
            [in] Int32 offset,
            [in] Int32 length);

        interface ICharArrayReader;
    }

   /**
    * This class implements a character buffer that can be used as an Writer. The buffer automatically grows when data is written to the stream.
    * The data can be retrieved using toCharArray() and toString().
    * Note: Invoking close() on this class has no effect, and methods of this class can be called after the stream has closed without generating an IOException.

    * @implements com::elastos::ICharArrayWriter
    * @implements com::elastos::ICloseable
    * @implements com::elastos::IFlushable
    * @implements com::elastos::IAppendable
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/CharArrayWriter.html
    */
    class CCharArrayWriter {
        /**
         * Constructs a new CharArrayWriter} which has a buffer allocated
         * with the default size of 32 characters. This buffer is also used as the
         * lock} to synchronize access to this writer.
         */
        constructor();
        /**
         * Constructs a new CharArrayWriter} which has a buffer allocated
         * with the size of initialSize} characters. The buffer is also used
         * as the lock} to synchronize access to this writer.
         *
         * @param initialSize
         *            the initial size of this CharArrayWriters buffer.
         * @throws IllegalArgumentException
         *             if initialSize < 0
         */
        constructor(
            [in] Int32 initialSize);

        interface ICharArrayWriter;
    }

   /**
    * Wraps an existing Reader and buffers the input. Expensive interaction with the underlying reader is minimized, since most (smaller)
    * requests can be satisfied by accessing the buffer alone. The drawback is that some extra space is required to hold the buffer
    * and that copying takes place when filling that buffer, but this is usually outweighed by the performance benefits.
    *
    * A typical application pattern for the class looks like this:
    * @code
    * BufferedReader buf = new BufferedReader(new FileReader("file.car"));
    * @endcode
    *
    * @implements com::elastos::IBufferedReader
    *
    * @sa com::elastos::CBufferedWriter
    *
    * <strong>Direct Known Subclasses:</strong>
    * - @ref com::elastos::CLineNumberReader
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedReader.html
    */
    class CBufferedReader {
        /**
        * Constructs a new BufferedReader, providing in with a buffer of 8192 characters.
        *
        * @param rin the IReader the buffer reads from.
        */
        constructor(
            [in] IReader* rin);

        /**
        * Constructs a new BufferedReader providing in} with size} characters of buffer.
        *
        * @param rin the IReader the buffer reads from.
        * @param size the size of buffer in characters.
        * @return ECode = NOERROR(0) if success, elas as follows:
        * Value | Meaning |
        * :-|:------------|
        * IllegalArgumentException | if size <= 0
        */
        constructor(
            [in] IReader* rin,
            [in] Int32 size);

        interface IBufferedReader;
    }

   /**
    * Wraps an existing Writer and buffers the output. Expensive interaction with the underlying reader is minimized,
    * since most (smaller) requests can be satisfied by accessing the buffer alone. The drawback is that some extra space is required
    * to hold the buffer and that copying takes place when filling that buffer, but this is usually outweighed by the performance benefits.
    *
    * A typical application pattern for the class looks like this:
    * @code
    * BufferedWriter buf = new BufferedWriter(new FileWriter("file.car"));
    * @endcode
    *
    * @implements com::elastos::IBufferedWriter
    *
    * @sa com::elastos::CBufferedReader
    *
    * <strong>Direct Known Subclasses:</strong>
    * - @ref com::elastos::CLineNumberWriter
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/BufferedWriter.html
    */
    class CBufferedWriter {
        /**
         * Constructs a new BufferedWriter providing out} with a buffer of 8192 bytes.
         *
         * @param wout the IWriter the buffer writes to.
         */
        constructor(
            [in] IWriter* wout);

        /**
         * Constructs a new BufferedWriter providing out} with size} bytes
         * of buffer.
         *
         * @param out the IWriter the buffer writes to.
         * @param size the size of buffer in bytes.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if size <= 0
         */
        constructor(
            [in] IWriter* wout,
            [in] Int32 size);

        interface IBufferedWriter;
    }

   /**
    * A specialized InputStream that reads bytes from a String in a sequential manner.
    *
    * @implements com::elastos::IStringBufferInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/StringBufferInputStream.html
    */
    class CStringBufferInputStream {
        /**
         * Construct a new StringBufferInputStream with str as source. The size of the stream is set to the length of the string.
         *
         * @param str  the source string for this stream.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if str is null
         *
         * @todo Fields
         *   -  String buffer The source string containing the data to read.
         *   -  int count The total number of characters in the source string.
         *   -  int pos The current position within the source string.
         */
        constructor(
            [in] String str);

        interface IStringBufferInputStream;
    }

   /**
    * Wraps an existing InputStream and counts the line terminators encountered while reading the data. Line numbering starts at 0.
    * Recognized line terminator sequences are '\r', '\n' and "\r\n". When using read, line terminator sequences are always translated into '\n'.
    *
    * @implements com::elastos::ILineNumberInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/7/docs/api/java/io/LineNumberInputStream.html
    *        java.io.LineNumberInputStream
    */
    class CLineNumberInputStream {
        /**
         * Constructs a new LineNumberInputStream on the IInputStream
         * in Line numbers are counted for all data read from this stream.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * LineNumberInputStream All operations on such a stream will fail.
         *
         * @param in   The non-null input stream to count line numbers.
         */
        constructor(
            [in] IInputStream* is);

        interface ILineNumberInputStream;
    }

   /**
    * Wraps an existing Reader and counts the line terminators encountered while reading the data.
    * The line number starts at 0 and is incremented any time '\r', '\n' or "\r\n" is read. 
    * The class has an internal buffer for its data. The size of the buffer defaults to 8 KB.
    *
    * @implements com::elastos::ILineNumberReader
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/LineNumberReader.html
    *    	 java.io.LineNumberReader
    */
    class CLineNumberReader {
        /**
         * Constructs a new LineNumberReader on the Reader in The internal
         * buffer gets the default size (8 KB).
         *
         * @param ir   the IReader that is buffered.
         */
        constructor(
            [in] IReader* ir);

        /**
         * Constructs a new LineNumberReader on the Reader in The size of
         * the internal buffer is specified by the parameter size
         *
         * @param ir    the Reader that is buffered.
         * @param size  the size of the buffer to allocate.
         * @throws IllegalArgumentException
         *             if size <= 0
         */
        constructor(
            [in] IReader* ir,
            [in] Int32 size);

        interface ILineNumberReader;
    }

   /**
    * Wraps an existing InputStream and adds functionality to "push back" bytes that have been read, so that they can be read again. 
    * Parsers may find this useful. The number of bytes which may be pushed back can be specified during construction. 
    * If the buffer of pushed back bytes is empty, bytes are read from the underlying input stream.
    *
    * @implements com::elastos::IPushbackInputStream
    *
    * @since Elastos 1.0
    * @todo  http://docs.oracle.com/javase/6/docs/api/java/io/PushbackInputStream.html
    *    	 java.io.PushbackInputStream
    */
    class CPushbackInputStream {
        /**
         * Constructs a new PushbackInputStream} with the specified input
         * stream as source. The size of the pushback buffer is set to the default
         * value of 1 byte.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * PushbackInputStream All read operations on such a stream will
         * fail.
         *
         * @param in
         *            the source input stream.
         */
        constructor(
            [in] IInputStream* is);
        /**
         * Constructs a new PushbackInputStream} with in} as source
         * input stream. The size of the pushback buffer is set to size
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * PushbackInputStream All read operations on such a stream will
         * fail.
         *
         * @param is    the source input stream.
         * @param size  the size of the pushback buffer.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if size is negative.
         */
        constructor(
            [in] IInputStream* is,
            [in] Int32 size);

        interface IPushbackInputStream;
    }

   /**
    * Wraps an existing Reader and adds functionality to "push back" characters that have been read, so that they can be read again.
    * Parsers may find this useful. The number of characters which may be pushed back can be specified during construction. 
    * If the buffer of pushed back bytes is empty, characters are read from the underlying reader.
    *
    * @implements com::elastos::IPushbackReader
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.PushbackReader
    */
    class CPushbackReader {
        /**
         * Constructs a new PushbackReader with the specified reader as
         * source. The size of the pushback buffer is set to the default value of 1
         * character.
         *
         * @param ir
         *            the source reader.
         */
        constructor(
            [in] IReader* ir);
        /**
         * Constructs a new PushbackReader with in} as source reader.
         * The size of the pushback buffer is set to size
         *
         * @param ir     the source reader.
         * @param size   the size of the pushback buffer.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if size is negative.
         */
        constructor(
            [in] IReader* ir,
            [in] Int32 size);

        interface IPushbackReader;
    }

   /**
    * Legacy security code; do not use.
    *
    * @implements com::elastos::IFilePermission
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.FilePermission
    */
    class CFilePermission {
        /**
         * Constructs a new FilePermission with the path and actions specified.
         *
         * @param path
         *            the pathname of the file or directory to apply the actions to.
         * @param actions
         *            the actions for the path May be any combination of
         *            "read", "write", "execute" and "delete".
         * @throws IllegalArgumentException
         *             if actions} is null} or an empty string, or if
         *             it contains a string other than "read", "write", "execute"
         *             and "delete".
         * @throws NullPointerException
         *             if path} is null
         */
        constructor(
            [in] String path,
            [in] String actions);

        interface IFilePermission;
    }

   /**
    * 
    *
    * @implements com::elastos::IFilePermissionCollection
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.FilePermissionCollection
    */
    class CFilePermissionCollection {
        interface IFilePermissionCollection;
    }

   /**
    * Concatenates two or more existing InputStreams. Reads are taken from the first stream until it ends, 
    * then the next stream is used, until the last stream returns end of file.
    *
    * @implements com::elastos::IInputStream
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.InputStream
    */
    class CSequenceInputStream {
        /**
         * Constructs a new SequenceInputStream using the two streams
         * s1 and s2 as the sequence of streams to read from.
         *
         * @param s1  the first stream to get bytes from.
         * @param s2  the second stream to get bytes from.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if s1 is null
         */
        constructor(
            [in] IInputStream *s1,
            [in] IInputStream *s2);

        /**
         * Constructs a new SequenceInputStream using the elements returned from
         * Enumeration e as the stream sequence. The instances returned by
         * e.nextElement must be of type InputStream
         *
         * @param e   the enumeration of InputStreams to get bytes from.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if any of the elements in e is null
         */
        constructor(
            [in] IObjectEnumerator* e);

        interface IInputStream;
    }

   /**
    * 
    *
    * @implements com::elastos::ICharsetHelper
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.
    */
    singleton class CCharsetHelper {
        interface ICharsetHelper;
    }

   /**
    * 
    *
    * @implements com::elastos::ICharsets
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.
    */
    singleton class CCharsets {
        interface ICharsets;
    }

   /**
    * Used to indicate the result of encoding/decoding. There are four types of results:
    * -# UNDERFLOW indicates that all input has been processed but more input is required. It is represented by the unique object CoderResult.UNDERFLOW.
    * -# OVERFLOW indicates an insufficient output buffer size. It is represented by the unique object CoderResult.OVERFLOW.
    * -# A malformed-input error indicates that an unrecognizable sequence of input units has been encountered. Get an instance of this type of result by calling CoderResult.malformedForLength(int) with the length of the malformed-input.
    * -# An unmappable-character error indicates that a sequence of input units can not be mapped to the output charset. Get an instance of this type of result by calling CoderResult.unmappableForLength(int) with the input sequence size indicating the identity of the unmappable character.
    *
    * @implements com::elastos::ICoderResult
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.nio.charset.CoderResult
    */
    class CCoderResult {
        interface ICoderResult;
    }

   /**
    * 
    *
    * @implements com::elastos::ICoderResultHelper
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.
    */
    singleton class CCoderResultHelper {
        interface ICoderResultHelper;
    }

   /**
    * Used to indicate what kind of actions to take in case of encoding/decoding errors. Currently three actions are defined: IGNORE, REPLACE and REPORT.
    *
    * @implements com::elastos::ICodingErrorAction
    *
    * @since Elastos 1.0
    * @todo  
    *    	 	java.nio.charset.CodingErrorAction
    */
    class CCodingErrorAction {
        interface ICodingErrorAction;
    }

   /**
    * 
    *
    * @implements com::elastos::IModifiedUtf8
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.
    */
    singleton class CModifiedUtf8 {
        interface IModifiedUtf8;
    }

   /**
    * 
    *
    * @implements com::elastos::INativeConverter
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.
    */
    singleton class CNativeConverter {
        interface INativeConverter;
    }

   /**
    * A charset is a named mapping between Unicode characters and byte sequences. Every Charset can decode, converting a byte sequence into a sequence of characters, and some can also encode, converting a sequence of characters into a byte sequence. Use the method canEncode() to find out whether a charset supports both.
    * 
    * <strong>Characters</strong>
    * 
    * In the context of this class, character always refers to a Java character: a Unicode code point in the range U+0000 to U+FFFF. (Java represents supplementary characters using surrogates.) Not all byte sequences will represent a character, and not all characters can necessarily be represented by a given charset. The method contains(Charset) can be used to determine whether every character representable by one charset can also be represented by another (meaning that a lossless transformation is possible from the contained to the container).
    * 
    * <strong>Encodings</strong>
    * 
    * There are many possible ways to represent Unicode characters as byte sequences. See <a href="http://www.unicode.org/reports/tr17/">UTR#17: Unicode Character Encoding Model</a> for detailed discussion.
    * 
    * The most important mappings capable of representing every character are the Unicode Transformation Format (UTF) charsets. Of those, UTF-8 and the UTF-16 family are the most common. UTF-8 (described in <a href="http://www.ietf.org/rfc/rfc3629.txt">RFC 3629</a>) encodes a character using 1 to 4 bytes. UTF-16 uses exactly 2 bytes per character (potentially wasting space, but allowing efficient random access into BMP text), and UTF-32 uses exactly 4 bytes per character (trading off even more space for efficient random access into text that includes supplementary characters).
    * 
    * UTF-16 and UTF-32 encode characters directly, using their code point as a two- or four-byte integer. This means that any given UTF-16 or UTF-32 byte sequence is either big- or little-endian. To assist decoders, Unicode includes a special byte order mark (BOM) character U+FEFF used to determine the endianness of a sequence. The corresponding byte-swapped code point U+FFFE is guaranteed never to be assigned. If a UTF-16 decoder sees 0xfe, 0xff, for example, it knows it's reading a big-endian byte sequence, while 0xff, 0xfe, would indicate a little-endian byte sequence.
    * 
    * UTF-8 can contain a BOM, but since the UTF-8 encoding of a character always uses the same byte sequence, there is no information about endianness to convey. Seeing the bytes corresponding to the UTF-8 encoding of U+FEFF (0xef, 0xbb, 0xbf) would only serve to suggest that you're reading UTF-8. Note that BOMs are decoded as the U+FEFF character, and will appear in the output character sequence. This means that a disadvantage to including a BOM in UTF-8 is that most applications that use UTF-8 do not expect to see a BOM. (This is also a reason to prefer UTF-8: it's one less complication to worry about.)
    * 
    * Because a BOM indicates how the data that follows should be interpreted, a BOM should occur as the first character in a character sequence.
    * 
    * See the <a href="http://unicode.org/faq/utf_bom.html#BOM">Byte Order Mark (BOM) FAQ</a> for more about dealing with BOMs.
    * 
    * <strong>Endianness and BOM behavior</strong>
    * 
    * The following tables show the endianness and BOM behavior of the UTF-16 variants.
    * 
    * This table shows what the encoder writes. "BE" means that the byte sequence is big-endian, "LE" means little-endian. "BE BOM" means a big-endian BOM (that is, 0xfe, 0xff).
    * Charset | Encoder writes |
    * :-|:------------|
    * UTF-16BE | BE, no BOM
    * UTF-16LE | LE, no BOM
    * UTF-16 | BE, with BE BOM
    *
    * The next table shows how each variant's decoder behaves when reading a byte sequence. The exact meaning of "failure" in the table is dependent on the CodingErrorAction supplied to malformedInputAction(), so "BE, failure" means "the byte sequence is treated as big-endian, and a little-endian BOM triggers the malformedInputAction".
    * The phrase "includes BOM" means that the output includes the U+FEFF byte order mark character.
    * Charset | BE BOM | LE BOM | No BOM
    * :-------|:-------|:-------|:-------|
    * UTF-16BE | BE, includes BOM | BE, failure | BE
    * UTF-16LE | LE, failure | LE, includes BOM |	LE
    * UTF-16 | BE | LE | BE
    *
    * <strong>Charset names</strong>
    *
    * A charset has a canonical name, returned by name(). Most charsets will also have one or more aliases, returned by aliases(). A charset can be looked up by canonical name or any of its aliases using forName(String).
    *
    * <strong>Guaranteed-available charsets</strong>
    *
    * The following charsets are available on every Java implementation:
    * - ISO-8859-1
    * - US-ASCII
    * - UTF-16
    * - UTF-16BE
    * - UTF-16LE
    * - UTF-8
    *
    * All of these charsets support both decoding and encoding. The charsets whose names begin "UTF" can represent all characters, as mentioned above. The "ISO-8859-1" and "US-ASCII" charsets can only represent small subsets of these characters. Except when required to do otherwise for compatibility, new code should use one of the UTF charsets listed above. The platform's default charset is UTF-8. (This is in contrast to some older implementations, where the default charset depended on the user's locale.)
    *
    * Most implementations will support hundreds of charsets. Use availableCharsets() or isSupported(String) to see what's available. If you intend to use the charset if it's available, just call forName(String) and catch the exceptions it throws if the charset isn't available.
    *
    * Additional charsets can be made available by configuring one or more charset providers through provider configuration files. Such files are always named as "java.nio.charset.spi.CharsetProvider" and located in the "META-INF/services" directory of one or more classpaths. The files should be encoded in "UTF-8". Each line of their content specifies the class name of a charset provider which extends CharsetProvider. A line should end with '\\r', '\\n' or '\\r\\n'. 
    * Leading and trailing whitespace is trimmed. Blank lines, and lines (after trimming) starting with "#" which are regarded as comments, are both ignored. Duplicates of names already found are also ignored. Both the configuration files and the provider classes will be loaded using the thread context class loader.
    *
    * Although class is thread-safe, the @ref com::elastos::CCharsetDecoder and @ref com::elastos::CCharsetEncoder instances it returns are inherently stateful.
    * 
    * @implements com::elastos::ICharset
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.nio.charset.Charset
    */
    class CCharsetICU {
        constructor(
            [in] String canonicalName,
            [in] String icuCanonName,
            [in] ArrayOf<String> aliases);

        interface ICharset;
    }

   /**
    * Transforms a sequence of 16-bit Java characters to a byte sequence in some encoding.
    * The input character sequence is a CharBuffer and the output byte sequence is a ByteBuffer.
    * 
    * Use encode(CharBuffer) to encode an entire CharBuffer to a new ByteBuffer, or encode(CharBuffer, ByteBuffer, boolean) for more control. 
    * When using the latter method, the entire operation proceeds as follows:
    * -# Invoke reset() to reset the encoder if this instance has been used before.
    * -# Invoke encode with the endOfInput parameter set to false until additional input is not needed (as signaled by the return value). The input buffer must be filled and the output buffer must be flushed between invocations.
    * The encode method will convert as many characters as possible, and the process won't stop until the input buffer has been exhausted, the output buffer has been filled, or an error has occurred. A CoderResult instance will be returned to indicate the current state. The caller should fill the input buffer, flush the output buffer, or recovering from an error and try again, accordingly.
    * -# Invoke encode for the last time with endOfInput set to true.
    * -# Invoke flush(ByteBuffer) to flush remaining output.
    *
    * There are two classes of encoding error: malformed input signifies that the input character sequence is not legal, while unmappable character signifies that the input is legal but cannot be mapped to a byte sequence (because the charset cannot represent the character, for example).
    * 
    * Errors can be handled in three ways. The default is to report the error to the caller. The alternatives are to ignore the error or replace the problematic input with the byte sequence returned by replacement(). The disposition for each of the two kinds of error can be set independently using the onMalformedInput(CodingErrorAction) and onUnmappableCharacter(CodingErrorAction) methods.
    * 
    * The default replacement bytes depend on the charset but can be overridden using the replaceWith(byte[]) method.
    * 
    * This class is abstract and encapsulates many common operations of the encoding process for all charsets. Encoders for a specific charset should extend this class and need only to implement the encodeLoop method for basic encoding. If a subclass maintains internal state, it should also override the implFlush and implReset methods.
    * 
    * This class is not thread-safe.
    *
    * @implements com::elastos::ICharsetEncoder
    * @sa com::elastos::CCharset
    * @sa com::elastos::CCharsetDecoder
    *
    * @since Elastos 1.0
    * @todo  
    *    	 	java.nio.charset.CharsetEncoder
    */
    class CCharsetEncoderICU {
        interface ICharsetEncoder;
    }

   /**
    * A class for turning a byte stream into a character stream. Data read from the source input stream is converted into characters 
    * by either a default or a provided character converter. The default encoding is taken from the "file.encoding" system property. 
    * InputStreamReader contains a buffer of bytes read from the source stream and converts these into characters as needed. The buffer size is 8K.
    *
    * @implements com::elastos::IInputStreamReader
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.InputStreamReader
    */
    class CInputStreamReader {
        /**
         * Constructs a new InputStreamReader} on the {@link InputStream}
         * in This constructor sets the character converter to the encoding
         * specified in the "file.encoding" property and falls back to ISO 8859_1
         * (ISO-Latin-1) if the property doesn't exist.
         *
         * @param is   the input stream from which to read characters.
         */
        constructor(
            [in] IInputStream* is);

        /**
         * Constructs a new InputStreamReader on the InputStream in The
         * character converter that is used to decode bytes into characters is
         * identified by name by enc If the encoding cannot be found, an
         * UnsupportedEncodingException error is thrown.
         *
         * @param is   the InputStream from which to read characters.
         * @param enc  identifies the character converter to use.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if enc is null
         * UnsupportedEncodingException | if the encoding specified by enc cannot be found.
         */
        constructor(
            [in] IInputStream* is,
            [in] String enc);

//        /**
//         * Constructs a new InputStreamReader on the InputStream in} and
//         * CharsetDecoder dec
//         *
//         * @param in
//         *            the source InputStream from which to read characters.
//         * @param dec
//         *            the CharsetDecoder used by the character conversion.
//         */
//        constructor(
//            [in] IInputStream* in,
//            [in] CharsetDecoder dec);
//
        /**
         * Constructs a new InputStreamReader on the InputStream in} and
         * Charset charset
         *
         * @param in
         *            the source InputStream from which to read characters.
         * @param charset
         *            the Charset that defines the character converter
         */
        constructor(
            [in] IInputStream* ins,
            [in] ICharset* charset);


        interface IInputStreamReader;
    }

   /**
    * 
    *
    * @implements com::elastos::IOutputStreamWriter
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.OutputStreamWriter
    */
    class COutputStreamWriter {
        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to. The default character encoding
         * is used.
         *
         * @param out
         *            the non-null target stream to write converted bytes to.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to and enc} as the character
         * encoding. If the encoding cannot be found, an
         * UnsupportedEncodingException error is thrown.
         *
         * @param out   the target stream to write converted bytes to.
         * @param enc   the string describing the desired character encoding.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if enc is null
         * UnsupportedEncodingException | if the encoding specified by enc cannot be found.
         */
        constructor(
            [in] IOutputStream* os,
            [in] String enc);

        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to and cs} as the character
         * encoding.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param cs
         *            the Charset} that specifies the character encoding.
         */
//        constructor(
//            [in] IOutputStream* os,
//            [in] Charset cs);

        /**
         * Constructs a new OutputStreamWriter using out} as the target
         * stream to write converted characters to and enc} as the character
         * encoder.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param enc
         *            the character encoder used for character conversion.
         */
//        constructor(
//            [in] IOutputStream* os,
//            [in] CharsetEncoder enc);

        interface IOutputStreamWriter;
    }

   /**
    * A specialized Reader that reads from a file in the file system. All read requests made by calling methods in this class are directly
    * forwarded to the equivalent function of the underlying operating system. Since this may induce some performance penalty, 
    * in particular if many small read requests are made, a FileReader is often wrapped by a BufferedReader.
    *
    * @implements com::elastos::IInputStreamReader
    * @sa com::elastos::CBufferedReader
    * @sa com::elastos::CFileWriter
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.InputStreamReader
    */
    class CFileReader {
        /**
         * Constructs a new FileReader on the given file
         *
         * @param file
         *            a File to be opened for reading characters from.
         * @throws FileNotFoundException
         *             if file} does not exist.
         */
        constructor(
            [in] IFile* file);

        /**
         * Construct a new FileReader on the given FileDescriptor fd Since
         * a previously opened FileDescriptor is passed as an argument, no
         * FileNotFoundException can be thrown.
         *
         * @param fd
         *            the previously opened file descriptor.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Construct a new FileReader on the given file named filename
         *
         * @param filename   an absolute or relative path specifying the file to open.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException | if there is no file named filename
         */
        constructor(
            [in] String filename);

        interface IInputStreamReader;
    }

   /**
    * A specialized Writer that writes to a file in the file system. All write requests made by calling methods in this class are directly forwarded
    * to the equivalent function of the underlying operating system. Since this may induce some performance penalty, 
    * in particular if many small write requests are made, a FileWriter is often wrapped by a BufferedWriter.
    *
    * @implements com::elastos::IOutputStreamWriter
    * @sa com::elastos::CBufferedWriter
    * @sa com::elastos::CFileReader
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.OutputStreamWriter
    */
    class CFileWriter {
        /**
         * Creates a FileWriter using the File file
         *
         * @param file
         *            the non-null File to write bytes to.
         * @throws IOException
         *             if file} cannot be opened for writing.
         */
        constructor(
            [in] IFile* file);

        /**
         * Creates a FileWriter using the File file The parameter
         * append} determines whether or not the file is opened and appended
         * to or just opened and overwritten.
         *
         * @param file
         *            the non-null File to write bytes to.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws IOException
         *             if the file} cannot be opened for writing.
         */
        constructor(
            [in] IFile* file,
            [in] Boolean append);

        /**
         * Creates a FileWriter using the existing FileDescriptor fd
         *
         * @param fd
         *            the non-null FileDescriptor to write bytes to.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Creates a FileWriter using the platform dependent filename
         *
         * @param filename
         *            the non-null name of the file to write bytes to.
         * @throws IOException
         *             if the file cannot be opened for writing.
         */
        constructor(
            [in] String filename);

        /**
         * Creates a FileWriter using the platform dependent filename The
         * parameter append} determines whether or not the file is opened and
         * appended to or just opened and overwritten.
         *
         * @param filename
         *            the non-null name of the file to write bytes to.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws IOException
         *             if the file} cannot be opened for writing.
         */
        constructor(
            [in] String filename,
            [in] Boolean append);

        interface IOutputStreamWriter;
    }

   /**
    * A specialized Reader that reads characters from a String in a sequential manner.
    *
    * @implements com::elastos::IStringReader
    * @sa com::elastos::CStringWriter
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.StringReader
    */
    class CStringReader {
        /**
         * Construct a new StringReader} with str} as source. The size
         * of the reader is set to the length()} of the string and the Object
         * to synchronize access through is set to str
         *
         * @param str
         *            the source string for this reader.
         */
        constructor(
            [in] String str);

        interface IStringReader;
    }

   /**
    * A specialized Writer that writes characters to a StringBuffer in a sequential manner, appending them in the process. 
    * The result can later be queried using the StringWriter(int) or toString() methods.
    *
    * @implements com::elastos::IStringWriter
    * @sa com::elastos::CStringReader
    * 
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.StringWriter
    */
    class CStringWriter {
        /**
         * Constructs a new StringWriter} which has a {@link StringBuffer}
         * allocated with the default size of 16 characters. The {@code
         * StringBuffer} is also the lock} used to synchronize access to this
         * writer.
         */
        constructor();

        /**
         * Constructs a new StringWriter} which has a {@link StringBuffer}
         * allocated with a size of initialSize} characters. The {@code
         * StringBuffer} is also the lock} used to synchronize access to this
         * writer.
         *
         * @param initialSize
         *            the intial size of the target string buffer.
         */
        constructor(
            [in] Int32 initialSize);

        interface IStringWriter;
    }

   /**
    * 
    *
    * @implements com::elastos::IByteBufferHelper
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.ByteBufferHelper
    */
    singleton class CByteBufferHelper {
        interface IByteBufferHelper;
    }
    
   /**
    * 
    *
    * @implements com::elastos::ICharBufferHelper
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.CharBufferHelper
    */
    singleton class CCharBufferHelper {
        constructor();
        
        interface ICharBufferHelper;
    }
	
   /**
    * This class provides several utilities to get I/O streams from channels.
    *
    * @implements com::elastos::IChannels
    *
    * @since Elastos 1.0
    * @todo  
    *    	 	java.nio.channels.Channels
    */
	singleton class CChannels {
		constructor();
		
		interface IChannels;
	}

   /**
    * Wraps either an existing OutputStream or an existing Writer and provides convenience methods for printing common data types in a human readable format. 
    * No ECode is thrown by this class. Instead, callers should use checkError() to see if a problem has occurred in this writer.
    *
    * @implements com::elastos::IPrintWriter
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.PrintWriter
    */
    class CPrintWriter {
        /**
         * Constructs a new PrintWriter} with out} as its target
         * stream. By default, the new print writer does not automatically flush its
         * contents to the target stream when a newline is encountered.
         *
         * @param outs    the target output stream.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if outs is null
         */
        constructor(
            [in] IOutputStream* outs);

        /**
         * Constructs a new PrintWriter} with out} as its target
         * stream. The parameter autoflush} determines if the print writer
         * automatically flushes its contents to the target stream when a newline is
         * encountered.
         *
         * @param outs        the target output stream.
         * @param autoflush   indicates whether contents are flushed upon encountering a newline sequence.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if outs is null
         */
        constructor(
            [in] IOutputStream* outs, 
            [in] Boolean autoflush);

        /**
         * Constructs a new PrintWriter} with wr} as its target
         * writer. By default, the new print writer does not automatically flush its
         * contents to the target writer when a newline is encountered.
         *
         * @param wr
         *            the target writer.
         * @throws NullPointerException
         *             if wr} is null
         */
        constructor(
            [in] IWriter* wr);

        /**
         * Constructs a new PrintWriter} with out} as its target
         * writer. The parameter autoflush} determines if the print writer
         * automatically flushes its contents to the target writer when a newline is
         * encountered.
         *
         * @param wr
         *            the target writer.
         * @param autoflush
         *            indicates whether to flush contents upon encountering a
         *            newline sequence.
         * @throws NullPointerException
         *             if out} is null
         */
        constructor(
            [in] IWriter* wr, 
            [in] Boolean autoflush);

        /**
         * Constructs a new PrintWriter} with file} as its target. The
         * virtual machine's default character set is used for character encoding.
         * The print writer does not automatically flush its contents to the target
         * file when a newline is encountered. The output to the file is buffered.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a new PrintWriter} with file} as its target. The
         * character set named csn} is used for character encoding.
         * The print writer does not automatically flush its contents to the target
         * file when a newline is encountered. The output to the file is buffered.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] IFile* file, 
            [in] String csn);
        /**
         * Constructs a new PrintWriter} with the file identified by {@code
         * fileName} as its target. The virtual machine's default character set is
         * used for character encoding. The print writer does not automatically
         * flush its contents to the target file when a newline is encountered. The
         * output to the file is buffered.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a new PrintWriter} with the file identified by {@code
         * fileName} as its target. The character set named csn} is used for
         * character encoding. The print writer does not automatically flush its
         * contents to the target file when a newline is encountered. The output to
         * the file is buffered.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] String fileName, 
            [in] String csn);

        interface IPrintWriter;
    }

   /**
    * Wraps an existing OutputStream and provides convenience methods for writing common data types in a human readable format. 
    * This is not to be confused with DataOutputStream which is used for encoding common data types so that they can be read back in. 
    * No ECode is thrown by this class. Instead, callers should use checkError() to see if a problem has occurred in this stream.
    *
    * @implements com::elastos::IPrintStream
    *
    * @since Elastos 1.0
    * @todo  
    *    	 java.io.PrintStream
    */
    class CPrintStream {
        /**
         * Constructs a new PrintStream} with out} as its target
         * stream. By default, the new print stream does not automatically flush its
         * contents to the target stream when a newline is encountered.
         *
         * @param outs   the target output stream.
         * @return ECode = NOERROR(0) if success, elas as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if outs is null
         */
        constructor(
            [in] IOutputStream* outs);

        /**
         * Constructs a new PrintStream} with out} as its target
         * stream. The parameter autoflush} determines if the print stream
         * automatically flushes its contents to the target stream when a newline is
         * encountered.
         *
         * @param out
         *            the target output stream.
         * @param autoflush
         *            indicates whether to flush contents upon encountering a
         *            newline sequence.
         * @throws NullPointerException
         *             if out} is null
         */
        constructor(
            [in] IOutputStream* outs, 
            [in] Boolean autoflush);

        /**
         * Constructs a new PrintStream} with out} as its target
         * stream and using the character encoding enc} while writing. The
         * parameter autoflush} determines if the print stream automatically
         * flushes its contents to the target stream when a newline is encountered.
         *
         * @param out
         *            the target output stream.
         * @param autoflush
         *            indicates whether or not to flush contents upon encountering a
         *            newline sequence.
         * @param enc
         *            the non-null string describing the desired character encoding.
         * @throws NullPointerException
         *             if out} or enc} are null
         * @throws UnsupportedEncodingException
         *             if the encoding specified by enc} is not supported.
         */
        constructor(
            [in] IOutputStream* outs, 
            [in] Boolean autoflush, 
            [in] String enc);

        /**
         * Constructs a new PrintStream} with file} as its target. The
         * virtual machine's default character set is used for character encoding.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a new PrintStream} with file} as its target. The
         * character set named csn} is used for character encoding.
         *
         * @param file
         *            the target file. If the file already exists, its contents are
         *            removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] IFile* file, 
            [in] String csn);

        /**
         * Constructs a new PrintStream} with the file identified by
         * fileName} as its target. The virtual machine's default character
         * set is used for character encoding.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a new PrintStream} with the file identified by
         * fileName} as its target. The character set named csn} is
         * used for character encoding.
         *
         * @param fileName
         *            the target file's name. If the file already exists, its
         *            contents are removed, otherwise a new file is created.
         * @param csn
         *            the name of the character set used for character encoding.
         * @throws FileNotFoundException
         *             if an error occurs while opening or creating the target file.
         * @throws NullPointerException
         *             if csn} is null
         * @throws SecurityException
         *             if a security manager exists and it denies writing to the
         *             target file.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by csn} is not supported.
         */
        constructor(
            [in] String fileName, 
            [in] String csn);

        interface IPrintStream;
    }
}

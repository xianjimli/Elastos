
module
{
    importlib("Elastos.Core.eco");

    merge("../../../car/Elastos/IO/Errors.car");
    merge("../../../car/Elastos/IO/Exceptions.car");
    merge("../../../car/Elastos/IO/IInputStream.car");
    merge("../../../car/Elastos/IO/IFilterInputStream.car");
    merge("../../../car/Elastos/IO/IBufferedInputStream.car");
    merge("../../../car/Elastos/IO/IOutputStream.car");
    merge("../../../car/Elastos/IO/IFilterOutputStream.car");
    merge("../../../car/Elastos/IO/IBufferedOutputStream.car");
    merge("../../../car/Elastos/IO/IByteArrayInputStream.car");
    merge("../../../car/Elastos/IO/IByteArrayOutputStream.car");
    merge("../../../car/Elastos/IO/IFileFilter.car");
    merge("../../../car/Elastos/IO/IFilenameFilter.car");
    merge("../../../car/Elastos/IO/IFile.car");
    merge("../../../car/Elastos/IO/IFileDescriptor.car");
    merge("../../../car/Elastos/IO/IFileInputStream.car");
    merge("../../../car/Elastos/IO/IFileOutputStream.car");
    merge("../../../car/Elastos/IO/IDataInput.car");
    merge("../../../car/Elastos/IO/IDataInputStream.car");
    merge("../../../car/Elastos/IO/IDataOutput.car");
    merge("../../../car/Elastos/IO/IDataOutputStream.car");
    merge("../../../car/Elastos/IO/IObjectInput.car");
    merge("../../../car/Elastos/IO/IObjectOutput.car");
    merge("../../../car/Elastos/IO/IObjectInputValidation.car");
    merge("../../../car/Elastos/IO/IReader.car");
    merge("../../../car/Elastos/IO/IWriter.car");
    merge("../../../car/Elastos/IO/ICharArrayReader.car");
    merge("../../../car/Elastos/IO/ICharArrayWriter.car");
    merge("../../../car/Elastos/IO/IBufferedReader.car");
    merge("../../../car/Elastos/IO/IBufferedWriter.car");
    merge("../../../car/Elastos/IO/IStringBufferInputStream.car");
    merge("../../../car/Elastos/IO/ILineNumberInputStream.car");
    merge("../../../car/Elastos/IO/ILineNumberReader.car");
    merge("../../../car/Elastos/IO/IPushbackInputStream.car");
    merge("../../../car/Elastos/IO/IPushbackReader.car");
    merge("../../../car/Elastos/IO/IFilePermission.car");
    merge("../../../car/Elastos/IO/IFilePermissionCollection.car");
    merge("../../../car/Elastos/IO/IInputStreamReader.car");
    merge("../../../car/Elastos/IO/IOutputStreamWriter.car");
    merge("../../../car/Elastos/IO/IPrintWriter.car");
    merge("../../../car/Elastos/IO/IStringReader.car");
    merge("../../../car/Elastos/IO/IStringWriter.car");
    merge("../../../car/Elastos/IO/ICloseable.car");
    merge("../../../car/Elastos/IO/IRandomAccessFile.car");
    /************************************NIO**********************************/
    merge("../../../car/Elastos/IO/ByteOrder.car");
    merge("../../../car/Elastos/IO/IBuffer.car");
    merge("../../../car/Elastos/IO/IByteBuffer.car");
    merge("../../../car/Elastos/IO/ICharBuffer.car");
    merge("../../../car/Elastos/IO/IDoubleBuffer.car");
    merge("../../../car/Elastos/IO/IFloatBuffer.car");
    merge("../../../car/Elastos/IO/IInt16Buffer.car");
    merge("../../../car/Elastos/IO/IInt32Buffer.car");
    merge("../../../car/Elastos/IO/IInt64Buffer.car");
    merge("../../../car/Elastos/IO/IMappedByteBuffer.car");
    merge("../../../car/Elastos/IO/Channels/IChannel.car");
    merge("../../../car/Elastos/IO/charset/ICharsetDecoder.car");
    merge("../../../car/Elastos/IO/charset/ICharsetEncoder.car");
    merge("../../../car/Elastos/IO/Channels/IChannels.car");
    merge("../../../car/Elastos/IO/Channels/IReadableByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IWritableByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IInterruptibleChannel.car");
    merge("../../../car/Elastos/IO/Channels/ISelectableChannel.car");
//    merge("../../../car/Elastos/IO/Channels/IDatagramChannel.car");
    merge("../../../car/Elastos/IO/Channels/IFileChannel.car");
    merge("../../../car/Elastos/IO/Channels/IFileLock.car");
    merge("../../../car/Elastos/IO/Channels/IGatheringByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/IPipe.car");
    merge("../../../car/Elastos/IO/Channels/IScatteringByteChannel.car");
    merge("../../../car/Elastos/IO/Channels/ISelectionKey.car");
    merge("../../../car/Elastos/IO/Channels/ISelector.car");
//    merge("../../../car/Elastos/IO/Channels/IServerSocketChannel.car");
    merge("../../../car/Elastos/IO/Channels/Spi/ISelectorProvider.car");




    class CFilterInputStream {
        /**
        * Constructs a new {@code FilterInputStream} with the specified input
        * stream as source.
        *
        * <p><strong>Warning:</strong> passing a null source creates an invalid
        * {@code FilterInputStream}, that fails on every method that is not
        * overridden. Subclasses should check for null in their constructors.
        *
        * @param in the input stream to filter reads on.
        */
        constructor(
            [in] IInputStream* is);

        interface IFilterInputStream;
    }

    class CRandomAccessFile{
        constructor(
            [in] IFile* pFile,
            [in] CString mode);

        constructor(
            [in] String fileName,
            [in] CString mode);

        interface IRandomAccessFile;
        interface IDataInput;
        interface IDataOutput;
    }

    class CBufferedInputStream {
        /**
         * Constructs a new {@code BufferedInputStream}, providing {@code in} with a buffer
         * of 8192 bytes.
         *
         * <p><strong>Warning:</strong> passing a null source creates a closed
         * {@code BufferedInputStream}. All read operations on such a stream will
         * fail with an IOException.
         *
         * @param in the {@code InputStream} the buffer reads from.
         */
        constructor(
            [in] IInputStream* is);

        /**
         * Constructs a new {@code BufferedInputStream}, providing {@code in} with {@code size} bytes
         * of buffer.
         *
         * <p><strong>Warning:</strong> passing a null source creates a closed
         * {@code BufferedInputStream}. All read operations on such a stream will
         * fail with an IOException.
         *
         * @param in the {@code InputStream} the buffer reads from.
         * @param size the size of buffer in bytes.
         * @throws IllegalArgumentException if {@code size <= 0}.
         */
        constructor(
            [in] IInputStream* is,
            [in] Int32 size);

        interface IBufferedInputStream;
    }

    class CFilterOutputStream {
        /**
         * Constructs a new {@code FilterOutputStream} with {@code out} as its
         * target stream.
         *
         * @param out
         *            the target stream that this stream writes to.
         */
        constructor(
            [in] IOutputStream* os);

        interface IFilterOutputStream;
    }

    class CBufferedOutputStream {
        /**
         * Constructs a new {@code BufferedOutputStream}, providing {@code out} with a buffer
         * of 8192 bytes.
         *
         * @param out the {@code OutputStream} the buffer writes to.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs a new {@code BufferedOutputStream}, providing {@code out} with {@code size} bytes
         * of buffer.
         *
         * @param out the {@code OutputStream} the buffer writes to.
         * @param size the size of buffer in bytes.
         * @throws IllegalArgumentException if {@code size <= 0}.
         */
        constructor(
            [in] IOutputStream* os,
            [in] Int32 size);

        interface IBufferedOutputStream;
    }

    class CByteArrayInputStream {
        /**
         * Constructs a new {@code ByteArrayInputStream} on the byte array
         * {@code buf}.
         *
         * @param buf
         *            the byte array to stream over.
         */
        constructor(
            [in] BufferOf<Byte> buffer);

        /**
         * Constructs a new {@code ByteArrayInputStream} on the byte array
         * {@code buf} with the initial position set to {@code offset} and the
         * number of bytes available set to {@code offset} + {@code length}.
         *
         * @param buf
         *            the byte array to stream over.
         * @param offset
         *            the initial position in {@code buf} to start streaming from.
         * @param length
         *            the number of bytes available for streaming.
         */
        constructor(
            [in] BufferOf<Byte> buffer,
            [in] Int32 offset,
            [in] Int32 length);

        interface IByteArrayInputStream;
    }

    class CByteArrayOutputStream {
        /**
         * Constructs a new ByteArrayOutputStream with a default size of 32 bytes.
         * If more than 32 bytes are written to this instance, the underlying byte
         * array will expand.
         */
        constructor();

        /**
         * Constructs a new {@code ByteArrayOutputStream} with a default size of
         * {@code size} bytes. If more than {@code size} bytes are written to this
         * instance, the underlying byte array will expand.
         *
         * @param size
         *            initial size for the underlying byte array, must be
         *            non-negative.
         * @throws IllegalArgumentException
         *             if {@code size} < 0.
         */
        constructor(
            [in] Int32 size);

        interface IByteArrayOutputStream;
    }

    class CFile {
        /**
         * Constructs a new file using the specified directory and name.
         *
         * @param dir
         *            the directory where the file is stored.
         * @param name
         *            the file's name.
         * @throws NullPointerException
         *             if {@code name} is {@code null}.
         */
        constructor(
            [in] IFile* dir,
            [in] String name);

        /**
         * Constructs a new file using the specified path.
         *
         * @param path
         *            the path to be used for the file.
         */
        constructor(
            [in] String path);

        /**
         * Constructs a new File using the specified directory path and file name,
         * placing a path separator between the two.
         *
         * @param dirPath
         *            the path to the directory where the file is stored.
         * @param name
         *            the file's name.
         * @throws NullPointerException
         *             if {@code name} is {@code null}.
         */
        constructor(
            [in] String dirPath,
            [in] String name);

        /**
         * Constructs a new File using the path of the specified URI. {@code uri}
         * needs to be an absolute and hierarchical Unified Resource Identifier with
         * file scheme and non-empty path component, but with undefined authority,
         * query or fragment components.
         *
         * @param uri
         *            the Unified Resource Identifier that is used to construct this
         *            file.
         * @throws IllegalArgumentException
         *             if {@code uri} does not comply with the conditions above.
         * @see #toURI
         * @see java.net.URI
         */
//        constructor(
//            [in] IURI* uri);

        interface IFile;
    }

    class CFileDescriptor {
        interface IFileDescriptor;
    }

    class CFileInputStream {
        /**
         * Constructs a new {@code FileInputStream} based on {@code file}.
         *
         * @param file
         *            the file from which this stream reads.
         * @throws FileNotFoundException
         *             if {@code file} does not exist.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             read request.
         */
        constructor(
            [in] IFile* file);
        /**
         * Constructs a new {@code FileInputStream} on the {@link FileDescriptor}
         * {@code fd}. The file must already be open, therefore no
         * {@code FileNotFoundException} will be thrown.
         *
         * @param fd
         *            the FileDescriptor from which this stream reads.
         * @throws NullPointerException
         *             if {@code fd} is {@code null}.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             read request.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Constructs a new {@code FileInputStream} on the file named
         * {@code fileName}. The path of {@code fileName} may be absolute or
         * relative to the system property {@code "user.dir"}.
         *
         * @param fileName
         *            the path and name of the file from which this stream reads.
         * @throws FileNotFoundException
         *             if there is no file named {@code fileName}.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             read request.
         */
        constructor(
            [in] String fileName);

        interface IFileInputStream;
    }

    class CFileOutputStream {
        /**
         * Constructs a new FileOutputStream on the File {@code file}. If the file
         * exists, it is overwritten.
         *
         * @param file
         *            the file to which this stream writes.
         * @throws FileNotFoundException
         *             if {@code file} cannot be opened for writing.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a new FileOutputStream on the File {@code file}. The
         * parameter {@code append} determines whether or not the file is opened and
         * appended to or just opened and overwritten.
         *
         * @param file
         *            the file to which this stream writes.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws FileNotFoundException
         *             if the {@code file} cannot be opened for writing.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         * @see java.lang.SecurityManager#checkWrite(String)
         */
        constructor(
            [in] IFile* file,
            [in] Boolean append);

        /**
         * Constructs a new FileOutputStream on the FileDescriptor {@code fd}. The
         * file must already be open, therefore no {@code FileNotFoundException}
         * will be thrown.
         *
         * @param fd
         *            the FileDescriptor to which this stream writes.
         * @throws NullPointerException
         *             if {@code fd} is {@code null}.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             write request.
         * @see java.lang.SecurityManager#checkWrite(FileDescriptor)
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Constructs a new FileOutputStream on the file named {@code filename}. If
         * the file exists, it is overwritten. The {@code filename} may be absolute
         * or relative to the system property {@code "user.dir"}.
         *
         * @param filename
         *            the name of the file to which this stream writes.
         * @throws FileNotFoundException
         *             if the file cannot be opened for writing.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             write request.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a new FileOutputStream on the file named {@code filename}.
         * The parameter {@code append} determines whether or not the file is opened
         * and appended to or just opened and overwritten. The {@code filename} may
         * be absolute or relative to the system property {@code "user.dir"}.
         *
         * @param filename
         *            the name of the file to which this stream writes.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws FileNotFoundException
         *             if the file cannot be opened for writing.
         * @throws SecurityException
         *             if a {@code SecurityManager} is installed and it denies the
         *             write request.
         */
        constructor(
            [in] String fileName,
            [in] Boolean append);

        interface IFileOutputStream;
    }

    class CDataInputStream {
        /**
         * Constructs a new DataInputStream on the InputStream {@code in}. All
         * reads are then filtered through this stream. Note that data read by this
         * stream is not in a human readable format and was most likely created by a
         * DataOutputStream.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * {@code DataInputStream}. All operations on such a stream will fail.
         *
         * @param in
         *            the source InputStream the filter reads from.
         * @see DataOutputStream
         * @see RandomAccessFile
         */
        constructor(
            [in] IInputStream* is);

        interface IDataInput;
        interface IDataInputStream;
    }

    class CDataOutputStream {
        /**
         * Constructs a new {@code DataOutputStream} on the {@code OutputStream}
         * {@code out}. Note that data written by this stream is not in a human
         * readable form but can be reconstructed by using a {@link DataInputStream}
         * on the resulting output.
         *
         * @param out
         *            the target stream for writing.
         */
        constructor(
            [in] IOutputStream* os);

        interface IDataOutput;
        interface IDataOutputStream;
    }

    [deprecated]
    class CCharArrayReader {
        /**
         * Constructs a CharArrayReader on the char array {@code buf}. The size of
         * the reader is set to the length of the buffer and the object to to read
         * from is set to {@code buf}.
         *
         * @param buf
         *            the char array from which to read.
         */
        constructor(
            [in] ArrayOf<Char8> buf);

        /**
         * Constructs a CharArrayReader on the char array {@code buf}. The size of
         * the reader is set to {@code length} and the start position from which to
         * read the buffer is set to {@code offset}.
         *
         * @param buf
         *            the char array from which to read.
         * @param offset
         *            the index of the first character in {@code buf} to read.
         * @param length
         *            the number of characters that can be read from {@code buf}.
         * @throws IllegalArgumentException
         *             if {@code offset < 0} or {@code length < 0}, or if
         *             {@code offset} is greater than the size of {@code buf} .
         */
        constructor(
            [in] ArrayOf<Char8> buf,
            [in] Int32 offset,
            [in] Int32 length);

        interface ICharArrayReader;
    }

    class CCharArrayWriter {
        /**
         * Constructs a new {@code CharArrayWriter} which has a buffer allocated
         * with the default size of 32 characters. This buffer is also used as the
         * {@code lock} to synchronize access to this writer.
         */
        constructor();
        /**
         * Constructs a new {@code CharArrayWriter} which has a buffer allocated
         * with the size of {@code initialSize} characters. The buffer is also used
         * as the {@code lock} to synchronize access to this writer.
         *
         * @param initialSize
         *            the initial size of this CharArrayWriters buffer.
         * @throws IllegalArgumentException
         *             if {@code initialSize < 0}.
         */
        constructor(
            [in] Int32 initialSize);

        interface ICharArrayWriter;
    }

    class CBufferedReader {
        /**
        * Constructs a new {@code BufferedReader}, providing {@code in} with a buffer
        * of 8192 characters.
        *
        * @param in the {@code Reader} the buffer reads from.
        */
        constructor(
            [in] IReader* rin);

        /**
        * Constructs a new {@code BufferedReader}, providing {@code in} with {@code size} characters
        * of buffer.
        *
        * @param in the {@code InputStream} the buffer reads from.
        * @param size the size of buffer in characters.
        * @throws IllegalArgumentException if {@code size <= 0}.
        */
        constructor(
            [in] IReader* rin,
            [in] Int32 size);

        interface IBufferedReader;
    }

    class CBufferedWriter {
        /**
         * Constructs a new {@code BufferedWriter}, providing {@code out} with a buffer
         * of 8192 bytes.
         *
         * @param out the {@code Writer} the buffer writes to.
         */
        constructor(
            [in] IWriter* wout);

        /**
         * Constructs a new {@code BufferedWriter}, providing {@code out} with {@code size} bytes
         * of buffer.
         *
         * @param out the {@code OutputStream} the buffer writes to.
         * @param size the size of buffer in bytes.
         * @throws IllegalArgumentException if {@code size <= 0}.
         */
        constructor(
            [in] IWriter* wout,
            [in] Int32 size);

        interface IBufferedWriter;
    }

    class CStringBufferInputStream {
        /**
         * Construct a new {@code StringBufferInputStream} with {@code str} as
         * source. The size of the stream is set to the {@code length()} of the
         * string.
         *
         * @param str
         *            the source string for this stream.
         * @throws NullPointerException
         *             if {@code str} is {@code null}.
         */
        constructor(
            [in] String str);

        interface IStringBufferInputStream;
    }

    class CLineNumberInputStream {
        /**
         * Constructs a new {@code LineNumberInputStream} on the {@link InputStream}
         * {@code in}. Line numbers are counted for all data read from this stream.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * {@code LineNumberInputStream}. All operations on such a stream will fail.
         *
         * @param in
         *            The non-null input stream to count line numbers.
         */
        constructor(
            [in] IInputStream* is);

        interface ILineNumberInputStream;
    }

    class CLineNumberReader {
        /**
         * Constructs a new LineNumberReader on the Reader {@code in}. The internal
         * buffer gets the default size (8 KB).
         *
         * @param in
         *            the Reader that is buffered.
         */
        constructor(
            [in] IReader* ir);
        /**
         * Constructs a new LineNumberReader on the Reader {@code in}. The size of
         * the internal buffer is specified by the parameter {@code size}.
         *
         * @param in
         *            the Reader that is buffered.
         * @param size
         *            the size of the buffer to allocate.
         * @throws IllegalArgumentException
         *             if {@code size <= 0}.
         */
        constructor(
            [in] IReader* ir,
            [in] Int32 size);

        interface ILineNumberReader;
    }

    class CPushbackInputStream {
        /**
         * Constructs a new {@code PushbackInputStream} with the specified input
         * stream as source. The size of the pushback buffer is set to the default
         * value of 1 byte.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * {@code PushbackInputStream}. All read operations on such a stream will
         * fail.
         *
         * @param in
         *            the source input stream.
         */
        constructor(
            [in] IInputStream* is);
        /**
         * Constructs a new {@code PushbackInputStream} with {@code in} as source
         * input stream. The size of the pushback buffer is set to {@code size}.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * {@code PushbackInputStream}. All read operations on such a stream will
         * fail.
         *
         * @param in
         *            the source input stream.
         * @param size
         *            the size of the pushback buffer.
         * @throws IllegalArgumentException
         *             if {@code size} is negative.
         */
        constructor(
            [in] IInputStream* is,
            [in] Int32 size);

        interface IPushbackInputStream;
    }

    class CPushbackReader {
        /**
         * Constructs a new {@code PushbackReader} with the specified reader as
         * source. The size of the pushback buffer is set to the default value of 1
         * character.
         *
         * @param in
         *            the source reader.
         */
        constructor(
            [in] IReader* ir);
        /**
         * Constructs a new {@code PushbackReader} with {@code in} as source reader.
         * The size of the pushback buffer is set to {@code size}.
         *
         * @param in
         *            the source reader.
         * @param size
         *            the size of the pushback buffer.
         * @throws IllegalArgumentException
         *             if {@code size} is negative.
         */
        constructor(
            [in] IReader* ir,
            [in] Int32 size);

        interface IPushbackReader;
    }

    class CFilePermission {
        /**
         * Constructs a new FilePermission with the path and actions specified.
         *
         * @param path
         *            the pathname of the file or directory to apply the actions to.
         * @param actions
         *            the actions for the {@code path}. May be any combination of
         *            "read", "write", "execute" and "delete".
         * @throws IllegalArgumentException
         *             if {@code actions} is {@code null} or an empty string, or if
         *             it contains a string other than "read", "write", "execute"
         *             and "delete".
         * @throws NullPointerException
         *             if {@code path} is {@code null}.
         */
        constructor(
            [in] String path,
            [in] String actions);

        interface IFilePermission;
    }

    class CFilePermissionCollection {
        interface IFilePermissionCollection;
    }

    class CSequenceInputStream {
        /**
         * Constructs a new {@code SequenceInputStream} using the two streams
         * {@code s1} and {@code s2} as the sequence of streams to read from.
         *
         * @param s1
         *            the first stream to get bytes from.
         * @param s2
         *            the second stream to get bytes from.
         * @throws NullPointerException
         *             if {@code s1} is {@code null}.
         */
        constructor(
            [in] IInputStream *s1,
            [in] IInputStream *s2);

        /**
         * Constructs a new SequenceInputStream using the elements returned from
         * Enumeration {@code e} as the stream sequence. The instances returned by
         * {@code e.nextElement()} must be of type {@link InputStream}.
         *
         * @param e
         *            the enumeration of {@code InputStreams} to get bytes from.
         * @throws NullPointerException
         *             if any of the elements in {@code e} is {@code null}.
         */
        constructor(
            [in] IObjectEnumerator* e);

        interface IInputStream;
    }

    class CInputStreamReader {
        /**
         * Constructs a new {@code InputStreamReader} on the {@link InputStream}
         * {@code in}. This constructor sets the character converter to the encoding
         * specified in the "file.encoding" property and falls back to ISO 8859_1
         * (ISO-Latin-1) if the property doesn't exist.
         *
         * @param in
         *            the input stream from which to read characters.
         */
        constructor(
            [in] IInputStream* is);

        /**
         * Constructs a new InputStreamReader on the InputStream {@code in}. The
         * character converter that is used to decode bytes into characters is
         * identified by name by {@code enc}. If the encoding cannot be found, an
         * UnsupportedEncodingException error is thrown.
         *
         * @param in
         *            the InputStream from which to read characters.
         * @param enc
         *            identifies the character converter to use.
         * @throws NullPointerException
         *             if {@code enc} is {@code null}.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by {@code enc} cannot be found.
         */
        constructor(
            [in] IInputStream* is,
            [in] String enc);

//        /**
//         * Constructs a new InputStreamReader on the InputStream {@code in} and
//         * CharsetDecoder {@code dec}.
//         *
//         * @param in
//         *            the source InputStream from which to read characters.
//         * @param dec
//         *            the CharsetDecoder used by the character conversion.
//         */
//        constructor(
//            [in] IInputStream* in,
//            [in] CharsetDecoder dec);
//
//        /**
//         * Constructs a new InputStreamReader on the InputStream {@code in} and
//         * Charset {@code charset}.
//         *
//         * @param in
//         *            the source InputStream from which to read characters.
//         * @param charset
//         *            the Charset that defines the character converter
//         */
//        constructor(
//            [in] IInputStream* in,
//            [in] Charset charset);

        interface IInputStreamReader;
    }

    class COutputStreamWriter {
        /**
         * Constructs a new OutputStreamWriter using {@code out} as the target
         * stream to write converted characters to. The default character encoding
         * is used.
         *
         * @param out
         *            the non-null target stream to write converted bytes to.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs a new OutputStreamWriter using {@code out} as the target
         * stream to write converted characters to and {@code enc} as the character
         * encoding. If the encoding cannot be found, an
         * UnsupportedEncodingException error is thrown.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param enc
         *            the string describing the desired character encoding.
         * @throws NullPointerException
         *             if {@code enc} is {@code null}.
         * @throws UnsupportedEncodingException
         *             if the encoding specified by {@code enc} cannot be found.
         */
        constructor(
            [in] IOutputStream* os,
            [in] String enc);

        /**
         * Constructs a new OutputStreamWriter using {@code out} as the target
         * stream to write converted characters to and {@code cs} as the character
         * encoding.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param cs
         *            the {@code Charset} that specifies the character encoding.
         */
//        constructor(
//            [in] IOutputStream* os,
//            [in] Charset cs);

        /**
         * Constructs a new OutputStreamWriter using {@code out} as the target
         * stream to write converted characters to and {@code enc} as the character
         * encoder.
         *
         * @param out
         *            the target stream to write converted bytes to.
         * @param enc
         *            the character encoder used for character conversion.
         */
//        constructor(
//            [in] IOutputStream* os,
//            [in] CharsetEncoder enc);

        interface IOutputStreamWriter;
    }

    class CFileReader {
        /**
         * Constructs a new FileReader on the given {@code file}.
         *
         * @param file
         *            a File to be opened for reading characters from.
         * @throws FileNotFoundException
         *             if {@code file} does not exist.
         */
        constructor(
            [in] IFile* file);

        /**
         * Construct a new FileReader on the given FileDescriptor {@code fd}. Since
         * a previously opened FileDescriptor is passed as an argument, no
         * FileNotFoundException can be thrown.
         *
         * @param fd
         *            the previously opened file descriptor.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Construct a new FileReader on the given file named {@code filename}.
         *
         * @param filename
         *            an absolute or relative path specifying the file to open.
         * @throws FileNotFoundException
         *             if there is no file named {@code filename}.
         */
        constructor(
            [in] String filename);

        interface IInputStreamReader;
    }

    class CFileWriter {
        /**
         * Creates a FileWriter using the File {@code file}.
         *
         * @param file
         *            the non-null File to write bytes to.
         * @throws IOException
         *             if {@code file} cannot be opened for writing.
         */
        constructor(
            [in] IFile* file);

        /**
         * Creates a FileWriter using the File {@code file}. The parameter
         * {@code append} determines whether or not the file is opened and appended
         * to or just opened and overwritten.
         *
         * @param file
         *            the non-null File to write bytes to.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws IOException
         *             if the {@code file} cannot be opened for writing.
         */
        constructor(
            [in] IFile* file,
            [in] Boolean append);

        /**
         * Creates a FileWriter using the existing FileDescriptor {@code fd}.
         *
         * @param fd
         *            the non-null FileDescriptor to write bytes to.
         */
        constructor(
            [in] IFileDescriptor* fd);

        /**
         * Creates a FileWriter using the platform dependent {@code filename}.
         *
         * @param filename
         *            the non-null name of the file to write bytes to.
         * @throws IOException
         *             if the file cannot be opened for writing.
         */
        constructor(
            [in] String filename);

        /**
         * Creates a FileWriter using the platform dependent {@code filename}. The
         * parameter {@code append} determines whether or not the file is opened and
         * appended to or just opened and overwritten.
         *
         * @param filename
         *            the non-null name of the file to write bytes to.
         * @param append
         *            indicates whether or not to append to an existing file.
         * @throws IOException
         *             if the {@code file} cannot be opened for writing.
         */
        constructor(
            [in] String filename,
            [in] Boolean append);

        interface IOutputStreamWriter;
    }

    class CStringReader {
        /**
         * Construct a new {@code StringReader} with {@code str} as source. The size
         * of the reader is set to the {@code length()} of the string and the Object
         * to synchronize access through is set to {@code str}.
         *
         * @param str
         *            the source string for this reader.
         */
        constructor(
            [in] String str);

        interface IStringReader;
    }

    class CStringWriter {
        /**
         * Constructs a new {@code StringWriter} which has a {@link StringBuffer}
         * allocated with the default size of 16 characters. The {@code
         * StringBuffer} is also the {@code lock} used to synchronize access to this
         * writer.
         */
        constructor();

        /**
         * Constructs a new {@code StringWriter} which has a {@link StringBuffer}
         * allocated with a size of {@code initialSize} characters. The {@code
         * StringBuffer} is also the {@code lock} used to synchronize access to this
         * writer.
         *
         * @param initialSize
         *            the intial size of the target string buffer.
         */
        constructor(
            [in] Int32 initialSize);

        interface IStringWriter;
    }
<<<<<<< HEAD

    singleton class CByteBufferHelper {
        interface IByteBufferHelper;
    }
=======
	
	singleton class CChannels {
		constructor();
		
		interface IChannels;
	}
>>>>>>> Provided IChannels::NewChannel() interface
}
